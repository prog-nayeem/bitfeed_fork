
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() {}

    const identity = x => x;

    function assign(tar, src) {
      // @ts-ignore
      for (const k in src) tar[k] = src[k];

      return tar;
    }

    function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
        loc: {
          file,
          line,
          column,
          char
        }
      };
    }

    function run(fn) {
      return fn();
    }

    function blank_object() {
      return Object.create(null);
    }

    function run_all(fns) {
      fns.forEach(run);
    }

    function is_function(thing) {
      return typeof thing === 'function';
    }

    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
    }

    let src_url_equal_anchor;

    function src_url_equal(element_src, url) {
      if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
      }

      src_url_equal_anchor.href = url;
      return element_src === src_url_equal_anchor.href;
    }

    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }

    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }

    function subscribe(store) {
      if (store == null) {
        return noop;
      }

      for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        callbacks[_key - 1] = arguments[_key];
      }

      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
    }

    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }

    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }

    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));

        if ($$scope.dirty === undefined) {
          return lets;
        }

        if (typeof lets === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);

          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }

          return merged;
        }

        return $$scope.dirty | lets;
      }

      return $$scope.dirty;
    }

    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }

    function get_all_dirty_from_scope($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;

        for (let i = 0; i < length; i++) {
          dirty[i] = -1;
        }

        return dirty;
      }

      return -1;
    }

    function set_store_value(store, ret, value) {
      store.set(value);
      return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client ? () => window.performance.now() : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

    const tasks = new Set();

    function run_tasks(now) {
      tasks.forEach(task => {
        if (!task.c(now)) {
          tasks.delete(task);
          task.f();
        }
      });
      if (tasks.size !== 0) raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */


    function loop(callback) {
      let task;
      if (tasks.size === 0) raf(run_tasks);
      return {
        promise: new Promise(fulfill => {
          tasks.add(task = {
            c: callback,
            f: fulfill
          });
        }),

        abort() {
          tasks.delete(task);
        }

      };
    } // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

    function append(target, node) {
      target.appendChild(node);
    }

    function get_root_for_style(node) {
      if (!node) return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

      if (root && root.host) {
        return root;
      }

      return node.ownerDocument;
    }

    function append_empty_stylesheet(node) {
      const style_element = element('style');
      append_stylesheet(get_root_for_style(node), style_element);
      return style_element;
    }

    function append_stylesheet(node, style) {
      append(node.head || node, style);
    }

    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }

    function detach(node) {
      node.parentNode.removeChild(node);
    }

    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i]) iterations[i].d(detaching);
      }
    }

    function element(name) {
      return document.createElement(name);
    }

    function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function space() {
      return text(' ');
    }

    function empty() {
      return text('');
    }

    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }

    function prevent_default(fn) {
      return function (event) {
        event.preventDefault(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function attr(node, attribute, value) {
      if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
    }

    function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === 'style') {
          node.style.cssText = attributes[key];
        } else if (key === '__value') {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr(node, key, attributes[key]);
        }
      }
    }

    function set_custom_element_data(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
      } else {
        attr(node, prop, value);
      }
    }

    function xlink_attr(node, attribute, value) {
      node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }

    function children(element) {
      return Array.from(element.childNodes);
    }

    function set_input_value(input, value) {
      input.value = value == null ? '' : value;
    }

    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? 'important' : '');
    }
    // so we cache the result instead


    let crossorigin;

    function is_crossorigin() {
      if (crossorigin === undefined) {
        crossorigin = false;

        try {
          if (typeof window !== 'undefined' && window.parent) {
            void window.parent.document;
          }
        } catch (error) {
          crossorigin = true;
        }
      }

      return crossorigin;
    }

    function add_resize_listener(node, fn) {
      const computed_style = getComputedStyle(node);

      if (computed_style.position === 'static') {
        node.style.position = 'relative';
      }

      const iframe = element('iframe');
      iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
      iframe.setAttribute('aria-hidden', 'true');
      iframe.tabIndex = -1;
      const crossorigin = is_crossorigin();
      let unsubscribe;

      if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', event => {
          if (event.source === iframe.contentWindow) fn();
        });
      } else {
        iframe.src = 'about:blank';

        iframe.onload = () => {
          unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
      }

      append(node, iframe);
      return () => {
        if (crossorigin) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }

        detach(iframe);
      };
    }

    function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
    }

    function custom_event(type, detail) {
      let bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, bubbles, false, detail);
      return e;
    }

    class HtmlTag {
      constructor() {
        this.e = this.n = null;
      }

      c(html) {
        this.h(html);
      }

      m(html, target) {
        let anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (!this.e) {
          this.e = element(target.nodeName);
          this.t = target;
          this.c(html);
        }

        this.i(anchor);
      }

      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }

      i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }

      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }

      d() {
        this.n.forEach(detach);
      }

    }

    const active_docs = new Set();
    let active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

    function hash$2(str) {
      let hash = 5381;
      let i = str.length;

      while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);

      return hash >>> 0;
    }

    function create_rule(node, a, b, duration, delay, ease, fn) {
      let uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      const step = 16.666 / duration;
      let keyframes = '{\n';

      for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
      }

      const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
      const name = `__svelte_${hash$2(rule)}_${uid}`;
      const doc = get_root_for_style(node);
      active_docs.add(doc);
      const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
      const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});

      if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }

      const animation = node.style.animation || '';
      node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }

    function delete_rule(node, name) {
      const previous = (node.style.animation || '').split(', ');
      const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
      : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
      );
      const deleted = previous.length - next.length;

      if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active) clear_rules();
      }
    }

    function clear_rules() {
      raf(() => {
        if (active) return;
        active_docs.forEach(doc => {
          const stylesheet = doc.__svelte_stylesheet;
          let i = stylesheet.cssRules.length;

          while (i--) stylesheet.deleteRule(i);

          doc.__svelte_rules = {};
        });
        active_docs.clear();
      });
    }

    function create_animation(node, from, fn, params) {
      if (!from) return noop;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;
      const {
        delay = 0,
        duration = 300,
        easing = identity,
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay,
        // @ts-ignore todo:
        end = start_time + duration,
        tick = noop,
        css
      } = fn(node, {
        from,
        to
      }, params);
      let running = true;
      let started = false;
      let name;

      function start() {
        if (css) {
          name = create_rule(node, 0, 1, duration, delay, easing, css);
        }

        if (!delay) {
          started = true;
        }
      }

      function stop() {
        if (css) delete_rule(node, name);
        running = false;
      }

      loop(now => {
        if (!started && now >= start_time) {
          started = true;
        }

        if (started && now >= end) {
          tick(1, 0);
          stop();
        }

        if (!running) {
          return false;
        }

        if (started) {
          const p = now - start_time;
          const t = 0 + 1 * easing(p / duration);
          tick(t, 1 - t);
        }

        return true;
      });
      start();
      tick(0, 1);
      return stop;
    }

    function fix_position(node) {
      const style = getComputedStyle(node);

      if (style.position !== 'absolute' && style.position !== 'fixed') {
        const {
          width,
          height
        } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
      }
    }

    function add_transform(node, a) {
      const b = node.getBoundingClientRect();

      if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
      }
    }

    let current_component;

    function set_current_component(component) {
      current_component = component;
    }

    function get_current_component() {
      if (!current_component) throw new Error('Function called outside component initialization');
      return current_component;
    }

    function beforeUpdate(fn) {
      get_current_component().$$.before_update.push(fn);
    }

    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }

    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];

        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event(type, detail);
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
        }
      };
    }
    // shorthand events, or if we want to implement
    // a real bubbling mechanism


    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];

      if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
      }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;

    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }

    function tick() {
      schedule_update();
      return resolved_promise;
    }

    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }

    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    } // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.


    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function

    function flush() {
      const saved_component = current_component;

      do {
        // first, call beforeUpdate functions
        // and update components
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$$);
        }

        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;

        while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...


        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];

          if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);
            callback();
          }
        }

        render_callbacks.length = 0;
      } while (dirty_components.length);

      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }

      update_scheduled = false;
      seen_callbacks.clear();
      set_current_component(saved_component);
    }

    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }

    let promise;

    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }

      return promise;
    }

    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }

    const outroing = new Set();
    let outros;

    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group

      };
    }

    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }

      outros = outros.p;
    }

    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }

    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block)) return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);

          if (callback) {
            if (detach) block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }

    const null_transition = {
      duration: 0
    };

    function create_in_transition(node, fn, params) {
      let config = fn(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;

      function cleanup() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task) task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(1, 0);
              dispatch(node, true, 'end');
              cleanup();
              return running = false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(t, 1 - t);
            }
          }

          return running;
        });
      }

      let started = false;
      return {
        start() {
          if (started) return;
          started = true;
          delete_rule(node);

          if (is_function(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },

        invalidate() {
          started = false;
        },

        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }

      };
    }

    function create_out_transition(node, fn, params) {
      let config = fn(node, params);
      let running = true;
      let animation_name;
      const group = outros;
      group.r += 1;

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(0, 1);
              dispatch(node, false, 'end');

              if (! --group.r) {
                // this will result in `end()` being called,
                // so we don't need to clean up here
                run_all(group.c);
              }

              return false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(1 - t, t);
            }
          }

          return running;
        });
      }

      if (is_function(config)) {
        wait().then(() => {
          // @ts-ignore
          config = config();
          go();
        });
      } else {
        go();
      }

      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }

          if (running) {
            if (animation_name) delete_rule(node, animation_name);
            running = false;
          }
        }

      };
    }

    function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;

      function clear_animation() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
          a: t,
          b: program.b,
          d,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }

      function go(b) {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        const program = {
          start: now() + delay,
          b
        };

        if (!b) {
          // @ts-ignore todo: improve typings
          program.group = outros;
          outros.r += 1;
        }

        if (running_program || pending_program) {
          pending_program = program;
        } else {
          // if this is an intro, and there's a delay, we need to do
          // an initial tick and/or apply CSS animation immediately
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, b, duration, delay, easing, css);
          }

          if (b) tick(0, 1);
          running_program = init(program, duration);
          add_render_callback(() => dispatch(node, b, 'start'));
          loop(now => {
            if (pending_program && now > pending_program.start) {
              running_program = init(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, 'start');

              if (css) {
                clear_animation();
                animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }

            if (running_program) {
              if (now >= running_program.end) {
                tick(t = running_program.b, 1 - t);
                dispatch(node, running_program.b, 'end');

                if (!pending_program) {
                  // we're done
                  if (running_program.b) {
                    // intro — we can tidy up immediately
                    clear_animation();
                  } else {
                    // outro — needs to be coordinated
                    if (! --running_program.group.r) run_all(running_program.group.c);
                  }
                }

                running_program = null;
              } else if (now >= running_program.start) {
                const p = now - running_program.start;
                t = running_program.a + running_program.d * easing(p / running_program.duration);
                tick(t, 1 - t);
              }
            }

            return !!(running_program || pending_program);
          });
        }
      }

      return {
        run(b) {
          if (is_function(config)) {
            wait().then(() => {
              // @ts-ignore
              config = config();
              go(b);
            });
          } else {
            go(b);
          }
        },

        end() {
          clear_animation();
          running_program = pending_program = null;
        }

      };
    }

    const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }

    function fix_and_outro_and_destroy_block(block, lookup) {
      block.f();
      outro_and_destroy_block(block, lookup);
    }

    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};

      while (i--) old_indexes[old_blocks[i].key] = i;

      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;

      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);

        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }

        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
      }

      const will_move = new Set();
      const did_move = new Set();

      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }

      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;

        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }

      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
      }

      while (n) insert(new_blocks[n - 1]);

      return new_blocks;
    }

    function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();

      for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));

        if (keys.has(key)) {
          throw new Error('Cannot have duplicate keys in a keyed each');
        }

        keys.add(key);
      }
    }

    function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = {
        $$scope: 1
      };
      let i = levels.length;

      while (i--) {
        const o = levels[i];
        const n = updates[i];

        if (n) {
          for (const key in o) {
            if (!(key in n)) to_null_out[key] = 1;
          }

          for (const key in n) {
            if (!accounted_for[key]) {
              update[key] = n[key];
              accounted_for[key] = 1;
            }
          }

          levels[i] = n;
        } else {
          for (const key in o) {
            accounted_for[key] = 1;
          }
        }
      }

      for (const key in to_null_out) {
        if (!(key in update)) update[key] = undefined;
      }

      return update;
    }

    function get_spread_object(spread_props) {
      return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    } // source: https://html.spec.whatwg.org/multipage/indices.html

    function bind(component, name, callback) {
      const index = component.$$.props[name];

      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }

    function create_component(block) {
      block && block.c();
    }

    function mount_component(component, target, anchor, customElement) {
      const {
        fragment,
        on_mount,
        on_destroy,
        after_update
      } = component.$$;
      fragment && fragment.m(target, anchor);

      if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
          const new_on_destroy = on_mount.map(run).filter(is_function);

          if (on_destroy) {
            on_destroy.push(...new_on_destroy);
          } else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
          }

          component.$$.on_mount = [];
        });
      }

      after_update.forEach(add_render_callback);
    }

    function destroy_component(component, detaching) {
      const $$ = component.$$;

      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)

        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }

    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }

      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }

    function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
      let dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
        const value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;

        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }

        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update); // `false` as a special case of no DOM component

      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

      if (options.target) {
        if (options.hydrate) {
          const nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }

        if (options.intro) transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
      }

      set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */


    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }

      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }

      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }

    }

    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({
        version: '3.44.3'
      }, detail), true));
    }

    function append_dev(target, node) {
      dispatch_dev('SvelteDOMInsert', {
        target,
        node
      });
      append(target, node);
    }

    function insert_dev(target, node, anchor) {
      dispatch_dev('SvelteDOMInsert', {
        target,
        node,
        anchor
      });
      insert(target, node, anchor);
    }

    function detach_dev(node) {
      dispatch_dev('SvelteDOMRemove', {
        node
      });
      detach(node);
    }

    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default) modifiers.push('preventDefault');
      if (has_stop_propagation) modifiers.push('stopPropagation');
      dispatch_dev('SvelteDOMAddEventListener', {
        node,
        event,
        handler,
        modifiers
      });
      const dispose = listen(node, event, handler, options);
      return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', {
          node,
          event,
          handler,
          modifiers
        });
        dispose();
      };
    }

    function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
        node,
        attribute
      });else dispatch_dev('SvelteDOMSetAttribute', {
        node,
        attribute,
        value
      });
    }

    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev('SvelteDOMSetProperty', {
        node,
        property,
        value
      });
    }

    function set_data_dev(text, data) {
      data = '' + data;
      if (text.wholeText === data) return;
      dispatch_dev('SvelteDOMSetData', {
        node: text,
        data
      });
      text.data = data;
    }

    function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';

        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
          msg += ' You can use a spread to convert this iterable into an array.';
        }

        throw new Error(msg);
      }
    }

    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */


    class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error("'target' is a required option");
        }

        super();
      }

      $destroy() {
        super.$destroy();

        this.$destroy = () => {
          console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
      }

      $capture_state() {}

      $inject_state() {}

    }

    // Inject process.env variables
    if (!window.injected) window.injected = {};
    if (!window.injected.TARGET) window.injected.TARGET = undefined;
    if (!window.injected.OVERRIDE_BACKEND_HOST) window.injected.OVERRIDE_BACKEND_HOST = undefined;
    if (!window.injected.OVERRIDE_BACKEND_PORT) window.injected.OVERRIDE_BACKEND_PORT = undefined;

    function getInjectedEnv(key, fallback) {
      if (window.injected[key] != null && window.injected[key] != "") {
        return window.injected[key];
      }

      return fallback;
    }

    var config$1 = {
      dev: undefined === "development",
      // external API for processing donations, retrieving donor info & message bar content
      donationRoot: "https://donate.bitfeed.live",
      // enables some additional logging & debugging tools
      debug: false,
      // enables an additional square packing algorithm debugging tool
      layoutHints: false,
      // if this instance is public-facing, enables e.g. analytics
      target: getInjectedEnv("TARGET"),
      public: getInjectedEnv("TARGET", "dev") === "public",
      // host & port of the backend API websocket server
      backend: "bits.monospace.live",
      // do not include the protocol
      backendPort: null,
      // Whether to connect to the backend server over ws:// or wss://
      secureSocket: window.location.protocol === "http:",
      // Disables the transaction feed
      noTxFeed: false,
      noBlockFeed: false,
      // Minimum delay in ms before newly recieved transactions enter the visualization
      txDelay: 3000,
      donationsEnabled: true,
      // Enables the message bar
      messagesEnabled: true,
      // Delay in ms between message bar rotations
      alertDuration: 20000
    };

    class TxPoolScene {
      constructor(_ref) {
        let {
          width,
          height,
          unit,
          padding,
          controller,
          heightStore,
          colorMode
        } = _ref;
        this.colorMode = colorMode || "age";
        this.maxHeight = 0;
        this.heightStore = heightStore;
        this.sceneType = 'pool';
        this.init({
          width,
          height,
          unit,
          padding,
          controller
        });
      }

      init(_ref2) {
        let {
          width,
          height,
          controller
        } = _ref2;
        this.controller = controller;
        this.inverted = false;
        this.scene = {
          count: 0,
          scroll: 0,
          offset: {
            x: 0,
            y: 0
          }
        };
        this.lastScroll = performance.now();
        this.resize({
          width,
          height
        });
        this.txs = {};
        this.hiddenTxs = {};
        this.scrollRateLimitTimer = null;
        this.initialised = true;
      }

      resize(_ref3) {
        let {
          width = this.width,
          height = this.height
        } = _ref3;
        this.width = width;
        this.height = height;
        this.heightLimit = width <= 620 ? height / 4.5 : height / 4;
        this.unitWidth = Math.floor(Math.max(4, width / 250));
        this.unitPadding = Math.floor(Math.max(1, width / 1000));
        this.gridSize = this.unitWidth + this.unitPadding * 2;
        this.blockWidth = Math.floor(width / this.gridSize) - 1;
        this.blockHeight = Math.floor(height / this.gridSize) - 1;
        this.scene.offset.x = (window.innerWidth - this.blockWidth * this.gridSize) / 2;
        this.scene.offset.y = (window.innerHeight - this.blockHeight * this.gridSize) / 2;
      }

      setColorMode(mode) {
        this.colorMode = mode;
        Object.values(this.txs).forEach(tx => {
          const txColor = tx.getColor(this.sceneType, mode);

          if (txColor.endColor) {
            tx.view.update({
              display: {
                color: txColor.color
              },
              duration: 0,
              delay: 0
            });
            tx.view.update({
              display: {
                color: txColor.endColor
              },
              start: tx.enteredTime,
              duration: txColor.duration,
              delay: 0
            });
          } else {
            tx.view.update({
              display: {
                color: txColor.color
              },
              duration: 500,
              delay: 0
            });
          }
        });
      }

      insert(tx, insertDelay) {
        let autoLayout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (autoLayout) {
          this.txs[tx.id] = tx;
          this.place(tx);

          if (this.checkTxScroll(tx)) {
            this.applyTxScroll(tx);
          }

          this.setTxOnScreen(tx, insertDelay);
        } else {
          this.hiddenTxs[tx.id] = tx;
        }
      }

      clearOffscreenTx(tx) {
        if (tx.pixelPosition && tx.pixelPosition.y + tx.pixelPosition.r < -(this.scene.offset.y + 50)) {
          this.controller.destroyTx(tx.id);
        }
      }

      clearOffscreenTxs() {
        const ids = this.getTxList();

        for (let i = 0; i < ids.length; i++) {
          this.clearOffscreenTx(this.txs[ids[i]]);
        }

        this.clearTimer = null;
      }

      redrawTx(tx, now) {
        if (tx && tx.view && tx.view.initialised) {
          this.saveGridToPixelPosition(tx);
          this.savePixelsToScreenPosition(tx);
          tx.view.update({
            display: {
              position: tx.screenPosition
            },
            duration: 1000,
            minDuration: 200,
            start: now,
            delay: 0,
            smooth: true,
            adjust: true
          });
        }
      } // updateChunk (ids, now = performance.now()) {
      //   for (let i = 0; i < ids.length; i++) {
      //     this.redrawTx(this.txs[ids[i]], now)
      //   }
      // }


      async doScroll(offset) {
        const now = performance.now();

        if (now - this.lastScroll > 1000) {
          this.lastScroll = now;
          const ids = this.getTxList();
          this.scene.scroll += offset;
          this.maxHeight += offset;
          if (this.heightStore) this.heightStore.set(this.maxHeight);

          for (let i = 0; i < ids.length; i++) {
            this.redrawTx(this.txs[ids[i]], now);
          }

          if (!this.clearTimer) {
            this.clearTimer = setTimeout(() => {
              this.clearOffscreenTxs();
            }, 1500);
          }
        }
      }

      scroll(offset, force) {
        if (!this.scrollLock) this.doScroll(offset); // if (!this.scrollRateLimitTimer || force || performance.now() > (this.scrollRateLimitTimer + 1000)) {
        //   this.scrollRateLimitTimer = performance.now()
        //   this.doScroll(offset)
        //   return true
        // } else return false
      } // calculates and returns the size of the tx in multiples of the grid size


      txSize(value) {
        // let scale = Math.log10(value)
        // let size = (scale*scale) / 5
        // let rounded = Math.pow(2, Math.ceil(Math.log2(size)))
        // return Math.max(4, rounded)
        return 1;
      }

      checkTxScroll(tx, insertDelay) {
        this.saveGridToPixelPosition(tx);
        const top = tx.pixelPosition.y + tx.pixelPosition.r;
        const bottom = tx.pixelPosition.y - tx.pixelPosition.r;

        if (top > this.maxHeight) {
          this.maxHeight = top;
          if (this.heightStore) this.heightStore.set(this.maxHeight);
        }

        return this.heightLimit && bottom > this.heightLimit;
      }

      applyTxScroll(tx) {
        const bottom = tx.pixelPosition.y - tx.pixelPosition.r;
        this.scroll(this.heightLimit - bottom);
      }

      setTxOnScreen(tx) {
        let insertDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.saveGridToPixelPosition(tx);
        this.savePixelsToScreenPosition(tx);

        if (!tx.view.initialised) {
          const txColor = tx.getColor(this.sceneType, this.colorMode);
          tx.view.update({
            display: {
              position: this.pixelsToScreen({
                x: tx.pixelPosition.x,
                y: window.innerHeight + 10,
                r: this.unitWidth / 2
              }),
              color: { ...txColor.color,
                alpha: 1
              }
            },
            delay: 0,
            state: 'ready'
          });
          tx.view.update({
            display: {
              position: tx.screenPosition,
              color: txColor.color
            },
            duration: 2500,
            delay: insertDelay,
            state: 'pool'
          });

          if (txColor.endColor) {
            tx.view.update({
              display: {
                color: txColor.endColor
              },
              start: tx.enteredTime,
              duration: txColor.duration,
              delay: 0
            });
          }
        } else {
          tx.view.update({
            display: {
              position: tx.screenPosition
            },
            duration: 1000,
            minDuration: 500,
            delay: 50,
            jitter: 500,
            smooth: true,
            adjust: true
          });
        }
      }

      layoutAll() {
        let resize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.maxHeight = 0;
        this.resize(resize);
        this.scene.count = 0;
        let ids = this.getHiddenTxList();

        for (let i = 0; i < ids.length; i++) {
          this.txs[ids[i]] = this.hiddenTxs[ids[i]];
          delete this.hiddenTxs[ids[i]];
        }

        ids = this.getActiveTxList();

        for (let i = 0; i < ids.length; i++) {
          this.place(this.txs[ids[i]]);
          this.saveGridToPixelPosition(this.txs[ids[i]]);
        }

        this.resetScroll();

        for (let i = 0; i < ids.length; i++) {
          this.setTxOnScreen(this.txs[ids[i]]);
        }
      }

      resetScroll() {
        const ids = this.getActiveTxList();
        let poolTop = -Infinity;
        let poolBottom = Infinity;
        let poolScreenTop = -Infinity;
        let tx;

        for (let i = 0; i < ids.length; i++) {
          tx = this.txs[ids[i]]; // this.saveGridToPixelPosition(tx)

          poolTop = Math.max(poolTop, tx.pixelPosition.y - tx.pixelPosition.r);
          poolScreenTop = Math.max(poolScreenTop, tx.pixelPosition.y + tx.pixelPosition.r);
          poolBottom = Math.min(poolBottom, tx.pixelPosition.y - tx.pixelPosition.r);
        }

        this.maxHeight = poolScreenTop;
        let scrollAmount = Math.min(-this.scene.scroll, this.heightLimit - poolTop);
        this.scene.scroll += scrollAmount;
        this.maxHeight += scrollAmount;
        if (this.heightStore) this.heightStore.set(this.maxHeight);
      }

      remove(id) {
        let exists = !!this.txs[id];
        delete this.txs[id];
        return exists;
      }

      drop(id) {
        return this.remove(id);
      }

      getTxList() {
        return [...this.getActiveTxList(), ...this.getHiddenTxList()];
      }

      getActiveTxList() {
        if (this.txs) return Object.keys(this.txs);else return [];
      }

      getHiddenTxList() {
        if (this.txs) return Object.keys(this.hiddenTxs);else return [];
      }

      saveGridToPixelPosition(tx) {
        const pixelRadius = tx.gridPosition.r * this.gridSize / 2 - this.unitPadding;
        tx.pixelPosition.x = this.gridSize * tx.gridPosition.x + pixelRadius;
        tx.pixelPosition.y = this.gridSize * tx.gridPosition.y + pixelRadius + this.scene.scroll;
        tx.pixelPosition.r = pixelRadius;
      }

      gridToPixels(position) {
        const pixelRadius = position.r * this.gridSize / 2 - this.unitPadding;
        return {
          x: this.gridSize * position.x + pixelRadius,
          y: this.gridSize * position.y + pixelRadius + this.scene.scroll,
          r: pixelRadius
        };
      }

      savePixelsToScreenPosition(tx) {
        let xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        tx.screenPosition.x = tx.pixelPosition.x + this.scene.offset.x + xOffset;
        tx.screenPosition.y = (this.inverted ? this.height - tx.pixelPosition.y : tx.pixelPosition.y) + this.scene.offset.y + yOffset;
        tx.screenPosition.r = tx.pixelPosition.r;
      }

      pixelsToScreen(position) {
        // if (this.inverted) {
        const screenPosition = { ...position
        };
        if (this.inverted) screenPosition.y = this.height - screenPosition.y;
        screenPosition.x += this.scene.offset.x;
        screenPosition.y += this.scene.offset.y;
        return screenPosition;
      }

      screenToGrid(position) {
        const pixels = {
          x: position.x - this.scene.offset.x,
          y: position.y - this.scene.offset.y + this.unitPadding
        };
        if (this.inverted) pixels.y = this.height - pixels.y;
        const grid = {
          x: Math.floor(pixels.x / this.gridSize),
          y: Math.floor((pixels.y - this.scene.scroll) / this.gridSize),
          // not sure why we need this offset??
          r: 0
        };
        return grid;
      }

      place(tx) {
        const size = this.txSize(tx);
        tx.gridPosition.x = 1 + Math.floor(position % this.blockWidth);
        tx.gridPosition.y = 1 + Math.floor(position / this.blockWidth);
        tx.gridPosition.r = size;
      }

      getVertexData() {
        // return Object.values(this.txs).slice(-1000).flatMap(tx => tx.view.sprite.getVertexData())
        return Object.values(this.txs).flatMap(tx => tx.view.sprite.getVertexData());
      }

      selectAt(position) {
        return null;
      }

      applyHighlighting(criteria) {
        Object.values(this.txs).forEach(tx => {
          tx.applyHighlighting(criteria);
        });
        Object.values(this.hiddenTxs).forEach(tx => {
          tx.applyHighlighting(criteria);
        });
      }

    }

    function smootherstep(x) {
      const ix = 1 - x;
      x = x * x;
      return x / (x + ix * ix);
    }

    function interpolateAttributeStart(attribute, now, modular) {
      if (attribute.v == 0 || attribute.t + attribute.d <= now) {
        // transition finished, next transition starts from current end state
        // (clamp to 1)
        if (attribute.boom) {
          attribute.a = attribute.a;
          attribute.v = 0;
          attribute.d = 0;
        } else {
          attribute.a = attribute.b;
          attribute.v = 0;
          attribute.d = 0;
        }

        return false;
      } else if (attribute.t > now) {
        // transition not started
        // (clamp to 0)
        return true;
      } else {
        // transition in progress
        // (interpolate)
        const progress = now - attribute.t;
        let delta = progress / attribute.d;

        if (attribute.boom) {
          delta *= 2;

          if (delta > 1) {
            delta = 2 - delta;
          }
        }

        if (attribute.e) {
          delta = smootherstep(delta);
        }

        if (modular && Math.abs(attribute.a - attribute.b) > 0.5) {
          if (attribute.a > 0.5) {
            attribute.a -= 1;
            attribute.a = attribute.a + delta * (attribute.b - attribute.a);
          } else {
            attribute.a = attribute.a + delta * (attribute.b - 1 - attribute.a);
          }

          if (attribute.a < 0) attribute.a += 1;
        } else {
          attribute.a = attribute.a + delta * (attribute.b - attribute.a);
        }

        attribute.d = attribute.d - progress;
        attribute.v = 1 / attribute.d;
        return true;
      }
    }

    class TxSprite {
      constructor(_ref, vertexArray) {
        let {
          now = performance.now(),
          x,
          y,
          r,
          h,
          l,
          alpha
        } = _ref;
        this.vertexArray = vertexArray;
        this.vertexData = Array(VI.length).fill(0);
        this.updateMap = {
          x: 0,
          y: 0,
          r: 0,
          h: 0,
          l: 0,
          a: 0
        };
        this.attributes = {
          x: {
            a: x,
            b: x,
            t: 0,
            v: 0,
            d: 0
          },
          y: {
            a: y,
            b: y,
            t: 0,
            v: 0,
            d: 0
          },
          r: {
            a: r,
            b: r,
            t: 0,
            v: 0,
            d: 0
          },
          h: {
            a: h,
            b: h,
            t: 0,
            v: 0,
            d: 0
          },
          l: {
            a: l,
            b: l,
            t: 0,
            v: 0,
            d: 0
          },
          a: {
            a: alpha,
            b: alpha,
            t: 0,
            v: 0,
            d: 0
          }
        }; // Used to temporarily modify the sprite, so that the base view can be resumed later

        this.modAttributes = null;
        this.vertexPointer = this.vertexArray.insert(this);
        this.compile();
      }

      interpolateAttributes(updateMap, attributes, offsetTime, delay, v, smooth, boomerang, duration, minDuration, adjust) {
        for (const key of Object.keys(updateMap)) {
          // for each non-null attribute:
          if (updateMap[key] != null) {
            // calculate current interpolated value, and set as 'from'
            const inProgress = interpolateAttributeStart(attributes[key], offsetTime, key === 'h'); // interpolateAttributeStart(attributes[key], offsetTime, key)
            // set 'start' to now

            attributes[key].t = offsetTime;
            if (!adjust || !inProgress) attributes[key].t += delay || 0; // if 'adjust' flag set
            // set 'duration' to Max(remaining time, 'duration')

            if (!adjust || duration && attributes[key].d == 0) {
              attributes[key].v = v;
              attributes[key].d = duration;
            } else if (minDuration > attributes[key].d) {
              attributes[key].v = 1 / minDuration;
              attributes[key].d = minDuration;
            } // set 'to' to target value


            attributes[key].b = updateMap[key];

            if (!adjust || !inProgress) {
              if (smooth) attributes[key].e = true;else if (!smooth && attributes[key].e) delete attributes[key].e;
              if (boomerang) attributes[key].boom = true;else if (!boomerang && attributes[key].boom) delete attributes[key].boom;
            }
          }
        }
      }

      update(_ref2) {
        let {
          now = performance.now(),
          delay,
          x,
          y,
          r,
          h,
          l,
          alpha,
          smooth,
          boomerang,
          duration,
          minDuration,
          adjust,
          modify
        } = _ref2;
        const offsetTime = now;
        const v = duration > 0 ? 1 / duration : 0;
        this.updateMap.x = x;
        this.updateMap.y = y;
        this.updateMap.r = r;
        this.updateMap.h = h;
        this.updateMap.l = l;
        this.updateMap.a = alpha;
        const isModified = !!this.modAttributes;

        if (!modify) {
          this.interpolateAttributes(this.updateMap, this.attributes, offsetTime, delay, v, smooth, boomerang, duration, minDuration, adjust);
        } else {
          if (!isModified) {
            // set up the modAttributes
            this.modAttributes = {};

            for (const key of Object.keys(this.updateMap)) {
              if (this.updateMap[key] != null) {
                this.modAttributes[key] = { ...this.attributes[key]
                };
              }
            }
          }

          this.interpolateAttributes(this.updateMap, this.modAttributes, offsetTime, delay, v, smooth, boomerang, duration, minDuration, adjust);
        }

        this.compile();
      } // Transition from modified state back to base attributes


      resume(duration) {
        let now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : performance.now();
        // If not in modified state, there's nothing to do
        if (!this.modAttributes) return;
        const offsetTime = now;
        const v = duration > 0 ? 1 / duration : 0;

        for (const key of Object.keys(this.modAttributes)) {
          // If this base attribute is static (fixed or post-transition), transition smoothly back
          if (this.attributes[key].v == 0 || this.attributes[key].t + this.attributes[key].d <= now) {
            // calculate current interpolated value, and set as 'from'
            interpolateAttributeStart(this.modAttributes[key], offsetTime, key === 'h');
            this.attributes[key].a = this.modAttributes[key].a;
            this.attributes[key].t = offsetTime;
            this.attributes[key].v = v;
            this.attributes[key].d = duration;
          }
        }

        this.modAttributes = null;
        this.compile();
      }

      compile() {
        let attributes = this.attributes;

        if (this.modAttributes) {
          attributes = { ...this.attributes,
            ...this.modAttributes
          };
        }

        attributes.r; // update vertex data in place
        // ugly, but avoids allocating and spreading large temporary arrays

        const vertexStride = VI.length + 2;

        for (let vertex = 0; vertex < 6; vertex++) {
          this.vertexData[vertex * vertexStride] = vertexOffsetFactors[vertex][0];
          this.vertexData[vertex * vertexStride + 1] = vertexOffsetFactors[vertex][1];

          for (let step = 0; step < VI.length; step++) {
            // components of each field in the vertex array are defined by an entry in VI:
            // VI[i].a is the attribute, VI[i].f is the inner field, VI[i].offA and VI[i].offB are offset factors
            if (VI[step].f === 'v' && attributes[VI[step].a].e) {
              if (VI[step].f === 'v' && attributes[VI[step].a].boom) {
                this.vertexData[vertex * vertexStride + step + 2] = -20 - attributes[VI[step].a][VI[step].f];
              } else {
                this.vertexData[vertex * vertexStride + step + 2] = -attributes[VI[step].a][VI[step].f];
              }
            } else if (VI[step].f === 'v' && attributes[VI[step].a].boom) {
              this.vertexData[vertex * vertexStride + step + 2] = -10 - attributes[VI[step].a][VI[step].f];
            } else {
              this.vertexData[vertex * vertexStride + step + 2] = attributes[VI[step].a][VI[step].f];
            }
          }
        }

        this.vertexArray.setData(this.vertexPointer, this.vertexData);
      }

      moveVertexPointer(index) {
        this.vertexPointer = index;
      }

      destroy() {
        this.vertexArray.remove(this.vertexPointer);
        this.vertexPointer = null;
      }

    }
    TxSprite.vertexSize = 26;
    TxSprite.vertexCount = 6;
    TxSprite.dataSize = TxSprite.vertexSize * TxSprite.vertexCount;
    const vertexOffsetFactors = [[-1, -1], [1, 1], [1, -1], [-1, -1], [1, 1], [-1, 1]];
    const VI = [];
    ['x', 'y', 'r', 'h', 'l', 'a'].forEach((attribute, aIndex) => {
      ['a', 'b', 't', 'v'].forEach(field => {
        VI.push({
          a: attribute,
          f: field
        });
      });
    });

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */

    function readable(value, start) {
      return {
        subscribe: writable(value, start).subscribe
      };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */


    function writable(value) {
      let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      let stop;
      const subscribers = new Set();

      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;

          if (stop) {
            // store is ready
            const run_queue = !subscriber_queue.length;

            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value);
            }

            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }

              subscriber_queue.length = 0;
            }
          }
        }
      }

      function update(fn) {
        set(fn(value));
      }

      function subscribe(run) {
        let invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);

        if (subscribers.size === 1) {
          stop = start(set) || noop;
        }

        run(value);
        return () => {
          subscribers.delete(subscriber);

          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }

      return {
        set,
        update,
        subscribe
      };
    }

    function derived(stores, fn, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto = fn.length < 2;
      return readable(initial_value, set => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;

        const sync = () => {
          if (pending) {
            return;
          }

          cleanup();
          const result = fn(single ? values[0] : values, set);

          if (auto) {
            set(result);
          } else {
            cleanup = is_function(result) ? result : noop;
          }
        };

        const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {
          values[i] = value;
          pending &= ~(1 << i);

          if (inited) {
            sync();
          }
        }, () => {
          pending |= 1 << i;
        }));
        inited = true;
        sync();
        return function stop() {
          run_all(unsubscribers);
          cleanup();
        };
      });
    }

    function cubicOut(t) {
      const f = t - 1.0;
      return f * f * f + 1.0;
    }

    function is_date(obj) {
      return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
      if (a === b || a !== a) return () => a;
      const type = typeof a;

      if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
      }

      if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
          return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
      }

      if (type === 'object') {
        if (!a || !b) throw new Error('Object cannot be null');

        if (is_date(a) && is_date(b)) {
          a = a.getTime();
          b = b.getTime();
          const delta = b - a;
          return t => new Date(a + t * delta);
        }

        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
          interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
          const result = {};
          keys.forEach(key => {
            result[key] = interpolators[key](t);
          });
          return result;
        };
      }

      if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
      }

      throw new Error(`Cannot interpolate ${type} values`);
    }

    function tweened(value) {
      let defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const store = writable(value);
      let task;
      let target_value = value;

      function set(new_value, opts) {
        if (value == null) {
          store.set(value = new_value);
          return Promise.resolve();
        }

        target_value = new_value;
        let previous_task = task;
        let started = false;
        let {
          delay = 0,
          duration = 400,
          easing = identity,
          interpolate = get_interpolator
        } = assign(assign({}, defaults), opts);

        if (duration === 0) {
          if (previous_task) {
            previous_task.abort();
            previous_task = null;
          }

          store.set(value = target_value);
          return Promise.resolve();
        }

        const start = now() + delay;
        let fn;
        task = loop(now => {
          if (now < start) return true;

          if (!started) {
            fn = interpolate(value, new_value);
            if (typeof duration === 'function') duration = duration(value, new_value);
            started = true;
          }

          if (previous_task) {
            previous_task.abort();
            previous_task = null;
          }

          const elapsed = now - start;

          if (elapsed > duration) {
            store.set(value = new_value);
            return false;
          } // @ts-ignore


          store.set(value = fn(easing(elapsed / duration)));
          return true;
        });
        return task.promise;
      }

      return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
      };
    }

    function makePollStore(name, url, frequency) {
      let initialValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      let responseHandler = arguments.length > 4 ? arguments[4] : undefined;
      let timer;
      const {
        subscribe,
        set,
        update
      } = writable(initialValue);
      if (!responseHandler) responseHandler = async (response, set) => {
        const data = await response.json();
        if (data) set(data);
      };

      const fetcher = () => {
        fetch(`${url}?t=${Date.now()}`).then(response => {
          responseHandler(response, set);
        }).catch(error => {
          console.log(`error polling data for ${name}: `, error);
          if (timer) clearTimeout(timer);
          timer = setTimeout(fetcher, 5000);
        });
      };

      fetcher();
      setInterval(fetcher, frequency || 60000);
      return {
        subscribe,
        set,
        update
      };
    }

    var localeCurrency = {};

    // Generated using ShowCurrencies.java
    var map$1 = {
      AD: 'EUR',
      AE: 'AED',
      AF: 'AFN',
      AG: 'XCD',
      AI: 'XCD',
      AL: 'ALL',
      AM: 'AMD',
      AN: 'ANG',
      AO: 'AOA',
      AR: 'ARS',
      AS: 'USD',
      AT: 'EUR',
      AU: 'AUD',
      AW: 'AWG',
      AX: 'EUR',
      AZ: 'AZN',
      BA: 'BAM',
      BB: 'BBD',
      BD: 'BDT',
      BE: 'EUR',
      BF: 'XOF',
      BG: 'BGN',
      BH: 'BHD',
      BI: 'BIF',
      BJ: 'XOF',
      BL: 'EUR',
      BM: 'BMD',
      BN: 'BND',
      BO: 'BOB',
      BQ: 'USD',
      BR: 'BRL',
      BS: 'BSD',
      BT: 'BTN',
      BV: 'NOK',
      BW: 'BWP',
      BY: 'BYR',
      BZ: 'BZD',
      CA: 'CAD',
      CC: 'AUD',
      CD: 'CDF',
      CF: 'XAF',
      CG: 'XAF',
      CH: 'CHF',
      CI: 'XOF',
      CK: 'NZD',
      CL: 'CLP',
      CM: 'XAF',
      CN: 'CNY',
      CO: 'COP',
      CR: 'CRC',
      CU: 'CUP',
      CV: 'CVE',
      CW: 'ANG',
      CX: 'AUD',
      CY: 'EUR',
      CZ: 'CZK',
      DE: 'EUR',
      DJ: 'DJF',
      DK: 'DKK',
      DM: 'XCD',
      DO: 'DOP',
      DZ: 'DZD',
      EC: 'USD',
      EE: 'EUR',
      EG: 'EGP',
      EH: 'MAD',
      ER: 'ERN',
      ES: 'EUR',
      ET: 'ETB',
      FI: 'EUR',
      FJ: 'FJD',
      FK: 'FKP',
      FM: 'USD',
      FO: 'DKK',
      FR: 'EUR',
      GA: 'XAF',
      GB: 'GBP',
      GD: 'XCD',
      GE: 'GEL',
      GF: 'EUR',
      GG: 'GBP',
      GH: 'GHS',
      GI: 'GIP',
      GL: 'DKK',
      GM: 'GMD',
      GN: 'GNF',
      GP: 'EUR',
      GQ: 'XAF',
      GR: 'EUR',
      GS: 'GBP',
      GT: 'GTQ',
      GU: 'USD',
      GW: 'XOF',
      GY: 'GYD',
      HK: 'HKD',
      HM: 'AUD',
      HN: 'HNL',
      HR: 'HRK',
      HT: 'HTG',
      HU: 'HUF',
      ID: 'IDR',
      IE: 'EUR',
      IL: 'ILS',
      IM: 'GBP',
      IN: 'INR',
      IO: 'USD',
      IQ: 'IQD',
      IR: 'IRR',
      IS: 'ISK',
      IT: 'EUR',
      JE: 'GBP',
      JM: 'JMD',
      JO: 'JOD',
      JP: 'JPY',
      KE: 'KES',
      KG: 'KGS',
      KH: 'KHR',
      KI: 'AUD',
      KM: 'KMF',
      KN: 'XCD',
      KP: 'KPW',
      KR: 'KRW',
      KW: 'KWD',
      KY: 'KYD',
      KZ: 'KZT',
      LA: 'LAK',
      LB: 'LBP',
      LC: 'XCD',
      LI: 'CHF',
      LK: 'LKR',
      LR: 'LRD',
      LS: 'LSL',
      LT: 'LTL',
      LU: 'EUR',
      LV: 'LVL',
      LY: 'LYD',
      MA: 'MAD',
      MC: 'EUR',
      MD: 'MDL',
      ME: 'EUR',
      MF: 'EUR',
      MG: 'MGA',
      MH: 'USD',
      MK: 'MKD',
      ML: 'XOF',
      MM: 'MMK',
      MN: 'MNT',
      MO: 'MOP',
      MP: 'USD',
      MQ: 'EUR',
      MR: 'MRO',
      MS: 'XCD',
      MT: 'EUR',
      MU: 'MUR',
      MV: 'MVR',
      MW: 'MWK',
      MX: 'MXN',
      MY: 'MYR',
      MZ: 'MZN',
      NA: 'NAD',
      NC: 'XPF',
      NE: 'XOF',
      NF: 'AUD',
      NG: 'NGN',
      NI: 'NIO',
      NL: 'EUR',
      NO: 'NOK',
      NP: 'NPR',
      NR: 'AUD',
      NU: 'NZD',
      NZ: 'NZD',
      OM: 'OMR',
      PA: 'PAB',
      PE: 'PEN',
      PF: 'XPF',
      PG: 'PGK',
      PH: 'PHP',
      PK: 'PKR',
      PL: 'PLN',
      PM: 'EUR',
      PN: 'NZD',
      PR: 'USD',
      PS: 'ILS',
      PT: 'EUR',
      PW: 'USD',
      PY: 'PYG',
      QA: 'QAR',
      RE: 'EUR',
      RO: 'RON',
      RS: 'RSD',
      RU: 'RUB',
      RW: 'RWF',
      SA: 'SAR',
      SB: 'SBD',
      SC: 'SCR',
      SD: 'SDG',
      SE: 'SEK',
      SG: 'SGD',
      SH: 'SHP',
      SI: 'EUR',
      SJ: 'NOK',
      SK: 'EUR',
      SL: 'SLL',
      SM: 'EUR',
      SN: 'XOF',
      SO: 'SOS',
      SR: 'SRD',
      ST: 'STD',
      SV: 'SVC',
      SX: 'ANG',
      SY: 'SYP',
      SZ: 'SZL',
      TC: 'USD',
      TD: 'XAF',
      TF: 'EUR',
      TG: 'XOF',
      TH: 'THB',
      TJ: 'TJS',
      TK: 'NZD',
      TL: 'USD',
      TM: 'TMT',
      TN: 'TND',
      TO: 'TOP',
      TR: 'TRY',
      TT: 'TTD',
      TV: 'AUD',
      TW: 'TWD',
      TZ: 'TZS',
      UA: 'UAH',
      UG: 'UGX',
      UM: 'USD',
      US: 'USD',
      UY: 'UYU',
      UZ: 'UZS',
      VA: 'EUR',
      VC: 'XCD',
      VE: 'VEF',
      VG: 'USD',
      VI: 'USD',
      VN: 'VND',
      VU: 'VUV',
      WF: 'XPF',
      WS: 'WST',
      YE: 'YER',
      YT: 'EUR',
      ZA: 'ZAR',
      ZM: 'ZMK',
      ZW: 'ZWL'
    };
    var map_1 = map$1;

    var map = map_1;

    var getCountryCode = function (localeString) {
      var components = localeString.split("_");

      if (components.length == 2) {
        return components.pop();
      }

      components = localeString.split("-");

      if (components.length == 2) {
        return components.pop();
      }

      return localeString;
    };

    localeCurrency.getCurrency = function (locale) {
      var countryCode = getCountryCode(locale).toUpperCase();

      if (countryCode in map) {
        return map[countryCode];
      }

      return null;
    };

    localeCurrency.getLocales = function (currencyCode) {
      currencyCode = currencyCode.toUpperCase();
      var locales = [];

      for (countryCode in map) {
        if (map[countryCode] === currencyCode) {
          locales.push(countryCode);
        }
      }

      return locales;
    };

    const currencies = {
      AUD: {
        char: 'AU$',
        pre: true,
        name: 'Australian Dollar',
        countries: ['Australia'],
        dp: 2,
        code: 'AUD'
      },
      BRL: {
        char: 'R$',
        pre: true,
        name: 'Brazilian Real',
        countries: ['Brazil'],
        dp: 2,
        code: 'BRL'
      },
      CAD: {
        char: 'CA$',
        pre: true,
        name: 'Canadian Dollar',
        countries: ['Canada'],
        dp: 2,
        code: 'CAD'
      },
      CHF: {
        char: 'fr.',
        pre: false,
        name: 'Swiss Franc',
        countries: ['Switzerland'],
        dp: 2,
        code: 'CHF'
      },
      CLP: {
        char: 'CLP$',
        pre: true,
        name: 'Chilean Peso',
        countries: ['Chile'],
        dp: 2,
        code: 'CLP'
      },
      CNY: {
        char: '¥',
        pre: true,
        name: 'Chinese Yuan',
        countries: ['China'],
        dp: 2,
        code: 'CNY'
      },
      CZK: {
        char: 'Kč',
        pre: false,
        name: 'Czech Koruna',
        countries: ['Czechia'],
        dp: 2,
        code: 'CZK'
      },
      DKK: {
        char: 'kr.',
        pre: false,
        name: 'Danish Krone',
        countries: ['Denmark'],
        dp: 2,
        code: 'DKK'
      },
      EUR: {
        char: '€',
        pre: true,
        name: 'Euro',
        countries: ['European Union', 'Austria', 'Belgium', 'Cyprus', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Portugal', 'Slovakia', 'Slovenia', 'Spain', 'Andorra', 'Monaco', 'San Marino', 'Vatican City', 'Kosovo', 'Montenegro'],
        dp: 2,
        code: 'EUR'
      },
      GBP: {
        char: '£',
        pre: true,
        name: 'Pound Sterling',
        countries: ['United Kingdom'],
        dp: 2,
        code: 'GBP'
      },
      HKD: {
        char: 'HK$',
        pre: true,
        name: 'Hong Kong Dollar',
        countries: ['Hong Kong'],
        dp: 2,
        code: 'HKD'
      },
      HRK: {
        char: 'kn',
        pre: false,
        name: 'Croatian Kuna',
        countries: ['Croatia'],
        dp: 2,
        code: 'HRK'
      },
      HUF: {
        char: 'Ft',
        pre: false,
        name: 'Hungarian Forint',
        countries: ['Hungary'],
        dp: 2,
        code: 'HUF'
      },
      INR: {
        char: '₹',
        pre: true,
        name: 'Indian Rupee',
        countries: ['India', 'Bhutan'],
        dp: 2,
        code: 'INR'
      },
      ISK: {
        char: 'kr',
        pre: false,
        name: 'Icelandic Króna',
        countries: ['Iceland'],
        dp: 2,
        code: 'ISK'
      },
      JPY: {
        char: '¥',
        pre: true,
        name: 'Japanese Yen',
        countries: ['Japan'],
        dp: 2,
        code: 'JPY'
      },
      KRW: {
        char: '₩',
        pre: true,
        name: 'Korean Won',
        countries: ['South Korea'],
        dp: 2,
        code: 'KRW'
      },
      NZD: {
        char: 'NZ$',
        pre: true,
        name: 'New Zealand Dollar',
        countries: ['New Zealand'],
        dp: 2,
        code: 'NZD'
      },
      PLN: {
        char: 'zł',
        pre: false,
        name: 'Polish Złoty',
        countries: ['Poland'],
        dp: 2,
        code: 'PLN'
      },
      RON: {
        char: 'L',
        pre: false,
        name: 'Romanian Leu',
        countries: ['Romania'],
        dp: 2,
        code: 'RON'
      },
      RUB: {
        char: '₽',
        pre: false,
        name: 'Russian Ruble',
        countries: ['Russia'],
        dp: 2,
        code: 'RUB'
      },
      SEK: {
        char: 'kr',
        pre: false,
        name: 'Swedish Krona',
        countries: ['Sweden'],
        dp: 2,
        code: 'SEK'
      },
      SGD: {
        char: 'S$',
        pre: true,
        name: 'Singapore Dollar',
        countries: ['Singapore'],
        dp: 2,
        code: 'SGD'
      },
      THB: {
        char: '฿',
        pre: true,
        name: 'Thai Baht',
        countries: ['Thailand'],
        dp: 2,
        code: 'THB'
      },
      TRY: {
        char: '₺',
        pre: true,
        name: 'Turkish Lira',
        countries: ['Turkey'],
        dp: 2,
        code: 'TRY'
      },
      TWD: {
        char: '圓',
        pre: true,
        name: 'New Taiwan Dollar',
        countries: ['Taiwan'],
        dp: 2,
        code: 'TWD'
      },
      USD: {
        char: '$',
        pre: true,
        name: 'US Dollar',
        countries: ['United States', 'USA'],
        dp: 2,
        code: 'USD'
      }
    };
    function formatCurrency(code, amount, params) {
      // Support for Intl.NumberFormat not quite there yet for all currencies/locales
      // const format = new Intl.NumberFormat(currency.locale, {currency: currency.code, currencyDisplay: "symbol", style: "currency"})
      // return format.format(amount)
      const currency = currencies[code] || currencies.USD;
      let parts = [currency.char];

      if (params && params.compact) {
        let suffixIndex = 0;

        while (amount > 1000 && suffixIndex < 4) {
          amount /= 1000;
          suffixIndex++;
        }

        let precision;
        if (suffixIndex == 0 && amount >= 10 && amount < 100) precision = 4;else precision = 3;
        const amountPart = amount < 1000 ? amount.toPrecision(precision) : Math.round(amount);
        parts.push(`${amountPart}${['', 'K', 'M', 'B', 'T'][suffixIndex]}`);
      } else {
        parts.push(amount.toLocaleString(undefined, {
          minimumFractionDigits: currency.dp,
          maximumFractionDigits: currency.dp
        }));
      }

      if (!currency.pre) parts = parts.reverse();
      return parts.join(' ');
    }

    function createCounter() {
      const {
        subscribe,
        set,
        update
      } = writable(0);
      return {
        subscribe,
        set,
        add: x => update(n => n + x),
        subtract: x => update(n => n - x),
        increment: () => update(n => n + 1),
        decrement: () => update(n => n - 1),
        reset: () => set(0)
      };
    }

    function createCachedDict(namespace, setValues, defaultValues) {
      const initial = { ...defaultValues
      };
      Object.keys(initial).forEach(field => {
        // fields take setValues first, then fall back to cached values, then defaults
        if (setValues[field] != null) initial[field] = setValues[field];else {
          const val = localStorage.getItem(`${namespace}-${field}`);

          if (val != null) {
            try {
              initial[field] = JSON.parse(val);
            } catch (e) {
              initial[field] = val;
            }
          }
        }
      });
      const {
        subscribe,
        set,
        update
      } = writable(initial);
      return {
        subscribe,
        set: val => {
          set(val);
          Object.keys(val).forEach(field => {
            localStorage.setItem(`${namespace}-${field}`, val[field]);
          });
        }
      };
    } // refresh exchange rates every minute


    const exchangeRates = makePollStore('rates', 'https://blockchain.info/ticker', 60000, {}); // refresh messages from donation server every hour

    const alerts = config$1.messagesEnabled ? makePollStore('alerts', `${config$1.donationRoot}/api/sponsorship/msgs.json`, 3600000, []) : writable(null); // refresh sponsor data every 10 minutes

    const heroes = makePollStore('heroes', `${config$1.donationRoot}/api/sponsorship/heroes.json`, 600000, null);
    const sponsors = makePollStore('sponsors', `${config$1.donationRoot}/api/sponsorship/sponsors.json`, 600000, null); // refresh sponsorship tiers every hour

    const tiers = config$1.donationsEnabled ? makePollStore('tiers', `${config$1.donationRoot}/api/sponsorship/tiers.json`, 3600000, null) : writable(null);
    const haveMessages = derived([alerts], _ref => {
      let [$alerts] = _ref;
      return $alerts && $alerts.length;
    });
    const haveSupporters = derived([heroes, sponsors], _ref2 => {
      let [$heroes, $sponsors] = _ref2;
      return $heroes && Object.values($heroes).length;
    });
    const darkMode = writable(true);
    const serverConnected = writable(false);
    const serverDelay = writable(1000);
    const devEvents = writable({
      addOneCallback: null,
      addManyCallback: null,
      addBlockCallback: null
    });
    const txCount = createCounter();
    const lastBlockId = writable(null);
    const mempoolCount = tweened(0);
    const mempoolScreenHeight = writable(0);
    const blockVisible = writable(false);
    const currentBlock = writable(null);
    const selectedTx = writable(null);
    const detailTx = writable(null);
    const blockAreaSize = writable(0);
    let localeCurrencyCode = localeCurrency.getCurrency(navigator.language);
    if (!currencies[localeCurrencyCode]) localeCurrencyCode = 'USD';
    const defaultSettings = {
      darkMode: true,
      showNetworkStatus: true,
      currency: localeCurrencyCode,
      showFX: true,
      vbytes: false,
      colorByFee: false,
      showMessages: true,
      showSearch: true,
      noTrack: false,
      blocksEnabled: true
    };
    const searchParams = URL ? new URL(document.location).searchParams : {};
    const urlSettings = Object.keys(defaultSettings).reduce((map, key) => {
      const param = searchParams.get(key);

      if (param != null) {
        if (param.toLowerCase() === 'false') map[key] = false;else map[key] = param;
      }

      return map;
    }, {});
    if (urlSettings.showMessages == null) urlSettings.showMessages = true;
    if (urlSettings.blocksEnabled == null) urlSettings.blocksEnabled = true;
    const settings = createCachedDict('settings', urlSettings, defaultSettings);
    const colorMode = derived([settings], _ref3 => {
      let [$settings] = _ref3;
      return $settings.colorByFee ? "fee" : "age";
    });
    const devSettings = config$1.dev && config$1.debug ? createCachedDict('dev-settings', {}, {
      guides: false,
      layoutHints: false
    }) : writable({});
    const sidebarToggle = writable(null);
    !localStorage.getItem('seen-welcome-msg'); // export const overlay = writable(newVisitor ? 'about' : null)

    const overlay = writable(null);
    const highlight = writable([]);
    const newHighlightQuery = writable(null);
    const highlightingFull = writable(false);
    const pageWidth = writable(window.innerWidth);
    const pageHeight = writable(window.innerHeight);
    const freezeResize = writable(false);
    let lastTinyScreen;
    const tinyScreen = derived([pageWidth, pageHeight, freezeResize], _ref4 => {
      let [$pageWidth, $pageHeight, $freezeResize] = _ref4;
      if ($freezeResize) return lastTinyScreen;else {
        const aspectRatio = $pageWidth / $pageHeight;
        lastTinyScreen = aspectRatio >= 1 && $pageWidth < 480 || aspectRatio <= 1 && $pageHeight < 480;
        return lastTinyScreen;
      }
    });
    let lastCompactScreen;
    const compactScreen = derived([pageWidth, pageHeight, freezeResize], _ref5 => {
      let [$pageWidth, $pageHeight, $freezeResize] = _ref5;
      if ($freezeResize) return lastTinyScreen;else {
        lastCompactScreen = $pageWidth <= 640 && $pageHeight <= 550;
        return lastCompactScreen;
      }
    });
    const blocksEnabled = derived([settings], _ref6 => {
      let [$settings] = _ref6;
      return !!$settings.blocksEnabled;
    });
    const latestBlockHeight = writable(null);
    const highlightInOut = writable(null);
    const loading = createCounter();
    const explorerBlock = writable(null);
    const blockTransitionDirection = writable(null);
    const urlPath = writable(null);

    function logTxSize(value, max) {
      let scale = Math.ceil(Math.log10(value)) - 5; // console.log(scale)

      return Math.min(max || Infinity, Math.max(1, scale)); // bound between 1 and the max displayable size (just in case!)
    }
    function byteTxSize(vbytes, max, log) {
      if (!vbytes) vbytes = 1;
      let scale = Math.max(1, Math.ceil(Math.sqrt(vbytes / 256)));
      return Math.min(max || Infinity, Math.max(1, scale)); // bound between 1 and the max displayable size (just in case!)
    }

    let settingsValue$1;
    settings.subscribe(v => {
      settingsValue$1 = v;
    });
    class TxMondrianPoolScene extends TxPoolScene {
      constructor(_ref) {
        let {
          width,
          height,
          unit,
          padding,
          controller,
          heightStore,
          colorMode
        } = _ref;
        super({
          width,
          height,
          unit,
          padding,
          controller,
          heightStore,
          colorMode
        });
      }

      resize(_ref2) {
        let {
          width,
          height,
          unit,
          padding
        } = _ref2;
        super.resize({
          width,
          height,
          unit,
          padding
        });
        this.resetLayout();
      }

      resetLayout() {
        if (this.layout) this.layout.destroy();
        this.layout = new MondrianLayout({
          width: this.blockWidth,
          height: this.blockHeight,
          context: this
        });
      } // calculates and returns the size of the tx in multiples of the grid size


      txSize() {
        let tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          value: 1,
          vbytes: 1
        };
        if (settingsValue$1.vbytes) return byteTxSize(tx.vbytes, this.blockWidth);else return logTxSize(tx.value, this.blockWidth);
      }

      place(tx) {
        const size = this.txSize(tx);
        const position = this.layout.place(tx, size);
        tx.gridPosition.x = position.x;
        tx.gridPosition.y = position.y;
        tx.gridPosition.r = position.r;
      }

      doScroll(offset) {
        super.doScroll(offset);
        this.layout.redraw();
        this.layout.clearOffscreen();
      } // handle mouse-over events - return the tx at this mouse position, if any


      selectAt(position) {
        if (this.layout) {
          const gridPosition = this.screenToGrid(position);
          return this.layout.getTxInGridCell(gridPosition);
        } else return null;
      }

      drop(id) {
        let tx = this.txs[id];

        if (tx && tx.gridSquare) {
          this.layout.remove(tx.gridSquare);
        }

        delete this.txs[id];
        return !!tx;
      }

    }

    class MondrianLayout {
      constructor(_ref3) {
        let {
          width,
          height,
          context
        } = _ref3;
        this.width = width;
        this.height = height;
        this.context = context;
        this.rowOffset = 0;
        this.rows = [];
        this.txMap = []; // map of which txs occupy each grid square
      }

      getRow(position) {
        return this.rows[position.y - this.rowOffset];
      }

      getSlot(position) {
        if (this.getRow(position)) {
          return this.getRow(position).map[position.x];
        }
      }

      addRow() {
        // Add a new layout row to the top of the layout
        // 'slots' is an ordered list of slots in this row
        // 'map' is dictionary mapping x coordinates to slots
        // 'max' is the height of the largest slot in this row
        const newRow = {
          y: this.rows.length + this.rowOffset,
          slots: [],
          map: {},
          max: 0
        };
        this.rows.push(newRow);
        return newRow;
      }

      clearOffscreen() {
        let done = false;
        const cutoff = -(this.context.scene.scroll + this.context.scene.offset.y) / this.context.gridSize; // console.log(`clearing layout rows. cut off at grid ${cutoff}`)

        while (!done && this.rows.length) {
          const head = this.rows[0];
          let max = 0;
          head.slots.forEach(x => {
            max = Math.max(max, x.r);
          });

          if (head.y + max < cutoff) {
            // console.log('row below cutoff - removing')
            this.rowOffset++;
            this.destroyRow(head);
            this.rows.shift();
            this.txMap.shift(); // console.log(head)
          } else {
            done = true;
          }
        }
      }

      addSlot(slot) {
        // console.log(`adding a slot to layout row ${slot.y} at x = ${slot.x}`)
        // slots must have non-zero size
        if (slot.r <= 0) return; // allow one slot per coordinate

        if (this.getSlot(slot)) {
          // the slot is already occupied
          // console.log('slot already exists at this location')
          const existingSlot = this.getSlot(slot); // swap for the new slot if it is larger

          if (slot.r > existingSlot.r) {
            existingSlot.r = slot.r;
            this.updateSlotSprite(existingSlot);
          }

          return existingSlot;
        } else {
          // Insert this slot into the ordered 'slots' list
          let insertAt = null;
          const row = this.getRow(slot);

          if (!row) {
            // console.log('no such row!')
            // console.log(slot)
            return;
          }

          for (let i = 0; i < row.slots.length && insertAt == null; i++) {
            // console.log(`insert at ${i}? (x = ${this.rows[slot.y].slots[i].x})`)
            if (row.slots[i].x > slot.x) {
              // console.log('yes')
              insertAt = i;
            }
          } // console.log(`insert slot at position ${insertAt}`)


          if (insertAt == null) row.slots.push(slot);else row.slots.splice(insertAt || 0, 0, slot);
          row.map[slot.x] = slot; // Set up a sprite for debugging graphics

          if (config$1.layoutHints) {
            slot.sprite = new TxSprite(this.slotToSprite(slot), this.context.controller.debugVertexArray);
          }

          return slot;
        }
      }

      removeSlot(slot) {
        const row = this.getRow(slot);

        if (row) {
          delete row.map[slot.x];
          let indexOf = row.slots.indexOf(slot);
          row.slots.splice(indexOf, 1);
        }

        if (slot.sprite) slot.sprite.destroy();
      } // Update the layout to accommodate a square of size squareWidth placed in the given slot


      fillSlot(slot, squareWidth) {
        const square = {
          left: slot.x,
          right: slot.x + squareWidth,
          bottom: slot.y,
          top: slot.y + squareWidth
        };
        this.removeSlot(slot); // console.log(`filling slot at ${slot.x},${slot.y},${slot.r} with ${squareWidth}`)
        // Find and fix collisions for each affected row (from slot.y + 1 to slot.y + squareWidth - 1)

        for (let rowIndex = slot.y; rowIndex < square.top; rowIndex++) {
          // console.log(`Checking row ${rowIndex}`)
          const row = this.getRow({
            y: rowIndex
          });

          if (row) {
            // look for an overlapping slot
            let collisions = [];
            let maxExcess = 0;

            for (let i = 0; i < row.slots.length; i++) {
              const testSlot = row.slots[i]; // console.log(`Checking slot ${i} (x: ${testSlot.x}) in row ${rowIndex}`)
              // collision if this slot overlaps the new square

              if (!(testSlot.x + testSlot.r < square.left || testSlot.x >= square.right)) {
                // console.log('Collision!')
                collisions.push(testSlot); // record how far this slot extends beyond the RHS of the filled slot (if at all)

                let excess = Math.max(0, testSlot.x + testSlot.r - (slot.x + slot.r)); // console.log(`overruns by ${excess}`)

                maxExcess = Math.max(maxExcess, excess);
              }
            } // add a new slot on the RHS of the inserted square, unless one already exists or there's no space left there


            if (square.right < this.width && !row.map[square.right]) {
              // console.log(`Adding RHS square at ${square.right},${rowIndex},${(slot.r - squareWidth + maxExcess)}`)
              this.addSlot({
                x: square.right,
                y: rowIndex,
                r: slot.r - squareWidth + maxExcess
              });
            } // process collisions (remove or adjust)
            // console.log('processing collisions: ', collisions)


            for (let i = 0; i < collisions.length; i++) {
              // shrink the slot to the now available space, or remove if no space left
              collisions[i].r = slot.x - collisions[i].x;
              if (collisions[i].r > 0) this.updateSlotSprite(collisions[i]);else this.removeSlot(collisions[i]);
            }
          } else {
            // collision with implied slot in next uninitialised row
            this.addRow();
            if (slot.x > 0) this.addSlot({
              x: 0,
              y: rowIndex,
              r: slot.x
            });
            if (square.right < this.width) this.addSlot({
              x: square.right,
              y: rowIndex,
              r: this.width - square.right
            });
          }
        } // Find and fix collisions in region below the inserted square


        for (let rowIndex = Math.max(0, slot.y - squareWidth); rowIndex < slot.y; rowIndex++) {
          // console.log(`Checking row ${rowIndex}`)
          const row = this.getRow({
            y: rowIndex
          });

          if (row) {
            // look for all overlapping slots
            for (let i = 0; i < row.slots.length; i++) {
              const testSlot = row.slots[i]; // console.log(`Checking slot ${i} (x: ${slot[i].x}) in row ${rowIndex}`)
              // collision if this slot overlaps the filled slot

              if (testSlot.x < slot.x + squareWidth && testSlot.x + testSlot.r > slot.x && testSlot.y + testSlot.r >= slot.y) {
                // console.log('Collision!')
                // shrink the slot to the now available space
                const oldSlotWidth = testSlot.r;
                testSlot.r = slot.y - testSlot.y;
                if (testSlot.r > 0) this.updateSlotSprite(testSlot);else this.removeSlot(testSlot); // now there's some uncovered space on the RHS of the old slot

                let remaining = {
                  x: testSlot.x + testSlot.r,
                  y: testSlot.y,
                  w: oldSlotWidth - testSlot.r,
                  h: testSlot.r
                }; // console.log('remaining space: ', remaining)
                // tile with free-floating slots to make sure we don't lose that space

                while (remaining.w > 0 && remaining.h > 0) {
                  // console.log('tiling free space')
                  if (remaining.w <= remaining.h) {
                    this.addSlot({
                      x: remaining.x,
                      y: remaining.y,
                      r: remaining.w
                    });
                    remaining.y += remaining.w;
                    remaining.h -= remaining.w;
                  } else {
                    this.addSlot({
                      x: remaining.x,
                      y: remaining.y,
                      r: remaining.h
                    });
                    remaining.x += remaining.h;
                    remaining.w -= remaining.h;
                  }
                }
              }
            }
          }
        }

        return {
          x: slot.x,
          y: slot.y,
          r: squareWidth
        };
      }

      place(tx, size) {
        let found = false;
        let rowIndex = 0;
        let row;
        let slotIndex = 0;
        let square = null;

        while (!found && rowIndex < this.rows.length) {
          row = this.rows[rowIndex];

          while (!found && slotIndex < row.slots.length) {
            const testSlot = row.slots[slotIndex]; // check if square fits in space

            if (testSlot.r >= size) {
              found = true;
              square = this.fillSlot(testSlot, size);
            }

            slotIndex++;
          }

          slotIndex = 0;
          rowIndex++;
        }

        if (!found) {
          const row = this.addRow();
          const slot = this.addSlot({
            x: 0,
            y: row.y,
            r: this.width
          });
          square = this.fillSlot(slot, size);
        } // update txMap


        tx.gridSquare = square;

        for (let x = 0; x < square.r; x++) {
          for (let y = 0; y < square.r; y++) {
            this.setTxMapCell({
              x: square.x + x,
              y: square.y + y
            }, tx);
          }
        }

        return square;
      }

      remove(square) {
        for (let x = 0; x < square.r; x++) {
          for (let y = 0; y < square.r; y++) {
            this.clearTxMapCell({
              x: square.x + x,
              y: square.y + y
            });
            if (x <= y) this.addSlot({
              x: square.x + x,
              y: square.y + y,
              r: square.r - y
            });
          }
        } // this.addSlot({ x: square.x, y: square.y, r: square.r })

      }

      setTxMapCell(coord, tx) {
        const offsetY = coord.y - this.rowOffset;

        while (this.txMap.length <= offsetY) {
          this.txMap.push(new Array(this.width).fill(null));
        }

        this.txMap[offsetY][coord.x] = tx;
      }

      clearTxMapCell(coord, tx) {
        const offsetY = coord.y - this.rowOffset;

        while (this.txMap.length <= offsetY) {
          this.txMap.push(new Array(this.width).fill(null));
        }

        if (this.txMap[offsetY]) this.txMap[offsetY][coord.x] = null;
      }

      getTxInGridCell(coord) {
        const offsetY = coord.y - this.rowOffset;
        if (this.txMap[offsetY]) return this.txMap[offsetY][coord.x];else return null;
      }

      slotToSprite(slot) {
        const pos = this.context.pixelsToScreen(this.context.gridToPixels(slot));
        return {
          x: pos.x,
          y: pos.y,
          r: pos.r,
          h: 0.5,
          l: 0.5,
          alpha: 0.5
        };
      }

      updateSlotSprite(slot) {
        if (config$1.layoutHints) {
          slot.sprite.update({ ...this.slotToSprite(slot),
            duration: 500,
            minDuration: 500,
            adjust: true
          });
        }
      }

      redraw() {
        if (config$1.layoutHints) {
          this.rows.forEach(row => {
            row.slots.forEach(slot => {
              this.updateSlotSprite(slot);
            });
          });
        }
      }

      destroyRow(row) {
        if (config$1.layoutHints) {
          row.slots.forEach(slot => {
            slot.sprite.destroy();
          });
        }
      }

      destroy() {
        if (config$1.layoutHints) {
          this.rows.forEach(row => {
            row.slots.forEach(slot => {
              slot.sprite.destroy();
            });
          });
        }
      }

    }

    function define (constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);

      for (var key in definition) prototype[key] = definition[key];

      return prototype;
    }

    function Color() {}
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };
    define(Color, color, {
      copy: function (channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function () {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
      : null // invalid hex
      ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
      brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function () {
        return this;
      },
      displayable: function () {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;

      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }

      return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function () {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
      },
      displayable: function () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      },
      formatHsl: function () {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
      }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */

    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }

    const radians = Math.PI / 180;
    const degrees = 180 / Math.PI;

    const K$1 = 18,
          Xn = 0.96422,
          Yn = 1,
          Zn = 0.82521,
          t0 = 4 / 29,
          t1 = 6 / 29,
          t2 = 3 * t1 * t1,
          t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
          x,
          z;
      if (r === g && g === b) x = z = y;else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Lab, lab, extend(Color, {
      brighter: function (k) {
        return new Lab(this.l + K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function (k) {
        return new Lab(this.l - K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function () {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$1(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$1, extend(Color, {
      brighter: function (k) {
        return new Hcl(this.h, this.c, this.l + K$1 * (k == null ? 1 : k), this.opacity);
      },
      darker: function (k) {
        return new Hcl(this.h, this.c, this.l - K$1 * (k == null ? 1 : k), this.opacity);
      },
      rgb: function () {
        return hcl2lab(this).rgb();
      }
    }));

    function hlToHex(_ref) {
      let {
        h,
        l
      } = _ref;
      return hcl$1(h * 360, 78.225, l * 150).hex();
    }
    function mixColor(startColor, endColor, min, max, value) {
      const dx = Math.max(0, Math.min(1, (value - min) / (max - min)));
      return {
        h: startColor.h + dx * (endColor.h - startColor.h),
        l: startColor.l + dx * (endColor.l - startColor.l)
      };
    }
    const pink = {
      h: 0.03,
      l: 0.35
    };
    const bluegreen = {
      h: 0.45,
      l: 0.4
    };
    const orange = {
      h: 0.181,
      l: 0.472
    };
    const teal = {
      h: 0.475,
      l: 0.55
    };
    const blue = {
      h: 0.5,
      l: 0.55
    };
    const green = {
      h: 0.37,
      l: 0.35
    };
    const purple = {
      h: 0.95,
      l: 0.35
    };
    const highlightA = {
      h: 0.93,
      l: 0.5
    }; //pink

    const highlightB = {
      h: 0.214,
      l: 0.62
    }; // green

    const highlightC = {
      h: 0.30,
      l: 1.0
    }; // white

    const highlightD = {
      h: 0.42,
      l: 0.35
    }; // blue

    const highlightE = {
      h: 0.12,
      l: 0.375
    }; // red

    let settingsValue;
    settings.subscribe(v => {
      settingsValue = v;
    });
    class TxBlockScene extends TxMondrianPoolScene {
      constructor(_ref) {
        let {
          width,
          height,
          unit = 4,
          padding = 1,
          blockId,
          controller,
          heightStore,
          colorMode
        } = _ref;
        super({
          width,
          height,
          unit,
          padding,
          controller,
          heightStore,
          colorMode
        });
        this.heightLimit = null;
        this.expired = false;
        this.laidOut = false;
        this.blockId = blockId;
        this.initialised = true;
        this.inverted = true;
        this.hidden = false;
        this.sceneType = 'block';
      }

      resize(_ref2) {
        let {
          width = this.width,
          height = this.height
        } = _ref2;

        if (this.initialised) {
          let blockWeight = 0;
          const ids = this.getTxList();

          for (let i = 0; i < ids.length; i++) {
            let squareSize = 0;
            if (this.txs[ids[i]]) squareSize = this.txSize(this.txs[ids[i]]);else if (this.hiddenTxs[ids[i]]) squareSize = this.txSize(this.hiddenTxs[ids[i]]);
            blockWeight += squareSize * squareSize;
          }

          this.width = width;
          this.height = height;
          this.blockWidth = Math.ceil(Math.sqrt(blockWeight));
          this.blockHeight = this.blockWidth;
          this.paddedUnit;
          this.gridSize = width / this.blockWidth;
          this.unitPadding = this.gridSize / 4;
          this.unitWidth = this.gridSize - this.unitPadding * 2;
          this.scene.offset = {
            x: (window.innerWidth - this.width) / 2,
            y: 2 * (window.innerHeight - this.height) / (window.innerWidth <= 640 ? 3.5 : 3)
          };
          this.scene.scroll = 0;
        } else {
          this.width = width;
          this.height = height;
        }

        this.resetLayout();
      } // calculates and returns the size of the tx in multiples of the grid size


      txSize() {
        let tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          value: 1,
          vbytes: 1
        };
        if (settingsValue.vbytes) return byteTxSize(tx.vbytes, Math.Infinity);else return logTxSize(tx.value, Math.Infinity);
      }

      setTxOnScreen(tx, pixelPosition) {
        this.saveGridToPixelPosition(tx);

        if (!tx.view.initialised) {
          tx.view.update({
            display: {
              position: {
                x: Math.random() * window.innerWidth,
                y: -(Math.random() * window.innerWidth) - this.scene.offset.y * 2 - pixelPosition.r,
                r: pixelPosition.r
              },
              color: tx.getColor('block', this.colorMode).color
            },
            delay: 0,
            state: 'ready'
          });
        }

        this.savePixelsToScreenPosition(tx, 0, this.hidden && !this.exited ? 50 : 0);

        if (this.hidden) {
          tx.view.update({
            display: {
              position: tx.screenPosition,
              color: tx.getColor('block', this.colorMode).color
            },
            duration: 0,
            delay: 0,
            state: 'block'
          });
        } else {
          tx.view.update({
            display: {
              position: tx.screenPosition,
              color: tx.getColor('block', this.colorMode).color
            },
            duration: this.laidOut ? 1000 : 2000,
            delay: 200,
            jitter: this.laidOut ? 500 : 1500,
            smooth: true,
            state: 'block'
          });
        }
      }

      prepareTxOnScreen(tx, now) {
        const oldRadius = tx.pixelPosition.r;
        this.saveGridToPixelPosition(tx);

        if (!tx.view.initialised) {
          tx.view.update({
            display: {
              position: {
                x: Math.random() * window.innerWidth,
                y: -(Math.random() * window.innerWidth) - this.scene.offset.y * 2 - tx.pixelPosition.r,
                r: tx.pixelPosition.r
              },
              color: { ...tx.getColor('block', this.colorMode).color,
                alpha: 1
              }
            },
            delay: 0,
            state: 'ready'
          });
        } else {
          const jitter = Math.random() * 1500;
          tx.view.update({
            display: {
              position: {
                r: oldRadius + Math.max(2, oldRadius * 0.2)
              }
            },
            delay: 200 + jitter,
            start: now,
            duration: 750,
            smooth: true,
            boomerang: true
          });
          tx.view.update({
            display: {
              color: ice(tx.colors[this.colorMode].block.color)
            },
            start: now,
            delay: 200 + jitter,
            duration: 500
          });
        }
      }

      prepareTx(tx, sequence) {
        this.place(tx);
        this.prepareTxOnScreen(tx);
      }

      enterTx(tx, start, right) {
        tx.view.update({
          display: {
            position: {
              x: tx.screenPosition.x + (right ? window.innerWidth : -window.innerWidth) + (Math.random() - 0.5) * (window.innerHeight / 4),
              y: tx.screenPosition.y + (Math.random() - 0.5) * (window.innerHeight / 4),
              r: tx.pixelPosition.r
            },
            color: { ...tx.getColor('block', this.colorMode).color,
              alpha: 0
            }
          },
          delay: 0,
          state: 'ready'
        });
        tx.view.update({
          display: {
            position: tx.screenPosition,
            color: { ...tx.getColor('block', this.colorMode).color,
              alpha: 1
            }
          },
          start,
          duration: 2000,
          delay: 200,
          jitter: 500,
          smooth: true
        });
      }

      enter(right) {
        this.hidden = false;
        this.exited = false;
        const ids = this.getActiveTxList();
        const start = performance.now();

        for (let i = 0; i < ids.length; i++) {
          this.enterTx(this.txs[ids[i]], start, right);
        }
      }

      enterRight() {
        this.enter(true);
      }

      enterLeft() {
        this.enter(false);
      }

      exitTx(tx, start, right) {
        tx.view.update({
          display: {
            position: {
              x: tx.screenPosition.x + (right ? window.innerWidth : -window.innerWidth) + (Math.random() - 0.5) * (window.innerHeight / 4),
              y: tx.screenPosition.y + (Math.random() - 0.5) * (window.innerHeight / 4),
              r: tx.pixelPosition.r
            },
            color: { ...tx.getColor('block', this.colorMode).color,
              alpha: 0
            }
          },
          delay: 200,
          start,
          jitter: 500,
          duration: 2000,
          smooth: true
        });
      }

      exit(right) {
        this.hidden = true;
        this.exited = true;
        const ids = this.getActiveTxList();
        const start = performance.now();

        for (let i = 0; i < ids.length; i++) {
          this.exitTx(this.txs[ids[i]], start, right);
        }
      }

      exitRight() {
        this.exit(true);
      }

      exitLeft() {
        this.exit(false);
      }

      hideTx(tx, now) {
        this.savePixelsToScreenPosition(tx);
        tx.view.update({
          display: {
            position: {
              y: tx.screenPosition.y + 50
            },
            color: {
              alpha: 0
            }
          },
          start: now,
          duration: 1500,
          delay: 50,
          state: 'fadeout',
          smooth: true
        });
      }

      showTx(tx, now) {
        this.savePixelsToScreenPosition(tx);
        tx.view.update({
          display: {
            position: {
              y: tx.screenPosition.y
            },
            color: {
              alpha: 1
            }
          },
          start: now,
          duration: 1500,
          delay: 50,
          state: 'fadeout',
          smooth: true
        });
      }

      prepareAll() {
        const now = performance.now();
        this.resize({});
        this.scene.count = 0;
        let ids = this.getHiddenTxList();

        for (let i = 0; i < ids.length; i++) {
          this.txs[ids[i]] = this.hiddenTxs[ids[i]];
          delete this.hiddenTxs[ids[i]];
        }

        ids = this.getActiveTxList();

        for (let i = 0; i < ids.length; i++) {
          this.prepareTx(this.txs[ids[i]], now);
        }
      }

      layoutAll(args) {
        // if (!this.hidden) {
        super.layoutAll(args);
        this.laidOut = true; // }
      }

      initialLayout(exited) {
        this.prepareAll();
        setTimeout(() => {
          this.layoutAll();
          if (exited) this.exitRight();
        }, 3000);
      }

      resetScroll() {
        return;
      }

      hide() {
        this.hidden = true;
        const now = performance.now();
        const ids = this.getActiveTxList();

        for (let i = 0; i < ids.length; i++) {
          this.hideTx(this.txs[ids[i]], now);
        }
      }

      show() {
        if (this.hidden) {
          this.hidden = false;
          const now = performance.now();
          const ids = this.getActiveTxList();

          for (let i = 0; i < ids.length; i++) {
            this.showTx(this.txs[ids[i]], now);
          }
        }
      }

      expire() {
        let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
        this.expired = true;
        const txIds = this.getTxList();

        for (let i = 0; i < txIds.length; i++) {
          if (this.txs[txIds[i]]) {
            this.controller.deleteTx(txIds[i]);
          }
        }

        setTimeout(() => {
          for (let i = 0; i < txIds.length; i++) {
            if (this.txs[txIds[i]]) {
              this.txs[txIds[i]].destroy();
            }
          }

          this.layout.destroy();
        }, delay);
      }

      selectAt(position) {
        if (this.layout) {
          const gridPosition = this.screenToGrid({
            x: position.x + this.gridSize / 4,
            y: position.y - this.gridSize / 2
          });
          return this.layout.getTxInGridCell(gridPosition);
        } else return null;
      }

    }

    function ice(color) {
      return {
        h: Math.abs(color.h - 0.58) < 0.1 ? color.h < 0.58 ? 0.48 : 0.68 : color.h,
        l: color.h < 0.76 ? 1 : 0.7
      };
    }

    const highlightTransitionTime = 300; // converts from this class's update format to TxSprite's update format
    // now, id, value, position, size, color, alpha, duration, adjust

    function toSpriteUpdate(display, duration, minDuration, delay, start, adjust, smooth, boomerang) {
      return {
        now: start || performance.now(),
        delay: delay,
        duration: duration,
        minDuration: minDuration,
        ...(display.position ? display.position : {}),
        ...(display.color ? display.color : {}),
        adjust,
        smooth,
        boomerang
      };
    }

    class TxView {
      constructor(_ref) {
        let {
          id,
          time,
          value,
          vbytes,
          vertexArray
        } = _ref;
        this.id = id;
        this.time = time;
        this.value = value;
        this.vbytes = vbytes;
        this.initialised = false;
        this.vertexArray = vertexArray;
        this.hover = false;
        this.highlight = false;
      }

      destroy() {
        if (this.sprite) {
          this.sprite.destroy();
          this.sprite = null;
        }
      }
      /*
        display: defines the final appearance of the sprite
            position: { x, y }
            size: in pixels
            color:
                i: x coord in color texture
                j: y coord in color texture
                alpha: alpha transparency
        duration: of the tweening animation from the previous display state
        delay: for queued transitions, how long to wait after current transition
               completes to start.
      */


      update(_ref2) {
        let {
          display,
          duration,
          minDuration,
          delay = 0,
          jitter,
          state,
          start,
          adjust,
          smooth,
          boomerang
        } = _ref2;
        this.state = state;
        if (jitter) delay += Math.random() * jitter;

        if (!this.initialised || !this.sprite) {
          this.initialised = true;
          this.sprite = new TxSprite(toSpriteUpdate(display, duration, minDuration, delay, start, adjust, smooth, boomerang), this.vertexArray); // apply any pending modifications

          if (this.hover) {
            this.sprite.update({ ...this.highlightColor,
              duration: highlightTransitionTime,
              adjust: false,
              modify: true
            });
          } else if (this.highlight) {
            this.sprite.update({ ...this.highlightColor,
              duration: highlightTransitionTime,
              adjust: false,
              modify: true
            });
          }
        } else {
          this.sprite.update(toSpriteUpdate(display, duration, minDuration, delay, start, adjust, smooth, boomerang));
        }
      }

      setHover(hoverOn, color) {
        if (hoverOn) {
          this.hover = true;
          this.hoverColor = color;
          this.sprite.update({ ...this.hoverColor,
            duration: highlightTransitionTime,
            adjust: false,
            modify: true
          });
        } else {
          this.hover = false;
          this.hoverColor = null;

          if (this.highlight) {
            if (this.sprite) {
              this.sprite.update({ ...this.highlightColor,
                duration: highlightTransitionTime,
                adjust: false,
                modify: true
              });
            }
          } else {
            if (this.sprite) this.sprite.resume(highlightTransitionTime);
          }
        }
      }

      setHighlight(highlightOn, color) {
        if (highlightOn) {
          this.highlight = true;
          this.highlightColor = color;

          if (!this.hover) {
            if (this.sprite) {
              this.sprite.update({ ...this.highlightColor,
                duration: highlightTransitionTime,
                adjust: false,
                modify: true
              });
            }
          }
        } else {
          this.highlight = false;
          this.highlightColor = null;

          if (!this.hover) {
            if (this.sprite) this.sprite.resume(highlightTransitionTime);
          }
        }
      }

      getPosition() {
        if (this.initialised && this.sprite) return this.sprite.getPosition();
      }

    }

    function subsidyAt(height) {
      const halvings = BigInt(Math.floor(height / 210000));
      if (halvings >= 64) return 0;else {
        let sats = BigInt(5000000000);
        sats >>= halvings;
        return Number(sats);
      }
    }

    class BitcoinTx {
      constructor(data, vertexArray) {
        let isCoinbase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        this.vertexArray = vertexArray;
        this.setData(data, isCoinbase);
        if (vertexArray) this.view = new TxView(this);
      }

      setCoinbaseData(block) {
        if (this.is_preview) {
          const subsidy = subsidyAt(block.height);
          this.coinbase = {
            height: block.height,
            fees: this.value - subsidy,
            subsidy
          };
        } else {
          const cbInfo = this.inputs[0].script_sig; // number of bytes encoding the block height

          const height_bytes = parseInt(cbInfo.substring(0, 2), 16); // extract the specified number of bytes, reverse the endianness (reverse pairs of hex characters), parse as a hex string

          const parsed_height = parseInt(cbInfo.substring(2, 2 + height_bytes * 2).match(/../g).reverse().join(''), 16); // save remaining bytes as free data

          const sig = cbInfo.substring(2 + height_bytes * 2);
          const sigAscii = sig && sig.length ? sig.match(/../g).reduce((parsed, hexChar) => {
            return parsed + String.fromCharCode(parseInt(hexChar, 16));
          }, "") : "";
          const height = block.height == null ? parsed_height : block.height;
          const subsidy = subsidyAt(height);
          this.coinbase = {
            height,
            sig,
            sigAscii,
            fees: this.value - subsidy,
            subsidy
          };
        }
      }

      setVertexArray(vertexArray) {
        this.vertexArray = vertexArray;
        this.view = new TxView(this);
      }

      mergeData(_ref) {
        let {
          version,
          inflated,
          partial,
          preview,
          id,
          value,
          fee,
          vbytes,
          numInputs,
          inputs,
          outputs,
          time,
          block
        } = _ref;
        this.setData({
          version,
          inflated: this.is_inflated || inflated,
          partial: this.is_partial && partial,
          preview: this.is_preview && preview,
          id,
          value,
          fee: this.fee || fee,
          vbytes,
          numInputs: this.numInputs || numInputs,
          inputs: this.inputs,
          outputs: this.outputs,
          time,
          block
        });
      }

      setData(_ref2) {
        let {
          version,
          inflated,
          partial,
          preview,
          id,
          value,
          fee,
          vbytes,
          numInputs,
          inputs,
          outputs,
          time,
          block
        } = _ref2;
        let isCoinbase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.version = version;
        this.is_inflated = !!inflated;
        this.is_partial = !!partial;
        this.is_preview = !!preview;
        this.id = id;
        if (!this.pixelPosition) this.pixelPosition = {
          x: 0,
          y: 0,
          r: 0
        };
        this.screenPosition = {
          x: 0,
          y: 0,
          r: 0
        };
        this.gridPosition = {
          x: 0,
          y: 0,
          r: 0
        };
        this.inputs = inputs;
        if (numInputs != null) this.numInputs = numInputs;
        this.outputs = outputs;
        this.value = value;
        this.fee = fee;
        this.vbytes = vbytes;
        if (this.fee != null) this.feerate = fee / vbytes;

        if (inputs && outputs && value == null) {
          this.value = this.calcValue();
        }

        this.time = time;
        this.highlight = false; // is a coinbase transaction?

        this.isCoinbase = isCoinbase;

        if (this.isCoinbase || this.fee == null || this.fee < 0 || this.is_partial) {
          this.fee = null;
          this.feerate = null;
        }

        if (!this.block) this.setBlock(block);
        const feeColor = this.isCoinbase || this.feerate == null ? orange : mixColor(teal, purple, 1, Math.log2(128), Math.log2(this.feerate));
        this.colors = {
          age: {
            block: {
              color: orange
            },
            pool: {
              color: orange,
              endColor: blue,
              duration: 60000
            }
          },
          fee: {
            block: {
              color: feeColor
            },
            pool: {
              color: feeColor
            }
          }
        };
      }

      destroy() {
        if (this.view) this.view.destroy();
      }

      calcValue() {
        if (this.outputs && this.outputs.length) {
          return this.outputs.reduce((acc, output) => {
            return acc + output.value;
          }, 0);
        } else return 0;
      }

      setBlock(block) {
        this.block = block;
        this.state = this.block ? 'block' : 'pool';

        if (this.block && (this.isCoinbase || this.block.coinbase && this.id == this.block.coinbase.id)) {
          this.isCoinbase = true;
          this.setCoinbaseData(this.block);
        }
      }

      onEnterScene() {
        this.enteredTime = performance.now();
      }

      getColor(scene, mode) {
        return this.colors[mode][scene];
      }

      hoverOn() {
        let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bluegreen;
        if (this.view) this.view.setHover(true, color);
      }

      hoverOff() {
        if (this.view) this.view.setHover(false);
      }

      highlightOn() {
        let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : pink;
        if (this.view) this.view.setHighlight(true, color);
        this.highlight = true;
      }

      highlightOff() {
        if (this.view) this.view.setHighlight(false);
        this.highlight = false;
      }

      applyHighlighting(criteria) {
        let color;
        this.highlight = false;
        criteria.forEach(criterion => {
          if (criterion.txid === this.id) {
            this.highlight = true;
            color = criterion.color;
          } else if (criterion.address && criterion.scriptPubKey) {
            this.outputs.forEach(output => {
              if (output.script_pub_key === criterion.scriptPubKey) {
                this.highlight = true;
                color = criterion.color;
              }
            });
          }
        });
        this.view.setHighlight(this.highlight, color || pink);
      }

      static fromRPCData(txData, isCoinbase) {
        return {
          version: txData.version,
          inflated: false,
          preview: true,
          id: txData.txid,
          value: null,
          // calculated in constructor
          fee: txData.fee * 100000000,
          vbytes: txData.vsize,
          inputs: txData.vin.map(vin => {
            return {
              script_sig: vin.coinbase || vin.scriptSig.hex,
              prev_txid: vin.txid,
              prev_vout: vin.vout
            };
          }),
          outputs: txData.vout.map(vout => {
            return {
              value: vout.value * 100000000,
              script_pub_key: vout.scriptPubKey.hex
            };
          })
        };
      } // unpack compact array format tx data


      static decompress(data, blockData) {
        return {
          version: data[0],
          inflated: false,
          preview: true,
          id: data[1],
          fee: data[2],
          value: data[3],
          vbytes: data[4],
          numInputs: data[5],
          outputs: data[6].map(vout => {
            return {
              value: vout[0],
              script_pub_key: vout[1]
            };
          })
        };
      }

    }

    class BitcoinBlock {
      constructor(_ref) {
        let {
          version,
          id,
          height,
          value,
          prev_block,
          merkle_root,
          timestamp,
          bits,
          bytes,
          txn_count,
          txns,
          fees
        } = _ref;
        this.isBlock = true;
        this.version = version;
        this.id = id;
        this.height = height;
        this.value = value;
        this.prev_block = prev_block;
        this.merkle_root = merkle_root;
        this.time = timestamp * 1000; // btc protocol gives times in seconds, js needs milliseconds

        this.bits = bits; // difficulty target (i.e. number of 0 bits required for hash)

        this.bytes = bytes; // OTW size of this block in bytes

        this.txnCount = txn_count;
        this.txns = txns;
        this.coinbase = new BitcoinTx(this.txns[0], true);
        this.fees = fees;
        this.coinbase.setBlock(this);
        this.height = this.height || this.coinbase.coinbase.height;
        this.miner_sig = this.coinbase.coinbase.sigAscii;
        this.total_vbytes = 0;

        if (this.fees != null) {
          this.maxFeerate = 0;
          this.minFeerate = this.txnCount > 1 ? Infinity : 0;
          this.avgFeerate = 0;
          this.txns.forEach(txn => {
            if (txn.id !== this.coinbase.id) {
              const txFeerate = txn.fee / txn.vbytes;
              this.maxFeerate = Math.max(this.maxFeerate, txFeerate);
              this.minFeerate = Math.min(this.minFeerate, txFeerate);
              this.avgFeerate += txn.feerate / this.txnCount;
            }

            this.total_vbytes += txn.vbytes;
          });
          this.avgFeerate = this.fees / this.total_vbytes;
        }
      }

      setVertexArray(vertexArray) {
        if (this.txns) {
          this.txns.forEach(txn => {
            txn.setVertexArray(vertexArray);
          });
        }
      }

      static fromRPCData(data) {
        const txns = data.tx.map((tx, index) => {
          return BitcoinTx.fromRPCData(tx, index == 0);
        });
        const value = txns.reduce((acc, tx) => {
          return acc + tx.fee + tx.value;
        }, 0);
        const fees = txns.reduce((acc, tx) => {
          return acc + tx.fee;
        }, 0);
        return {
          version: data.version,
          id: data.hash,
          height: data.height,
          value: value,
          prev_block: data.previousblockhash,
          merkle_root: data.merkleroot,
          timestamp: data.time,
          bits: data.bits,
          bytes: data.size,
          txn_count: txns.length,
          txns,
          fees
        };
      }

      static decompress(data) {
        return {
          version: data[0],
          id: data[1],
          height: data[2],
          value: data[3],
          prev_block: data[4],
          timestamp: data[5],
          bits: data[6],
          bytes: data[7],
          txn_count: data[8].length,
          txns: data[8].map(txData => BitcoinTx.decompress(txData)),
          fees: data[9]
        };
      }

    }

    /*
      Utility class for access and management of low-level sprite data

      Maintains a single Float32Array of sprite data, keeping track of empty slots
      to allow constant-time insertion and deletion

      Automatically resizes by copying to a new, larger Float32Array when necessary,
      or compacting into a smaller Float32Array when there's space to do so.
    */
    class FastVertexArray {
      constructor(length, stride, counter) {
        // console.log(`Creating Fast Vertex Array with length ${length} and stride ${stride} `)
        this.length = length;
        this.counter = counter;
        this.count = 0;
        this.stride = stride;
        this.sprites = [];
        this.data = new Float32Array(this.length * this.stride);
        this.freeSlots = [];
        this.lastSlot = 0;
        this.nullSprite = new Float32Array(this.stride); // this.print()
      }

      print() {// console.log(`Length: ${this.length}, Free slots: ${this.freeSlots.length}, last slot: ${this.lastSlot}`)
        // console.log(this.freeSlots)
        // console.log(this.data)
      }

      insert(sprite) {
        // console.log('inserting into FVA')
        this.count++;
        if (this.counter) this.counter.increment();
        let position;

        if (this.freeSlots.length) {
          position = this.freeSlots.shift();
        } else {
          position = this.lastSlot;
          this.lastSlot++;

          if (this.lastSlot > this.length) {
            this.expand();
          }
        } // this.print()


        this.sprites[position] = sprite;
        return position;
      }

      remove(index) {
        this.count--;
        if (this.counter) this.counter.decrement();
        this.setData(index, this.nullSprite);
        this.freeSlots.push(index);
        this.sprites[index] = null;
        if (this.length > 2048 && this.count < this.length * 0.4) this.compact(); // this.print()
      }

      setData(index, dataChunk) {
        // console.log(`Updating chunk at ${index} (${index * this.stride})`)
        this.data.set(dataChunk, index * this.stride); // this.print()
      }

      getData(index) {
        return this.data.subarray(index, this.stride);
      }

      expand() {
        // console.log('Expanding FVA')
        this.length *= 2;
        const newData = new Float32Array(this.length * this.stride);
        newData.set(this.data);
        this.data = newData;
        this.print();
      }

      compact() {
        // console.log('Compacting FVA')
        // console.log(this.sprites)
        // New array length is the smallest power of 2 larger than the sprite count (but no smaller than 512)
        const newLength = Math.max(512, Math.pow(2, Math.ceil(Math.log2(this.count))));

        if (this.newLength != this.length) {
          // console.log(`compacting from ${this.length} to ${newLength}`)
          this.length = newLength;
          this.data = new Float32Array(this.length * this.stride);
          let sprite;
          const newSprites = [];
          let i = 0;

          for (var index in this.sprites) {
            sprite = this.sprites[index];

            if (sprite) {
              newSprites.push(sprite);
              sprite.moveVertexPointer(i);
              sprite.compile();
              i++;
            }
          }

          this.sprites = newSprites;
          this.freeSlots = [];
          this.lastSlot = i;
        }

        this.print();
      }

      getVertexData() {
        return this.data;
      }

    }

    const apiRoot = `${config$1.backend ? config$1.backend : window.location.host}${config$1.backendPort ? ":" + config$1.backendPort : ""}`;
    var api = {
      root: apiRoot,
      websocketUri: `${config$1.secureSocket ? "wss://" : "ws://"}${apiRoot}/ws/txs`,
      uri: `${config$1.secureSocket ? "https://" : "http://"}${apiRoot}`
    };

    var buffer = {};

    var base64Js = {};

    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    } // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications


    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens(b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      } // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42


      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;
      var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    } // base64 is 4/3 + up to two characters of the original data


    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }

    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

      var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i;

      for (i = 0; i < len; i += 4) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr;
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }

    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];

      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }

      return output.join('');
    }

    function fromByteArray(uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3
      // go through the array every three bytes, we'll deal with trailing stuff later

      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      } // pad the end with zeros, but make sure to not forget the extra bytes


      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
      }

      return parts.join('');
    }

    var ieee754 = {};

    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

    ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;

      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;

      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }

      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };

    ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);

        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }

        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }

        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = e << mLen | m;
      eLen += mLen;

      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    (function (exports) {

    const base64 = base64Js;

    const ieee754$1 = ieee754;

    const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */

    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      // Can typed array instances can be augmented?
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function () {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      } // Return an augmented `Uint8Array` instance


      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }

      if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      const valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      const b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148


    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);

      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }

      return fromArrayLike(arrayView);
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      let buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      } // Return an augmented `Uint8Array` instance


      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      let x = a.length;
      let y = b.length;

      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      let i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      const buffer = Buffer.allocUnsafe(length);
      let pos = 0;

      for (i = 0; i < list.length; ++i) {
        let buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }

        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
      }

      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

      let loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      let loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      const len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      const len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      const len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      let str = '';
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);

      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      let i;

      if (dir) {
        let foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          let found = true;

          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      const strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      let i;

      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      const remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      let loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;

      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    const MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      let res = '';
      let i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      let ret = '';
      end = Math.min(buf.length, end);

      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      let ret = '';
      end = Math.min(buf.length, end);

      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = '';

      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      const newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      let val = this[offset + --byteLength];
      let mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      const first = this[offset];
      const last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      const first = this[offset];
      const last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      let i = byteLength;
      let mul = 1;
      let val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      const first = this[offset];
      const last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow

      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      const first = this[offset];
      const last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      let mul = 1;
      let i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      let i = byteLength - 1;
      let mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(0xffffffff));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }

    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(0xffffffff));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }

    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      let i = byteLength - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      const len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          const code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // CUSTOM ERRORS
    // =============
    // Simplified versions from Node, changed for Buffer-only usage


    const errors = {};

    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, 'message', {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          }); // Add the error code to the name to include it in the stack trace.

          this.name = `${this.name} [${sym}]`; // Access the stack to generate the error message including the error code
          // from the name.

          this.stack; // eslint-disable-line no-unused-expressions
          // Reset the name to the actual name.

          delete this.name;
        }

        get code() {
          return sym;
        }

        set code(value) {
          Object.defineProperty(this, 'code', {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }

        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }

      };
    }

    E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }

      return 'Attempt to access memory outside buffer bounds';
    }, RangeError);
    E('ERR_INVALID_ARG_TYPE', function (name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E('ERR_OUT_OF_RANGE', function (str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;

      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);

        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }

        received += 'n';
      }

      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);

    function addNumericalSeparator(val) {
      let res = '';
      let i = val.length;
      const start = val[0] === '-' ? 1 : 0;

      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }

      return `${val.slice(0, i)}${res}`;
    } // CHECK FUNCTIONS
    // ===============


    function checkBounds(buf, offset, byteLength) {
      validateNumber(offset, 'offset');

      if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
      }
    }

    function checkIntBI(value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;

        if (byteLength > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }

        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
      }

      checkBounds(buf, offset, byteLength);
    }

    function validateNumber(value, name) {
      if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
      }
    }

    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
      }

      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }

      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
    } // HELPER FUNCTIONS
    // ================


    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

      str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];

      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      const byteArray = [];

      for (let i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];

      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      let i;

      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166


    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      // For IE11 support
      return obj !== obj; // eslint-disable-line no-self-compare
    } // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219


    const hexSliceLookupTable = function () {
      const alphabet = '0123456789abcdef';
      const table = new Array(256);

      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;

        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }

      return table;
    }(); // Return not function with Error if BigInt not supported


    function defineBigIntMethod(fn) {
      return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
    }

    function BufferBigIntNotDefined() {
      throw new Error('BigInt not supported');
    }
    }(buffer));

    var lib = {};

    var bitConverter = {};

    Object.defineProperty(bitConverter, "__esModule", {
      value: true
    });
    bitConverter.createBitArray = createBitArray;
    bitConverter.fromBits = fromBits;
    bitConverter.toBits = toBits;
    /* eslint-disable no-unused-vars */

    /**
     * Virtual type for bit arrays, i.e., arrays in which each element contains
     * an integer in range `[0, 1 << L)`, where `1 <= L <= 8`.
     */

    /* eslint-enable no-unused-vars */

    /**
     * Performs unchecked conversion from `Uint8Array` to `BitArray`.
     * This function is translated as the indentity operation by Babel; it's needed purely
     * for Flow type checks.
     *
     * @param {Uint8Array} src
     *   array to convert
     * @returns {Uint8Array}
     *   `src` interpreted as a `BitArray` with the specified bitness
     *
     * @api private
     */

    function toBitArrayUnchecked(src) {
      return src;
    }
    /**
     * Creates a new array with specified bitness.
     *
     * @param {number} len
     *   length of the created array
     * @returns {Uint8Array}
     *
     * @api private
     */


    function createBitArray(len) {
      return toBitArrayUnchecked(new Uint8Array(len));
    }
    /**
     * Converts an array from one number of bits per element to another.
     *
     * @api private
     */


    function convert(src, srcBits, dst, dstBits, pad) {
      var mask = (1 << dstBits) - 1;
      var acc = 0;
      var bits = 0;
      var pos = 0;
      src.forEach(function (b) {
        // Pull next bits from the input buffer into accumulator.
        acc = (acc << srcBits) + b;
        bits += srcBits; // Push into the output buffer while there are enough bits in the accumulator.

        while (bits >= dstBits) {
          bits -= dstBits;
          dst[pos] = acc >> bits & mask;
          pos += 1;
        }
      });

      if (pad) {
        if (bits > 0) {
          // `dstBits - rem.bits` is the number of trailing zero bits needed to be appended
          // to accumulator bits to get the trailing bit group.
          dst[pos] = acc << dstBits - bits & mask;
        }
      } else {
        // Truncate the remaining padding, but make sure that it is zeroed and not
        // overly long first.
        if (bits >= srcBits) {
          throw new Error("Excessive padding: ".concat(bits, " (max ").concat(srcBits - 1, " allowed)"));
        }

        if (acc % (1 << bits) !== 0) {
          throw new Error('Non-zero padding');
        }
      }
    }
    /**
     * Encodes a `Uint8Array` buffer as an array with a lesser number of bits per element.
     *
     * @api private
     */


    function toBits(src, bits, dst) {
      if (bits > 8 || bits < 1) {
        throw new RangeError('Invalid bits per element; 1 to 8 expected');
      } // `BitArray<8>` is equivalent to `Uint8Array`; unfortunately, Flow
      // has problems expressing this, so the explicit conversion is performed here.


      convert(toBitArrayUnchecked(src), 8, dst, bits, true);
      return dst;
    }

    function fromBits(src, bits, dst) {
      if (bits > 8 || bits < 1) {
        throw new RangeError('Invalid bits per element; 1 to 8 expected');
      }

      convert(src, bits, toBitArrayUnchecked(dst), 8, false);
      return dst;
    }

    var encoding = {};

    Object.defineProperty(encoding, "__esModule", {
      value: true
    });
    encoding.CHECKSUM_LENGTH = void 0;
    encoding.createChecksum = createChecksum;
    encoding.decode = decode$1;
    encoding.decodeWithPrefix = decodeWithPrefix;
    encoding.encode = encode$1;
    encoding.expandPrefix = expandPrefix;
    encoding.verifyChecksum = verifyChecksum;

    var _bitConverter$1 = bitConverter; // Alphabet for Bech32


    var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'; // Checksum constant for Bech32m.

    var BECH32M_CHECKSUM = 0x2bc830a3;
    var CHECKSUM_LENGTH = 6; // Reverse lookup for characters

    encoding.CHECKSUM_LENGTH = CHECKSUM_LENGTH;

    var CHAR_LOOKUP = function () {
      var lookup = new Map();

      for (var i = 0; i < CHARSET.length; i += 1) {
        lookup.set(CHARSET[i], i);
      }

      return lookup;
    }(); // Poly generators


    var GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

    function polymod(values) {
      return values.reduce(function (checksum, value) {
        var bits = checksum >> 25;
        var newChecksum = (checksum & 0x1ffffff) << 5 ^ value;
        return GEN.reduce(function (chk, gen, i) {
          return (bits >> i & 1) === 0 ? chk : chk ^ gen;
        }, newChecksum);
      },
      /* initial checksum */
      1);
    }
    /**
     * Expands a prefix into the specified output buffer.
     */


    function expandPrefix(prefix, outBuffer) {
      for (var i = 0; i < prefix.length; i += 1) {
        var code = prefix.charCodeAt(i);
        outBuffer[i] = code >> 5;
        outBuffer[i + prefix.length + 1] = code & 31;
      }

      outBuffer[prefix.length] = 0;
    }
    /**
     * Verifies the checksum for a particular buffer.
     */


    function verifyChecksum(buffer) {
      switch (polymod(buffer)) {
        case 1:
          return 'bech32';

        case BECH32M_CHECKSUM:
          return 'bech32m';

        default:
          return undefined;
      }
    }
    /**
     * Creates a checksum for a buffer and writes it to the last 6 5-bit groups
     * of the buffer.
     */


    function createChecksum(buffer, encoding) {
      var checksumConstant;

      switch (encoding) {
        case 'bech32':
          checksumConstant = 1;
          break;

        case 'bech32m':
          checksumConstant = BECH32M_CHECKSUM;
          break;

        default:
          throw Error("Invalid encoding value: ".concat(encoding, "; expected bech32 or bech32m"));
      }

      var mod = polymod(buffer) ^ checksumConstant;

      for (var i = 0; i < CHECKSUM_LENGTH; i += 1) {
        var shift = 5 * (5 - i);
        buffer[buffer.length - CHECKSUM_LENGTH + i] = mod >> shift & 31;
      }
    }
    /**
     * Encodes an array of 5-bit groups into a string.
     *
     * @param {Uint8Array} buffer
     * @returns {string}
     *
     * @api private
     */


    function encode$1(buffer) {
      return buffer.reduce(function (acc, bits) {
        return acc + CHARSET[bits];
      }, '');
    }
    /**
     * Decodes a string into an array of 5-bit groups.
     *
     * @param {string} message
     * @param {Uint8Array} [dst]
     *   Optional array to write the output to. If not specified, the array is created.
     * @returns {Uint8Array}
     *   Array with the result of decoding
     *
     * @throws {Error}
     *   if there are characters in `message` not present in the encoding alphabet
     *
     * @api private
     */


    function decode$1(message, dst) {
      var realDst = dst || (0, _bitConverter$1.createBitArray)(message.length);

      for (var i = 0; i < message.length; i += 1) {
        var idx = CHAR_LOOKUP.get(message[i]);

        if (idx === undefined) {
          throw new Error("Invalid char in message: ".concat(message[i]));
        }

        realDst[i] = idx;
      }

      return realDst;
    }
    /**
     * Decodes a string and a human-readable prefix into an array of 5-bit groups.
     * The prefix is expanded as specified by Bech32.
     *
     * @param {string} prefix
     * @param {string} message
     * @returns {Uint8Array}
     *   Array with the result of decoding
     *
     * @api private
     */


    function decodeWithPrefix(prefix, message) {
      var len = message.length + 2 * prefix.length + 1;
      var dst = (0, _bitConverter$1.createBitArray)(len);
      expandPrefix(prefix, dst.subarray(0, 2 * prefix.length + 1));
      decode$1(message, dst.subarray(2 * prefix.length + 1));
      return dst;
    }

    Object.defineProperty(lib, "__esModule", {
      value: true
    });
    lib.BitcoinAddress = void 0;
    lib.decode = decode;
    lib.decodeTo5BitArray = decodeTo5BitArray;
    lib.encode = encode;
    lib.encode5BitArray = encode5BitArray;
    lib.from5BitArray = from5BitArray;
    lib.to5BitArray = to5BitArray;

    var _bitConverter = bitConverter;

    var _encoding = encoding;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    } // Minimum char code that could be present in the encoded message


    var MIN_CHAR_CODE = 33; // Maximum char code that could be present in the encoded message

    var MAX_CHAR_CODE = 126; // Maximum encoded message length

    var MAX_ENC_LENGTH = 90;
    /**
     * Converts a Uint8Array into a Uint8Array variant, in which each element
     * encodes 5 bits of the original byte array.
     *
     * @param {Uint8Array} src
     *   Input to convert
     * @param {?Uint8Array} dst
     *   Optional output buffer. If specified, the sequence of 5-bit chunks will be written there;
     *   if not specified, the output buffer will be created from scratch. The length
     *   of `outBuffer` is not checked.
     * @returns {Uint8Array}
     *   Output buffer consisting of 5-bit chunks
     *
     * @api public
     */

    function to5BitArray(src, dst) {
      var len = Math.ceil(src.length * 8 / 5);
      var realDst = dst || (0, _bitConverter.createBitArray)(len);
      return (0, _bitConverter.toBits)(src, 5, realDst);
    }

    function from5BitArray(src, dst) {
      var len = Math.floor(src.length * 5 / 8);
      var realDst = dst || new Uint8Array(len);
      return (0, _bitConverter.fromBits)(src, 5, realDst);
    }
    /**
     * Encodes binary data into Bech32 encoding.
     *
     * Ordinarily, you may want to use [`encode`](#encode) because it converts
     * binary data to an array of 5-bit integers automatically.
     *
     * @param {string} prefix
     *   Human-readable prefix to place at the beginning of the encoding
     * @param {Uint8Array} data
     *   Array of 5-bit integers with data to encode
     * @param {Encoding} encoding
     *   Encoding to use; influences the checksum computation. If not specified,
     *   Bech32 encoding will be used.
     * @returns {string}
     *   Bech32 encoding of data in the form `<prefix>1<base32 of data><checksum>`
     *
     * @api public
     */


    function encode5BitArray(prefix, data) {
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bech32'; // 1. Allocate buffer for all operations

      var len = 2 * prefix.length + 1 // expanded prefix
      + data.length // five-bit data encoding
      + _encoding.CHECKSUM_LENGTH; // checksum

      if (len - prefix.length > MAX_ENC_LENGTH) {
        throw new Error("Message to be produced is too long (max ".concat(MAX_ENC_LENGTH, " supported)"));
      }

      for (var i = 0; i < prefix.length; i += 1) {
        var ord = prefix.charCodeAt(i);

        if (ord < MIN_CHAR_CODE || ord > MAX_CHAR_CODE) {
          throw new TypeError("Invalid char in prefix: ".concat(ord, "; should be in ASCII range ").concat(MIN_CHAR_CODE, "-").concat(MAX_CHAR_CODE));
        }
      }

      var buffer = (0, _bitConverter.createBitArray)(len); // 2. Expand the human-readable prefix into the beginning of the buffer

      (0, _encoding.expandPrefix)(prefix, buffer.subarray(0, 2 * prefix.length + 1)); // 3. Copy `data` into the output

      var dataBuffer = buffer.subarray(2 * prefix.length + 1, buffer.length - _encoding.CHECKSUM_LENGTH);
      dataBuffer.set(data); // 4. Create the checksum

      (0, _encoding.createChecksum)(buffer, encoding); // 5. Convert into string

      var encoded = (0, _encoding.encode)(buffer.subarray(2 * prefix.length + 1));
      return "".concat(prefix, "1").concat(encoded);
    }
    /**
     * Encodes binary data into Bech32 encoding.
     *
     * @param {string} prefix
     *   Human-readable prefix to place at the beginning of the encoding
     * @param {Uint8Array} data
     *   Binary data to encode
     * @param {Encoding} encoding
     *   Encoding to use; influences the checksum computation. If not specified,
     *   Bech32 encoding will be used.
     * @returns {string}
     *   Bech32 encoding of data in the form `<prefix>1<base32 of data><checksum>`
     *
     * @api public
     */


    function encode(prefix, data) {
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bech32';
      return encode5BitArray(prefix, to5BitArray(data), encoding);
    }
    /**
     * Decodes data from Bech32 encoding into an array of 5-bit integers.
     *
     * Ordinarily, you may want to use [`decode`](#decode) because it automatically
     * converts the array of 5-bit integers into an ordinary `Uint8Array`.
     *
     * @param {string} message
     *   Bech32-encoded message
     * @returns {DecodeResult<FiveBitArray>}
     *   Decoded object with `prefix` and `data` fields, which contain the human-readable
     *   prefix and the array of 5-bit integers respectively.
     *
     * @api public
     */


    function decodeTo5BitArray(message) {
      // Check preconditions
      // 1. Message length
      if (message.length > MAX_ENC_LENGTH) {
        throw new TypeError("Message too long; max ".concat(MAX_ENC_LENGTH, " expected"));
      } // 2. Mixed case


      var hasLowerCase = false;
      var hasUpperCase = false;

      for (var i = 0; i < message.length; i += 1) {
        var ord = message.charCodeAt(i); // 3. Allowed chars in the encoding

        if (ord < MIN_CHAR_CODE || ord > MAX_CHAR_CODE) {
          throw new TypeError("Invalid char in message: ".concat(ord, "; should be in ASCII range ").concat(MIN_CHAR_CODE, "-").concat(MAX_CHAR_CODE));
        }

        hasLowerCase = hasLowerCase || ord >= 65 && ord <= 90;
        hasUpperCase = hasUpperCase || ord >= 97 && ord <= 122;
      }

      if (hasLowerCase && hasUpperCase) {
        throw new TypeError('Mixed-case message');
      }

      var lowerCaseMsg = message.toLowerCase(); // 4. Existence of the separator char

      var sepIdx = lowerCaseMsg.lastIndexOf('1');

      if (sepIdx < 0) {
        throw new Error('No separator char ("1") found');
      } // 5. Placing of the separator char in the message


      if (sepIdx > message.length - _encoding.CHECKSUM_LENGTH - 1) {
        throw new Error("Data part of the message too short (at least ".concat(_encoding.CHECKSUM_LENGTH, " chars expected)"));
      }

      var prefix = lowerCaseMsg.substring(0, sepIdx); // Checked within `decodeWithPrefix`:
      // 6. Invalid chars in the data part of the message

      var bitArray = (0, _encoding.decodeWithPrefix)(prefix, lowerCaseMsg.substring(sepIdx + 1)); // 7. Checksum

      var encoding = (0, _encoding.verifyChecksum)(bitArray);

      if (encoding === undefined) {
        throw new Error('Invalid checksum');
      }

      return {
        prefix: prefix,
        encoding: encoding,
        // Strip off the prefix from the front and the checksum from the end
        data: bitArray.subarray(2 * prefix.length + 1, bitArray.length - _encoding.CHECKSUM_LENGTH)
      };
    }
    /**
     * Decodes data from Bech32 encoding into an array of 5-bit integers.
     *
     * @param {string} message
     *   Bech32-encoded message
     * @returns {DecodeResult}
     *   Decoded object with `prefix` and `data` fields, which contain the human-readable
     *   prefix and the decoded binary data respectively.
     *
     * @api public
     */


    function decode(message) {
      var _decodeTo5BitArray = decodeTo5BitArray(message),
          prefix = _decodeTo5BitArray.prefix,
          encoding = _decodeTo5BitArray.encoding,
          bitArray = _decodeTo5BitArray.data;

      return {
        prefix: prefix,
        encoding: encoding,
        data: from5BitArray(bitArray)
      };
    }
    /**
     * Bitcoin address.
     */


    var BitcoinAddress = /*#__PURE__*/function () {
      function BitcoinAddress(prefix, scriptVersion, data) {
        _classCallCheck(this, BitcoinAddress);

        if (prefix !== 'bc' && prefix !== 'tb') {
          throw new Error('Invalid human-readable prefix, "bc" or "tb" expected');
        }

        if (scriptVersion < 0 || scriptVersion > 16) {
          throw new RangeError('Invalid scriptVersion, value in range [0, 16] expected');
        }

        if (data.length < 2 || data.length > 40) {
          throw new RangeError('Invalid script length: expected 2 to 40 bytes');
        }

        if (scriptVersion === 0 && data.length !== 20 && data.length !== 32) {
          throw new Error('Invalid v0 script length: expected 20 or 32 bytes');
        }

        this.prefix = prefix;
        this.scriptVersion = scriptVersion;
        this.data = data;
      }
      /**
       * Guesses the address type based on its internal structure.
       *
       * @returns {void | 'p2wpkh' | 'p2wsh'}
       */


      _createClass(BitcoinAddress, [{
        key: "type",
        value: function type() {
          if (this.scriptVersion !== 0) {
            return undefined;
          }

          switch (this.data.length) {
            case 20:
              return 'p2wpkh';

            case 32:
              return 'p2wsh';
            // should be unreachable, but it's JS, so you never know

            default:
              return undefined;
          }
        }
        /**
         * Encodes this address in Bech32 or Bech32m format, depending on the script version.
         * Version 0 scripts are encoded using original Bech32 encoding as per BIP 173,
         * while versions 1-16 are encoded using the modified encoding as per BIP 350.
         *
         * @returns {string}
         *   Bech32(m)-encoded address
         */

      }, {
        key: "encode",
        value: function encode() {
          // Bitcoin addresses use Bech32 in a peculiar way - script version is
          // not a part of the serialized binary data, but is rather prepended as 5-bit value
          // before the rest of the script. This necessitates some plumbing here.
          var len = Math.ceil(this.data.length * 8 / 5);
          var converted = (0, _bitConverter.createBitArray)(len + 1);
          converted[0] = this.scriptVersion;
          to5BitArray(this.data, converted.subarray(1));
          var encoding = this.scriptVersion === 0 ? 'bech32' : 'bech32m';
          return encode5BitArray(this.prefix, converted, encoding);
        }
      }], [{
        key: "decode",
        value:
        /**
         * Human-readable prefix. Equal to `'bc'` (for mainnet addresses)
         * or `'tb'` (for testnet addresses).
         */

        /**
         * Script version. An integer between 0 and 16 (inclusive).
         */

        /**
         * Script data. A byte string with length 2 to 40 (inclusive).
         */

        /**
         * Decodes a Bitcoin address from a Bech32(m) string.
         * As per BIP 350, the original encoding is expected for version 0 scripts, while
         * other script versions expect the modified encoding.
         *
         * This method does not check whether the address is well-formed;
         * use `type()` method on returned address to find that out.
         *
         * @param {string} message
         * @returns {BitcoinAddress}
         */
        function decode(message) {
          var _decodeTo5BitArray2 = decodeTo5BitArray(message),
              prefix = _decodeTo5BitArray2.prefix,
              data = _decodeTo5BitArray2.data,
              encoding = _decodeTo5BitArray2.encoding; // Extra check to satisfy Flow.


          if (prefix !== 'bc' && prefix !== 'tb') {
            throw new Error('Invalid human-readable prefix, "bc" or "tb" expected');
          }

          var scriptVersion = data[0];

          if (scriptVersion === 0 && encoding !== 'bech32') {
            throw Error("Unexpected encoding ".concat(encoding, " used for version 0 script"));
          }

          if (scriptVersion > 0 && encoding !== 'bech32m') {
            throw Error("Unexpected encoding ".concat(encoding, " used for version ").concat(scriptVersion, " script"));
          }

          return new this(prefix, scriptVersion, from5BitArray(data.subarray(1)));
        }
      }]);

      return BitcoinAddress;
    }();

    lib.BitcoinAddress = BitcoinAddress;

    /**
     * Base58 characters must only include numbers 123456789, uppercase ABCDEFGHJKLMNPQRSTUVWXYZ and lowercase abcdefghijkmnopqrstuvwxyz.
     * @kind namespace
     * @name base58_chars
     * @type {string}
     */

    const base58_chars$3 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    var base58_chars_1 = base58_chars$3;

    const base58_chars$2 = base58_chars_1;
    /**
     * Generates a mapping between base58 and ascii.
     * @name create_base58_map
     * @kind function
     * @returns {Array} mapping between ascii and base58.
     * @ignore
     */


    const create_base58_map$1 = () => {
      const base58M = Array(256).fill(-1);

      for (let i = 0; i < base58_chars$2.length; ++i) base58M[base58_chars$2.charCodeAt(i)] = i;

      return base58M;
    };

    var create_base58_map_1 = create_base58_map$1;

    const base58_chars$1 = base58_chars_1;

    const create_base58_map = create_base58_map_1;

    const base58Map = create_base58_map();
    /**
     * Converts a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) into a base58 string.
     * @kind function
     * @name binary_to_base58
     * @param {Uint8Array | Array} uint8array Unsigned integer.
     * @returns {base58_chars} The base58 string representation of the binary array.
     * @example <caption>Ways to `require`.</caption>
     * ```js
     * const { binary_to_base58 } = require("base58-js")
     * ```
     * @example <caption>Ways to `import`.</caption>
     * ```js
     * import { binary_to_base58 } from 'base58-js'
     * ```
     * @example <caption>Usage.</caption>
     * ```js
     * const str = binary_to_base58([15, 239, 64])
     * console.log(str)
     * ```
     * Logged output will be 6MRy.
     */

    const binary_to_base58 = uint8array => {
      const result = [];

      for (const byte of uint8array) {
        let carry = byte;

        for (let j = 0; j < result.length; ++j) {
          const x = (base58Map[result[j]] << 8) + carry;
          result[j] = base58_chars$1.charCodeAt(x % 58);
          carry = x / 58 | 0;
        }

        while (carry) {
          result.push(base58_chars$1.charCodeAt(carry % 58));
          carry = carry / 58 | 0;
        }
      }

      for (const byte of uint8array) if (byte) break;else result.push('1'.charCodeAt(0));

      result.reverse();
      return String.fromCharCode(...result);
    };

    var binary_to_base58_1 = binary_to_base58;

    const base58_chars = base58_chars_1;
    /**
     * Converts a `base58` string to its corresponding binary representation.
     * @kind function
     * @name base58_to_binary
     * @param {base58_chars} base58String base58 encoded string
     * @returns {Uint8Array} binary representation for the base58 string.
     * @example <caption>Ways to `import`.</caption>
     * ```js
     * import { base58_to_binary } from 'base58-js'
     * ```
     * @example <caption>Ways to `require`.</caption>
     * ```js
     * const { base58_to_binary } = require('base58-js')
     * ```
     * @example <caption>Usage.</caption>
     * ```js
     * const bin = base58_to_binary("6MRy")
     * console.log(bin)
     * ```
     * Logged output will be Uint8Array(3) [15, 239, 64].
     */


    const base58_to_binary = base58String => {
      if (!base58String || typeof base58String !== 'string') throw new Error(`Expected base58 string but got “${base58String}”`);
      if (base58String.match(/[IOl0]/gm)) throw new Error(`Invalid base58 character “${base58String.match(/[IOl0]/gm)}”`);
      const lz = base58String.match(/^1+/gm);
      const psz = lz ? lz[0].length : 0;
      const size = (base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
      return new Uint8Array([...new Uint8Array(psz), ...base58String.match(/.{1}/g).map(i => base58_chars.indexOf(i)).reduce((acc, i) => {
        acc = acc.map(j => {
          const x = j * 58 + i;
          i = x >> 8;
          return x;
        });
        return acc;
      }, new Uint8Array(size)).reverse().filter((lastValue => value => lastValue = lastValue || value)(false))]);
    };

    var base58_to_binary_1 = base58_to_binary;

    var hash$1 = {};

    var utils$b = {};

    var minimalisticAssert = assert$5;

    function assert$5(val, msg) {
      if (!val) throw new Error(msg || 'Assertion failed');
    }

    assert$5.equal = function assertEqual(l, r, msg) {
      if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
    };

    var inherits_browser = {exports: {}};

    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;

          var TempCtor = function () {};

          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }

    var assert$4 = minimalisticAssert;

    var inherits = inherits_browser.exports;

    utils$b.inherits = inherits;

    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
        return false;
      }

      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }

      return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
    }

    function toArray(msg, enc) {
      if (Array.isArray(msg)) return msg.slice();
      if (!msg) return [];
      var res = [];

      if (typeof msg === 'string') {
        if (!enc) {
          // Inspired by stringToUtf8ByteArray() in closure-library by Google
          // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
          // Apache License 2.0
          // https://github.com/google/closure-library/blob/master/LICENSE
          var p = 0;

          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);

            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === 'hex') {
          msg = msg.replace(/[^a-z0-9]+/ig, '');
          if (msg.length % 2 !== 0) msg = '0' + msg;

          for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
      }

      return res;
    }

    utils$b.toArray = toArray;

    function toHex(msg) {
      var res = '';

      for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

      return res;
    }

    utils$b.toHex = toHex;

    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
      return res >>> 0;
    }

    utils$b.htonl = htonl;

    function toHex32(msg, endian) {
      var res = '';

      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === 'little') w = htonl(w);
        res += zero8(w.toString(16));
      }

      return res;
    }

    utils$b.toHex32 = toHex32;

    function zero2(word) {
      if (word.length === 1) return '0' + word;else return word;
    }

    utils$b.zero2 = zero2;

    function zero8(word) {
      if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
    }

    utils$b.zero8 = zero8;

    function join32(msg, start, end, endian) {
      var len = end - start;
      assert$4(len % 4 === 0);
      var res = new Array(len / 4);

      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }

      return res;
    }

    utils$b.join32 = join32;

    function split32(msg, endian) {
      var res = new Array(msg.length * 4);

      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];

        if (endian === 'big') {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 0xff;
          res[k + 2] = m >>> 8 & 0xff;
          res[k + 3] = m & 0xff;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 0xff;
          res[k + 1] = m >>> 8 & 0xff;
          res[k] = m & 0xff;
        }
      }

      return res;
    }

    utils$b.split32 = split32;

    function rotr32$1(w, b) {
      return w >>> b | w << 32 - b;
    }

    utils$b.rotr32 = rotr32$1;

    function rotl32$2(w, b) {
      return w << b | w >>> 32 - b;
    }

    utils$b.rotl32 = rotl32$2;

    function sum32$3(a, b) {
      return a + b >>> 0;
    }

    utils$b.sum32 = sum32$3;

    function sum32_3$1(a, b, c) {
      return a + b + c >>> 0;
    }

    utils$b.sum32_3 = sum32_3$1;

    function sum32_4$2(a, b, c, d) {
      return a + b + c + d >>> 0;
    }

    utils$b.sum32_4 = sum32_4$2;

    function sum32_5$2(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }

    utils$b.sum32_5 = sum32_5$2;

    function sum64$1(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }

    utils$b.sum64 = sum64$1;

    function sum64_hi$1(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }

    utils$b.sum64_hi = sum64_hi$1;

    function sum64_lo$1(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }

    utils$b.sum64_lo = sum64_lo$1;

    function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }

    utils$b.sum64_4_hi = sum64_4_hi$1;

    function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }

    utils$b.sum64_4_lo = sum64_4_lo$1;

    function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }

    utils$b.sum64_5_hi = sum64_5_hi$1;

    function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }

    utils$b.sum64_5_lo = sum64_5_lo$1;

    function rotr64_hi$1(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }

    utils$b.rotr64_hi = rotr64_hi$1;

    function rotr64_lo$1(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }

    utils$b.rotr64_lo = rotr64_lo$1;

    function shr64_hi$1(ah, al, num) {
      return ah >>> num;
    }

    utils$b.shr64_hi = shr64_hi$1;

    function shr64_lo$1(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }

    utils$b.shr64_lo = shr64_lo$1;

    var common$5 = {};

    var utils$a = utils$b;

    var assert$3 = minimalisticAssert;

    function BlockHash$4() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = 'big';
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }

    common$5.BlockHash = BlockHash$4;

    BlockHash$4.prototype.update = function update(msg, enc) {
      // Convert message to array, pad it, and join into 32bit blocks
      msg = utils$a.toArray(msg, enc);
      if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length; // Enough data, try updating

      if (this.pending.length >= this._delta8) {
        msg = this.pending; // Process pending data in blocks

        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils$a.join32(msg, 0, msg.length - r, this.endian);

        for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
      }

      return this;
    };

    BlockHash$4.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert$3(this.pending === null);
      return this._digest(enc);
    };

    BlockHash$4.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 0x80;

      for (var i = 1; i < k; i++) res[i] = 0; // Append length


      len <<= 3;

      if (this.endian === 'big') {
        for (var t = 8; t < this.padLength; t++) res[i++] = 0;

        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
      } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;

        for (t = 8; t < this.padLength; t++) res[i++] = 0;
      }

      return res;
    };

    var sha = {};

    var common$4 = {};

    var utils$9 = utils$b;

    var rotr32 = utils$9.rotr32;

    function ft_1$1(s, x, y, z) {
      if (s === 0) return ch32$1(x, y, z);
      if (s === 1 || s === 3) return p32(x, y, z);
      if (s === 2) return maj32$1(x, y, z);
    }

    common$4.ft_1 = ft_1$1;

    function ch32$1(x, y, z) {
      return x & y ^ ~x & z;
    }

    common$4.ch32 = ch32$1;

    function maj32$1(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }

    common$4.maj32 = maj32$1;

    function p32(x, y, z) {
      return x ^ y ^ z;
    }

    common$4.p32 = p32;

    function s0_256$1(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }

    common$4.s0_256 = s0_256$1;

    function s1_256$1(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }

    common$4.s1_256 = s1_256$1;

    function g0_256$1(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }

    common$4.g0_256 = g0_256$1;

    function g1_256$1(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }

    common$4.g1_256 = g1_256$1;

    var utils$8 = utils$b;

    var common$3 = common$5;

    var shaCommon$1 = common$4;

    var rotl32$1 = utils$8.rotl32;
    var sum32$2 = utils$8.sum32;
    var sum32_5$1 = utils$8.sum32_5;
    var ft_1 = shaCommon$1.ft_1;
    var BlockHash$3 = common$3.BlockHash;
    var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];

    function SHA1() {
      if (!(this instanceof SHA1)) return new SHA1();
      BlockHash$3.call(this);
      this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
      this.W = new Array(80);
    }

    utils$8.inherits(SHA1, BlockHash$3);
    var _1 = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;

    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;

      for (var i = 0; i < 16; i++) W[i] = msg[start + i];

      for (; i < W.length; i++) W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];

      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32$1(b, 30);
        b = a;
        a = t;
      }

      this.h[0] = sum32$2(this.h[0], a);
      this.h[1] = sum32$2(this.h[1], b);
      this.h[2] = sum32$2(this.h[2], c);
      this.h[3] = sum32$2(this.h[3], d);
      this.h[4] = sum32$2(this.h[4], e);
    };

    SHA1.prototype._digest = function digest(enc) {
      if (enc === 'hex') return utils$8.toHex32(this.h, 'big');else return utils$8.split32(this.h, 'big');
    };

    var utils$7 = utils$b;

    var common$2 = common$5;

    var shaCommon = common$4;

    var assert$2 = minimalisticAssert;

    var sum32$1 = utils$7.sum32;
    var sum32_4$1 = utils$7.sum32_4;
    var sum32_5 = utils$7.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash$2 = common$2.BlockHash;
    var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

    function SHA256$1() {
      if (!(this instanceof SHA256$1)) return new SHA256$1();
      BlockHash$2.call(this);
      this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
      this.k = sha256_K;
      this.W = new Array(64);
    }

    utils$7.inherits(SHA256$1, BlockHash$2);
    var _256 = SHA256$1;
    SHA256$1.blockSize = 512;
    SHA256$1.outSize = 256;
    SHA256$1.hmacStrength = 192;
    SHA256$1.padLength = 64;

    SHA256$1.prototype._update = function _update(msg, start) {
      var W = this.W;

      for (var i = 0; i < 16; i++) W[i] = msg[start + i];

      for (; i < W.length; i++) W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert$2(this.k.length === W.length);

      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32$1(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32$1(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32$1(T1, T2);
      }

      this.h[0] = sum32$1(this.h[0], a);
      this.h[1] = sum32$1(this.h[1], b);
      this.h[2] = sum32$1(this.h[2], c);
      this.h[3] = sum32$1(this.h[3], d);
      this.h[4] = sum32$1(this.h[4], e);
      this.h[5] = sum32$1(this.h[5], f);
      this.h[6] = sum32$1(this.h[6], g);
      this.h[7] = sum32$1(this.h[7], h);
    };

    SHA256$1.prototype._digest = function digest(enc) {
      if (enc === 'hex') return utils$7.toHex32(this.h, 'big');else return utils$7.split32(this.h, 'big');
    };

    var utils$6 = utils$b;

    var SHA256 = _256;

    function SHA224() {
      if (!(this instanceof SHA224)) return new SHA224();
      SHA256.call(this);
      this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
    }

    utils$6.inherits(SHA224, SHA256);
    var _224 = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;

    SHA224.prototype._digest = function digest(enc) {
      // Just truncate output
      if (enc === 'hex') return utils$6.toHex32(this.h.slice(0, 7), 'big');else return utils$6.split32(this.h.slice(0, 7), 'big');
    };

    var utils$5 = utils$b;

    var common$1 = common$5;

    var assert$1 = minimalisticAssert;

    var rotr64_hi = utils$5.rotr64_hi;
    var rotr64_lo = utils$5.rotr64_lo;
    var shr64_hi = utils$5.shr64_hi;
    var shr64_lo = utils$5.shr64_lo;
    var sum64 = utils$5.sum64;
    var sum64_hi = utils$5.sum64_hi;
    var sum64_lo = utils$5.sum64_lo;
    var sum64_4_hi = utils$5.sum64_4_hi;
    var sum64_4_lo = utils$5.sum64_4_lo;
    var sum64_5_hi = utils$5.sum64_5_hi;
    var sum64_5_lo = utils$5.sum64_5_lo;
    var BlockHash$1 = common$1.BlockHash;
    var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

    function SHA512$1() {
      if (!(this instanceof SHA512$1)) return new SHA512$1();
      BlockHash$1.call(this);
      this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
      this.k = sha512_K;
      this.W = new Array(160);
    }

    utils$5.inherits(SHA512$1, BlockHash$1);
    var _512 = SHA512$1;
    SHA512$1.blockSize = 1024;
    SHA512$1.outSize = 512;
    SHA512$1.hmacStrength = 192;
    SHA512$1.padLength = 128;

    SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W; // 32 x 32bit words

      for (var i = 0; i < 32; i++) W[i] = msg[start + i];

      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2

        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7

        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15

        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16

        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };

    SHA512$1.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);

      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert$1(this.k.length === W.length);

      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }

      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };

    SHA512$1.prototype._digest = function digest(enc) {
      if (enc === 'hex') return utils$5.toHex32(this.h, 'big');else return utils$5.split32(this.h, 'big');
    };

    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2); // 34

      var c2_hi = rotr64_hi(xl, xh, 7); // 39

      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2); // 34

      var c2_lo = rotr64_lo(xl, xh, 7); // 39

      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9); // 41

      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9); // 41

      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29); // 61

      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0) r += 0x100000000;
      return r;
    }

    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29); // 61

      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0) r += 0x100000000;
      return r;
    }

    var utils$4 = utils$b;

    var SHA512 = _512;

    function SHA384() {
      if (!(this instanceof SHA384)) return new SHA384();
      SHA512.call(this);
      this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
    }

    utils$4.inherits(SHA384, SHA512);
    var _384 = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;

    SHA384.prototype._digest = function digest(enc) {
      if (enc === 'hex') return utils$4.toHex32(this.h.slice(0, 12), 'big');else return utils$4.split32(this.h.slice(0, 12), 'big');
    };

    sha.sha1 = _1;
    sha.sha224 = _224;
    sha.sha256 = _256;
    sha.sha384 = _384;
    sha.sha512 = _512;

    var ripemd = {};

    var utils$3 = utils$b;

    var common = common$5;

    var rotl32 = utils$3.rotl32;
    var sum32 = utils$3.sum32;
    var sum32_3 = utils$3.sum32_3;
    var sum32_4 = utils$3.sum32_4;
    var BlockHash = common.BlockHash;

    function RIPEMD160() {
      if (!(this instanceof RIPEMD160)) return new RIPEMD160();
      BlockHash.call(this);
      this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
      this.endian = 'little';
    }

    utils$3.inherits(RIPEMD160, BlockHash);
    ripemd.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;

    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;

      for (var j = 0; j < 80; j++) {
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }

      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };

    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === 'hex') return utils$3.toHex32(this.h, 'little');else return utils$3.split32(this.h, 'little');
    };

    function f(j, x, y, z) {
      if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
    }

    function K(j) {
      if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
    }

    function Kh(j) {
      if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
    }

    var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

    var utils$2 = utils$b;

    var assert = minimalisticAssert;

    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;

      this._init(utils$2.toArray(key, enc));
    }

    var hmac = Hmac;

    Hmac.prototype._init = function init(key) {
      // Shorten key, if needed
      if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize); // Add padding to key

      for (var i = key.length; i < this.blockSize; i++) key.push(0);

      for (i = 0; i < key.length; i++) key[i] ^= 0x36;

      this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a

      for (i = 0; i < key.length; i++) key[i] ^= 0x6a;

      this.outer = new this.Hash().update(key);
    };

    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };

    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };

    (function (exports) {
    var hash = exports;
    hash.utils = utils$b;
    hash.common = common$5;
    hash.sha = sha;
    hash.ripemd = ripemd;
    hash.hmac = hmac; // Proxy hash functions to the main object

    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
    }(hash$1));

    window.Buffer = buffer.Buffer;

    function addressToSPK(address) {
      if (address.startsWith('bc1')) {
        const result = lib.BitcoinAddress.decode(address);
        let prefix;
        if (result.scriptVersion == 1) prefix = '5120'; // taproot (OP_PUSHNUM_1 OP_PUSHBYTES_32)
        else if (address.length == 62) prefix = '0020'; // p2wsh (OP_0 OP_PUSHBYTES_32)
        else prefix = '0014'; // p2wpkh (OP_0 OP_PUSHBYTES_20)

        return prefix + buffer.Buffer.from(result.data).toString('hex');
      } else {
        const result = base58_to_binary_1(address);
        let prefix, postfix;

        if (address.charAt(0) === '1') {
          prefix = '76a914'; // p2pkh (OP_DUP OP_HASH160 OP_PUSHBYTES_20)

          postfix = '88ac'; // p2pkh (OP_EQUALVERIFY OP_CHECKSIG)
        } else {
          prefix = 'a914'; // p2sh (OP_HASH160 OP_PUSHBYTES_20)

          postfix = '87'; // p2sh (OP_EQUAL)
        }

        return prefix + buffer.Buffer.from(result).toString('hex').slice(2, -8) + postfix;
      }
    } // Extract an address from a raw scriptpubkey

    function SPKToAddress(spk) {
      if (spk.startsWith('5120')) {
        // taproot
        return new lib.BitcoinAddress('bc', 1, hexToUintArray(spk.slice(4))).encode();
      } else if (spk.startsWith('0020') || spk.startsWith('0014')) {
        // p2wsh or p2wpkh
        return new lib.BitcoinAddress('bc', 0, hexToUintArray(spk.slice(4))).encode();
      } else if (spk.startsWith('76a914')) {
        // p2pkh
        const payload = "00" + spk.slice(6, -4);
        const checksum = hash(hash(payload)).slice(0, 8);
        return binary_to_base58_1(hexToUintArray(payload + checksum));
      } else if (spk.startsWith('a914')) {
        // p2sh
        const payload = "05" + spk.slice(4, -2);
        const checksum = hash(hash(payload)).slice(0, 8);
        return binary_to_base58_1(hexToUintArray(payload + checksum));
      } else if (spk.startsWith('6a')) {
        // OP_RETURN
        return 'OP_RETURN';
      } else if (spk.length == 134 && spk.startsWith('41') && spk.endsWith('ac')) {
        // uncompressed p2pk
        return 'P2PK';
      } else if (spk.length == 70 && spk.startsWith('21') && spk.endsWith('ac')) {
        // compressed p2pk
        return 'P2PK';
      } else if (spk.endsWith('51ae') && spk.startsWith('51')) {
        // possible p2ms (raw multisig)
        return '1-of-1 P2MS';
      } else if (spk.endsWith('52ae')) {
        // possible p2ms (raw multisig)
        if (spk.startsWith(51)) return '1-of-2 P2MS';
        if (spk.startsWith(52)) return '2-of-2 P2MS';
      } else if (spk.endsWith('53ae')) {
        // possible p2ms (raw multisig)
        if (spk.startsWith(51)) return '1-of-3 P2MS';
        if (spk.startsWith(52)) return '2-of-3 P2MS';
        if (spk.startsWith(53)) return '3-of-3 P2MS';
      }
    }

    function hexToUintArray(hex) {
      let a = new Uint8Array(hex.length / 2);

      for (let i = 0; i < a.length; i++) {
        a[i] = parseInt(hex.substr(2 * i, 2), 16);
      }

      return a;
    }

    function hash(hex) {
      return hash$1.sha256().update(hexToUintArray(hex)).digest('hex');
    }

    // ***does not validate that a given address/txid/block is valid***

    function matchQuery(query) {
      if (!query || !query.length) return;
      const q = query.toLowerCase(); // Looks like a block height?

      const asInt = parseInt(q); // Remember to update the bounds in

      if (!isNaN(asInt) && asInt >= 0 && `${asInt}` === q) {
        return {
          query: 'blockheight',
          label: 'block height',
          height: asInt,
          value: asInt
        };
      } // Looks like a block hash?


      if (/^0{8}[a-f0-9]{56}$/.test(q)) {
        return {
          query: 'blockhash',
          label: 'block hash',
          hash: query,
          value: query
        };
      } // Looks like a transaction input?


      if (/^[0-9]+:[a-f0-9]{64}$/.test(q)) {
        const parts = q.split(':');
        return {
          query: 'input',
          label: 'transaction input',
          txid: parts[1],
          output: parts[0],
          value: q
        };
      } // Looks like a transaction output?


      if (/^[a-f0-9]{64}:[0-9]+$/.test(q)) {
        const parts = q.split(':');
        return {
          query: 'output',
          label: 'transaction output',
          txid: parts[0],
          output: parts[1],
          value: q
        };
      } // Looks like a transaction id?


      if (/^[a-f0-9]{64}$/.test(q)) {
        return {
          query: 'txid',
          label: 'transaction',
          txid: q,
          value: q
        };
      } // Looks like an address


      if (q.length >= 26 && q.length <= 34 || q.length === 42 || q.length === 62) {
        // Looks like a legacy address
        if (/^[13]\w{24,33}$/.test(q)) {
          let addressType;
          if (q[0] === '1') addressType = 'p2pkh';else if (q[0] === '3') addressType = 'p2sh';else return null;
          return {
            query: 'address',
            label: 'address',
            encoding: 'base58',
            addressType,
            address: query,
            value: query,
            scriptPubKey: addressToSPK(query)
          };
        } // Looks like a bech32 address


        if (/^bc1\w{39}(\w{20})?$/.test(q)) {
          let addressType;

          if (q.startsWith('bc1q')) {
            if (q.length === 42) addressType = 'p2wpkh';else if (q.length === 62) addressType = 'p2wsh';else return null;
          } else if (q.startsWith('bc1p') && q.length === 62) {
            addressType = 'p2tr';
          } else return null;

          return {
            query: 'address',
            label: 'address',
            encoding: 'bech32',
            addressType,
            address: query,
            value: query,
            scriptPubKey: addressToSPK(query)
          };
        }
      }

      return null;
    }
    let currentBlockVal;
    currentBlock.subscribe(block => {
      currentBlockVal = block;
    });

    async function fetchTx(txid) {
      if (!txid) return;
      const response = await fetch(`${api.uri}/api/tx/${txid}`, {
        method: 'GET'
      });
      if (!response) throw new Error('null response');

      if (response.status == 200) {
        const result = await response.json();
        const txData = result.tx;

        if (result.blockheight != null && result.blockhash != null) {
          txData.block = {
            height: result.blockheight,
            hash: result.blockhash,
            time: result.time * 1000
          };
        }

        return new BitcoinTx(txData, null, txData.inputs && txData.inputs[0] && txData.inputs[0].prev_txid === "0000000000000000000000000000000000000000000000000000000000000000");
      } else {
        throw new Error(response.status);
      }
    }

    async function fetchBlockByHash(hash) {
      if (!hash || currentBlockVal && hash === currentBlockVal.id) return true; // try to fetch static block

      console.log('downloading block', hash);
      let response = await fetch(`${api.uri}/api/block/${hash}`, {
        method: 'GET'
      });

      if (!response) {
        console.log('failed to download block', hash);
        throw new Error('null response');
      }

      if (response && response.status == 200) {
        const blockData = await response.json();
        let block;

        if (blockData) {
          if (blockData.id) {
            block = new BitcoinBlock(blockData);
          } else block = new BitcoinBlock(BitcoinBlock.decompress(blockData));
        }

        if (block && block.id) {
          console.log('downloaded block', block.id);
        } else {
          console.log('failed to download block', block.id);
        }

        return block;
      }
    }

    async function fetchBlockByHeight(height) {
      if (height == null) return;
      const response = await fetch(`${api.uri}/api/block/height/${height}`, {
        method: 'GET'
      });
      if (!response) throw new Error('null response');

      if (response.status == 200) {
        const hash = await response.json();
        return fetchBlockByHash(hash);
      } else {
        throw new Error(response.status);
      }
    }

    async function fetchSpends(txid) {
      if (txid == null) return;
      const response = await fetch(`${api.uri}/api/spends/${txid}`, {
        method: 'GET'
      });
      if (!response) throw new Error('null response');

      if (response.status == 200) {
        const result = await response.json();
        return result.map(output => {
          if (output) {
            if (output === true) {
              return true;
            } else {
              return {
                txid: output[0],
                vin: output[1]
              };
            }
          } else {
            return null;
          }
        });
      } else {
        return null;
      }
    }
    async function searchTx(txid, input, output) {
      if (input != null) {
        urlPath.set(`/tx/${input}:${txid}`);
      } else if (output != null) {
        urlPath.set(`/tx/${txid}:${output}`);
      } else {
        urlPath.set(`/tx/${txid}`);
      }

      try {
        let searchResult = await fetchTx(txid);

        if (searchResult) {
          selectedTx.set(searchResult);
          detailTx.set(searchResult);
          overlay.set('tx');
          if (input != null || output != null) highlightInOut.set({
            txid,
            input,
            output
          });
          return null;
        } else {
          return '500';
        }
      } catch (err) {
        console.log('error fetching tx ', err);
        return err.message;
      }
    }
    async function searchBlockHash(hash) {
      urlPath.set(`/block/${hash}`);
      overlay.set(null);

      try {
        const searchResult = await fetchBlockByHash(hash);

        if (searchResult) {
          if (searchResult.id) {
            explorerBlock.set(searchResult);
          }

          return null;
        } else {
          return '500';
        }
      } catch (err) {
        console.log('error fetching block ', err);
        return err.message;
      }
    }
    async function searchBlockHeight(height) {
      urlPath.set(`/block/height/${height}`);
      overlay.set(null);

      try {
        const searchResult = await fetchBlockByHeight(height);

        if (searchResult) {
          if (searchResult.id) {
            explorerBlock.set(searchResult);
          }

          return null;
        } else {
          return '500';
        }
      } catch (err) {
        console.log('error fetching block ', err);
        return err.message;
      }
    }

    class TxController {
      constructor(_ref) {
        let {
          width,
          height
        } = _ref;
        this.vertexArray = new FastVertexArray(2048, TxSprite.dataSize, txCount);
        this.debugVertexArray = new FastVertexArray(1024, TxSprite.dataSize);
        this.txs = {};
        this.expiredTxs = {};
        this.poolScene = new TxMondrianPoolScene({
          width,
          height,
          controller: this,
          heightStore: mempoolScreenHeight
        });
        this.blockAreaSize = width <= 620 ? Math.min(window.innerWidth * 0.7, window.innerHeight / 2.75) : Math.min(window.innerWidth * 0.75, window.innerHeight / 2.5);
        blockAreaSize.set(this.blockAreaSize);
        this.blockScene = null;
        this.block = null;
        this.explorerBlockScene = null;
        this.explorerBlock = null;
        this.clearBlockTimeout = null;
        this.txDelay = 0; //config.txDelay

        this.maxTxDelay = config$1.txDelay;
        this.knownBlocks = {};
        this.selectedTx = null;
        this.selectionLocked = false;
        this.lastTxTime = 0;
        this.txDelay = 0;
        this.blocksEnabled = true;
        blocksEnabled.subscribe(enabled => {
          this.blocksEnabled = enabled;
        });
        detailTx.subscribe(tx => {
          this.onDetailTxChanged(tx);
        });
        highlight.subscribe(criteria => {
          this.highlightCriteria = criteria;
          this.applyHighlighting();
        });
        colorMode.subscribe(mode => {
          this.setColorMode(mode);
        });
        explorerBlock.subscribe(block => {
          if (block) {
            this.exploreBlock(block);
          } else {
            this.resumeLatest();
          }
        });
      }

      getVertexData() {
        return this.vertexArray.getVertexData();
      }

      getDebugVertexData() {
        return this.debugVertexArray.getVertexData();
      }

      getScenes() {
        if (this.blockScene && this.explorerBlockScene) return [this.poolScene, this.blockScene, this.explorerBlockScene];else if (this.blockScene) return [this.poolScene, this.blockScene];else return [this.poolScene];
      }

      redoLayout(_ref2) {
        let {
          width,
          height
        } = _ref2;
        this.poolScene.layoutAll({
          width,
          height
        });

        if (this.blockScene) {
          this.blockScene.layoutAll({
            width: this.blockAreaSize,
            height: this.blockAreaSize
          });
        }

        if (this.explorerBlockScene) {
          this.explorerBlockScene.layoutAll({
            width: this.blockAreaSize,
            height: this.blockAreaSize
          });
        }
      }

      resize(_ref3) {
        let {
          width,
          height
        } = _ref3;
        this.blockAreaSize = width <= 620 ? Math.min(window.innerWidth * 0.7, window.innerHeight / 2.75) : Math.min(window.innerWidth * 0.75, window.innerHeight / 2.5);
        blockAreaSize.set(this.blockAreaSize);
        this.redoLayout({
          width,
          height
        });
      }

      setColorMode(mode) {
        this.colorMode = mode;
        this.poolScene.setColorMode(mode);

        if (this.blockScene) {
          this.blockScene.setColorMode(mode);
        }

        if (this.explorerBlockScene) {
          this.explorerBlockScene.setColorMode(mode);
        }
      }

      applyHighlighting() {
        this.poolScene.applyHighlighting(this.highlightCriteria);

        if (this.blockScene) {
          this.blockScene.applyHighlighting(this.highlightCriteria);
        }

        if (this.explorerBlockScene) {
          this.explorerBlockScene.applyHighlighting(this.highlightCriteria);
        }
      }

      addTx(txData) {
        const tx = new BitcoinTx(txData, this.vertexArray);
        tx.applyHighlighting(this.highlightCriteria);

        if (!this.txs[tx.id] && !this.expiredTxs[tx.id]) {
          // smooth near-simultaneous arrivals over up to three seconds
          const dx = performance.now() - this.lastTxTime;
          this.lastTxTime = performance.now();

          if (dx <= 250) {
            this.txDelay = Math.min(3000, this.txDelay + Math.random() * 250);
          } else {
            this.txDelay = Math.max(0, this.txDelay - (dx - 250));
          }

          this.txs[tx.id] = tx;
          tx.onEnterScene();
          this.poolScene.insert(this.txs[tx.id], this.txDelay);
        }
      }

      dropTx(txid) {
        if (this.txs[txid] && this.poolScene.drop(txid)) {
          this.txs[txid].view.update({
            display: {
              position: {
                y: -100 //this.txs[txid].screenPosition.y - 100

              } // color: {
              //   alpha: 0
              // }

            },
            delay: 0,
            duration: 2000
          });
          setTimeout(() => {
            this.destroyTx(txid);
          }, 2000); // this.poolScene.layoutAll()
        }
      }

      simulateBlock() {
        const time = Date.now() / 1000;
        console.log('sim time ', time);
        this.addBlock({
          version: 'fake',
          id: Math.random(),
          value: 10000,
          prev_block: 'also_fake',
          merkle_root: 'merkle',
          timestamp: time,
          bits: 'none',
          txn_count: 20,
          fees: 100,
          txns: [{
            version: 'fake',
            inflated: false,
            id: 'coinbase',
            value: 625000100,
            fee: 100,
            vbytes: 500,
            inputs: [{
              prev_txid: '00000000000000000000000000000',
              prev_vout: 0,
              script_sig: '03e0170b04efb72c622f466f756e6472792055534120506f6f6c202364726f70676f6c642f0eb5059f0000000000000000',
              sequence_no: 0,
              value: 625000100,
              script_pub_key: "76a9145e9b23809261178723055968d134a947f47e799f88ac"
            }],
            outputs: [{
              prev_txid: '00000000000000000000000000000',
              prev_vout: 0,
              script_sig: '03e0170b04efb72c622f466f756e6472792055534120506f6f6c202364726f70676f6c642f0eb5059f0000000000000000',
              sequence_no: 0,
              value: 625000100,
              script_pub_key: "76a9145e9b23809261178723055968d134a947f47e799f88ac"
            }],
            time: Date.now()
          }, ...Object.keys(this.txs).filter(() => {
            return Math.random() < 0.5;
          }).map(key => {
            return { ...this.txs[key],
              inputs: this.txs[key].inputs ? this.txs[key].inputs.map(input => {
                return { ...input,
                  script_pub_key: null,
                  value: null
                };
              }) : []
            };
          })]
        });
      }

      addBlock(block) {

        // discard duplicate blocks
        if (!block || !block.id || this.knownBlocks[block.id]) {
          return;
        }

        latestBlockHeight.set(block.height); // this.knownBlocks[block.id] = true

        if (this.clearBlockTimeout) clearTimeout(this.clearBlockTimeout);
        this.expiredTxs = {};

        if (this.explorerBlockScene && this.explorerBlock && this.explorerBlock.id === block.id) {
          this.block = this.explorerBlock;
          this.blockScene = this.explorerBlockScene;
          this.explorerBlockScene = null;
          this.explorerBlock = null;
          urlPath.set("/");

          for (let i = 0; i < block.txns.length; i++) {
            this.txs[block.txns[i].id].setData(block.txns[i]);
            this.poolScene.remove(block.txns[i].id);
          }

          this.poolScene.layoutAll();
          return;
        }

        if (!this.explorerBlockScene) this.clearBlock();
        this.poolScene.scrollLock = true;

        if (this.blocksEnabled) {
          this.blockScene = new TxBlockScene({
            width: this.blockAreaSize,
            height: this.blockAreaSize,
            blockId: block.id,
            controller: this,
            colorMode: this.colorMode
          });
          let knownCount = 0;
          let unknownCount = 0;

          for (let i = 0; i < block.txns.length; i++) {
            if (this.poolScene.remove(block.txns[i].id)) {
              knownCount++;
              this.txs[block.txns[i].id].mergeData(block.txns[i]);
              this.txs[block.txns[i].id].setBlock(block);
              this.blockScene.insert(this.txs[block.txns[i].id], 0, false);
            } else {
              unknownCount++;
              const tx = new BitcoinTx({ ...block.txns[i],
                block: block
              }, this.vertexArray);
              this.txs[tx.id] = tx;
              this.txs[tx.id].applyHighlighting(this.highlightCriteria);
              this.blockScene.insert(tx, 0, false);
            }

            this.expiredTxs[block.txns[i].id] = true;
          }

          console.log(`New block with ${knownCount} known transactions and ${unknownCount} unknown transactions`);
          this.blockScene.initialLayout(!!this.explorerBlockScene);
          setTimeout(() => {
            this.poolScene.scrollLock = false;
            this.poolScene.layoutAll();
          }, 4000);
          blockVisible.set(true);

          if (!this.explorerBlockScene) {
            currentBlock.set(block);
          }
        } else {
          for (let i = 0; i < block.txns.length; i++) {
            if (this.txs[block.txns[i].id] && this.txs[block.txns[i].id].view) {
              this.txs[block.txns[i].id].view.update({
                display: {
                  color: this.txs[block.txns[i].id].getColor('block', 'age').color
                },
                duration: 1000,
                delay: 0,
                jitter: 0
              });
            }

            this.expiredTxs[block.txns[i].id] = true;
          }

          setTimeout(() => {
            for (let i = 0; i < block.txns.length; i++) {
              if (this.txs[block.txns[i].id] && this.txs[block.txns[i].id].view) {
                this.txs[block.txns[i].id].view.update({
                  display: {
                    position: {
                      y: window.innerHeight + 50,
                      r: 10
                    },
                    color: {
                      alpha: 0
                    }
                  },
                  duration: 3000,
                  delay: 0,
                  jitter: 1000
                });
              }

              this.expiredTxs[block.txns[i].id] = true;
            }
          }, 1500);
          setTimeout(() => {
            for (let i = 0; i < block.txns.length; i++) {
              this.poolScene.remove(block.txns[i].id);
            }

            this.poolScene.scrollLock = false;
            this.poolScene.layoutAll();
          }, 5500);
          currentBlock.set(block);
        }

        this.block = block;
        return block;
      }

      async exploreBlock(block) {
        if (this.block && this.block.id === block.id) {
          this.showBlock();
          return;
        }

        let enterFromRight = false; // clean up previous block

        if (this.explorerBlock && this.explorerBlockScene) {
          const prevBlock = this.explorerBlock;
          const prevBlockScene = this.explorerBlockScene;

          if (prevBlock.height < block.height) {
            prevBlockScene.exitLeft();
            enterFromRight = true;
          } else prevBlockScene.exitRight();

          prevBlockScene.expire(3000);
        } else if (this.blockScene) {
          this.blockScene.exitRight();
        }

        this.explorerBlock = block;

        if (this.blocksEnabled) {
          this.explorerBlockScene = new TxBlockScene({
            width: this.blockAreaSize,
            height: this.blockAreaSize,
            blockId: block.id,
            controller: this,
            colorMode: this.colorMode
          });

          for (let i = 0; i < block.txns.length; i++) {
            const tx = new BitcoinTx({ ...block.txns[i],
              block: block
            }, this.vertexArray);
            this.txs[tx.id] = tx;
            this.txs[tx.id].applyHighlighting(this.highlightCriteria);
            this.explorerBlockScene.insert(tx, 0, false);
          }

          this.explorerBlockScene.prepareAll();
          this.explorerBlockScene.layoutAll();

          if (enterFromRight) {
            blockTransitionDirection.set('right');
            this.explorerBlockScene.enterRight();
          } else {
            blockTransitionDirection.set('left');
            this.explorerBlockScene.enterLeft();
          }
        }

        blockVisible.set(true);
        await tick();
        currentBlock.set(block);
      }

      async resumeLatest() {
        if (this.explorerBlock && this.explorerBlockScene) {
          this.explorerBlock;
          const prevBlockScene = this.explorerBlockScene;
          prevBlockScene.exitLeft();
          prevBlockScene.expire(3000);
          this.explorerBlockScene = null;
          this.explorerBlock = null;
          urlPath.set("/");
        }

        if (this.blockScene && this.block) {
          blockTransitionDirection.set('right');
          await tick();
          this.blockScene.enterRight();
          currentBlock.set(this.block);
        }
      }

      async hideBlock() {
        if (this.blockScene && !this.explorerBlockScene) {
          blockTransitionDirection.set(null);
          await tick();
          this.blockScene.hide();
        }
      }

      showBlock() {
        if (this.blockScene && !this.explorerBlockScene) {
          this.blockScene.show();
        }
      }

      clearBlock() {
        if (this.blockScene) {
          this.blockScene.exitLeft();
          this.blockScene.expire();
        }

        this.block = null;
        currentBlock.set(null);
      }

      destroyTx(id) {
        this.getScenes().forEach(scene => {
          scene.remove(id);
        });
        if (this.txs[id]) this.txs[id].destroy();
        this.deleteTx(id);
      }

      deleteTx(id) {
        delete this.txs[id];
      }

      mouseMove(position) {
        if (this.poolScene && !this.selectionLocked) {
          let selected = this.poolScene.selectAt(position);
          if (!selected && this.blockScene && !this.explorerBlock && !this.blockScene.hidden) selected = this.blockScene.selectAt(position);
          if (!selected && this.explorerBlockScene && this.explorerBlock && !this.explorerBlockScene.hidden) selected = this.explorerBlockScene.selectAt(position);

          if (selected !== this.selectedTx) {
            if (this.selectedTx) this.selectedTx.hoverOff();
            if (selected) selected.hoverOn();
          }

          this.selectedTx = selected;
          selectedTx.set(this.selectedTx);
        }
      }

      async mouseClick(position) {
        if (this.poolScene) {
          let selected = this.poolScene.selectAt(position);
          if (!selected && this.blockScene && !this.explorerBlock && !this.blockScene.hidden) selected = this.blockScene.selectAt(position);
          if (!selected && this.explorerBlockScene && this.explorerBlock && !this.explorerBlockScene.hidden) selected = this.explorerBlockScene.selectAt(position);
          let sameTx = true;

          if (selected !== this.selectedTx) {
            sameTx = false;
            if (this.selectedTx) this.selectedTx.hoverOff();
            if (selected) selected.hoverOn();
          }

          this.selectedTx = selected;
          selectedTx.set(selected);

          if (sameTx && selected) {
            if (!selected.is_inflated || selected.is_partial) {
              loading.increment();
              await searchTx(selected.id);
              loading.decrement();
            } else {
              urlPath.set(`/tx/${selected.id}`);
              detailTx.set(selected);
              overlay.set('tx');
            }

            console.log(selected);
          }

          this.selectionLocked = !!selected && !(this.selectionLocked && sameTx);
        }
      }

      onDetailTxChanged(tx) {
        if (!tx) {
          if (this.selectedTx) {
            this.selectedTx.hoverOff();
            this.selectedTx = null;
          }

          selectedTx.set(null);
          this.selectionLocked = false;
        }

        selectedTx.set(null);
      }

    }

    var vertShaderSrc = "#define GLSLIFY 1\nvarying lowp vec4 vColor;attribute vec2 offset;attribute vec4 posX;attribute vec4 posY;attribute vec4 posR;attribute vec4 hues;attribute vec4 lights;attribute vec4 alphas;uniform vec2 screenSize;uniform float now;uniform sampler2D colorTexture;float interpolate(float x,bool useSmooth,bool boomerang){x=clamp(x,0.0,1.0);if(boomerang){x=2.0*x;if(x>1.0){x=2.0-x;}}if(useSmooth){float ix=1.0-x;x=x*x;return x/(x+ix*ix);}else{return x;}}float interpolateHue(vec4 hue){bool useSmooth=false;bool boomerang=false;if(hue.w<=-20.0){boomerang=true;useSmooth=true;hue.w=(0.0-hue.w)-20.0;}else if(hue.w<=-10.0){boomerang=true;hue.w=(0.0-hue.w)-10.0;}else if(hue.w<0.0){useSmooth=true;hue.w=-hue.w;}float d=clamp((now-hue.z)*hue.w,0.0,1.0);float delta=interpolate(d,useSmooth,boomerang);if(abs(hue.x-hue.y)>0.5){if(hue.x>0.5){return mod(mix(hue.x-1.0,hue.y,delta),1.0);}else{return mod(mix(hue.x,hue.y-1.0,delta),1.0);}}else{return mix(hue.x,hue.y,delta);}}float interpolateAttribute(vec4 attr){bool useSmooth=false;bool boomerang=false;if(attr.w<=-20.0){boomerang=true;useSmooth=true;attr.w=(0.0-attr.w)-20.0;}else if(attr.w<=-10.0){boomerang=true;attr.w=(0.0-attr.w)-10.0;}else if(attr.w<0.0){useSmooth=true;attr.w=-attr.w;}float d=clamp((now-attr.z)*attr.w,0.0,1.0);float delta=interpolate(d,useSmooth,boomerang);return mix(attr.x,attr.y,delta);}void main(){vec4 screenTransform=vec4(2.0/screenSize.x,2.0/screenSize.y,-1.0,-1.0);float radius=interpolateAttribute(posR);vec2 position=vec2(interpolateAttribute(posX),interpolateAttribute(posY))+(radius*offset);gl_Position=vec4(position*screenTransform.xy+screenTransform.zw,1.0,1.0);float hue=interpolateHue(hues);float light=interpolateAttribute(lights);float alpha=interpolateAttribute(alphas);vec4 texel=texture2D(colorTexture,vec2(light,hue));vColor=vec4(texel.rgb,alpha);}"; // eslint-disable-line

    var fragShaderSrc = "#define GLSLIFY 1\nvarying lowp vec4 vColor;void main(){gl_FragColor=vColor;gl_FragColor.rgb*=gl_FragColor.a;}"; // eslint-disable-line

    /* src/components/TxRender.svelte generated by Svelte v3.44.3 */
    const {
      Object: Object_1$4,
      console: console_1$3,
      window: window_1$2
    } = globals;
    const file$B = "src/components/TxRender.svelte";

    function create_fragment$D(ctx) {
      let canvas_1;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          canvas_1 = element("canvas");
          attr_dev(canvas_1, "class", "tx-scene svelte-1ta3g9x");
          attr_dev(canvas_1, "width",
          /*displayWidth*/
          ctx[1]);
          attr_dev(canvas_1, "height",
          /*displayHeight*/
          ctx[2]);
          set_style(canvas_1, "width",
          /*cssWidth*/
          ctx[3] + "px");
          set_style(canvas_1, "height",
          /*cssHeight*/
          ctx[4] + "px");
          add_location(canvas_1, file$B, 301, 0, 8675);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, canvas_1, anchor);
          /*canvas_1_binding*/

          ctx[9](canvas_1);

          if (!mounted) {
            dispose = [listen_dev(window_1$2, "resize",
            /*resizeCanvas*/
            ctx[6], false, false, false), listen_dev(window_1$2, "load",
            /*windowReady*/
            ctx[5], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*displayWidth*/
          2) {
            attr_dev(canvas_1, "width",
            /*displayWidth*/
            ctx[1]);
          }

          if (dirty[0] &
          /*displayHeight*/
          4) {
            attr_dev(canvas_1, "height",
            /*displayHeight*/
            ctx[2]);
          }

          if (dirty[0] &
          /*cssWidth*/
          8) {
            set_style(canvas_1, "width",
            /*cssWidth*/
            ctx[3] + "px");
          }

          if (dirty[0] &
          /*cssHeight*/
          16) {
            set_style(canvas_1, "height",
            /*cssHeight*/
            ctx[4] + "px");
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(canvas_1);
          /*canvas_1_binding*/

          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$D.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
      let $devSettings;
      validate_store(devSettings, 'devSettings');
      component_subscribe($$self, devSettings, $$value => $$invalidate(19, $devSettings = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('TxRender', slots, []);
      let canvas;
      let gl;
      let animationFrameRequest;
      let displayWidth;
      let displayHeight;
      let cssWidth;
      let cssHeight;
      let shaderProgram;
      let aspectRatio;
      let sceneScale = [1.0, 1.0];
      let pointArray;
      let debugPointArray;
      let lastTime = performance.now();
      const nullPointArray = new Float32Array();
      let {
        controller
      } = $$props;
      let {
        running = false
      } = $$props;
      let sizeFrozen;
      freezeResize.subscribe(val => {
        sizeFrozen = val;
      }); // Shader attributes
      // each attribute (except index) contains [x: startValue, y: endValue, z: startTime, w: rate]
      // shader interpolates between start and end values at the given rate, from the given time

      const attribs = {
        offset: {
          type: 'FLOAT',
          count: 2,
          pointer: null
        },
        posX: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        },
        posY: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        },
        posR: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        },
        hues: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        },
        lights: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        },
        alphas: {
          type: 'FLOAT',
          count: 4,
          pointer: null
        }
      }; // Auto-calculate the number of bytes per vertex based on specified attributes

      const stride = Object.values(attribs).reduce((total, attrib) => {
        return total + attrib.count * 4;
      }, 0); // Auto-calculate vertex attribute offsets

      for (let i = 0, offset = 0; i < Object.keys(attribs).length; i++) {
        let attrib = Object.values(attribs)[i];
        attrib.offset = offset;
        offset += attrib.count * 4;
      } // Color map texture


      let colorTexture;

      function windowReady() {
        resizeCanvas();
      }

      let resizeTimer;

      function resizeCanvas() {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = null; // var rect = canvas.parentNode.getBoundingClientRect()

        if (canvas && !sizeFrozen) {
          $$invalidate(3, cssWidth = window.innerWidth);
          $$invalidate(4, cssHeight = window.innerHeight);
          $$invalidate(1, displayWidth = cssWidth * window.devicePixelRatio);
          $$invalidate(2, displayHeight = cssHeight * window.devicePixelRatio);
          $$invalidate(0, canvas.width = displayWidth, canvas);
          $$invalidate(0, canvas.height = displayHeight, canvas);
          if (gl) gl.viewport(0, 0, displayWidth, displayHeight);
        } else {
          resizeTimer = setTimeout(resizeCanvas, 500);
        }
      }

      function getTxPointArray() {
        if (controller) {
          return controller.getVertexData();
        } else //   controller.getScenes().flatMap(scene => scene.getVertexData())
          // )
          return new Float32Array(); // return new Float32Array(

      }

      function getDebugTxPointArray() {
        if (controller && $devSettings.layoutHints) {
          return controller.getDebugVertexData();
        } else //   controller.getScenes().flatMap(scene => scene.getVertexData())
          // )
          return new Float32Array(); // return new Float32Array(

      }

      function compileShader(src, type) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.log(`Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`);
          console.log(gl.getShaderInfoLog(shader));
        }

        return shader;
      }

      function buildShaderProgram(shaderInfo) {
        let program = gl.createProgram();
        shaderInfo.forEach(function (desc) {
          let shader = compileShader(desc.src, desc.type);

          if (shader) {
            gl.attachShader(program, shader);
          }
        });
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.log("Error linking shader program:");
          console.log(gl.getProgramInfoLog(program));
        }

        return program;
      }

      function run(now) {
        if (!now) {
          now = performance.now();
        } // /* RESET DRAWING AREA */

        /* LOAD VERTEX DATA */


        pointArray = getTxPointArray();

        if (config$1.layoutHints) {
          debugPointArray = getDebugTxPointArray();
          const combinedArray = new Float32Array(pointArray.length + debugPointArray.length);
          combinedArray.set(pointArray, 0);
          combinedArray.set(debugPointArray, pointArray.length);
          pointArray = combinedArray;
        }
        /* SET UP SHADER UNIFORMS */
        // screen dimensions


        gl.uniform2f(gl.getUniformLocation(shaderProgram, 'screenSize'), cssWidth, cssHeight); // frame timestamp

        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'now'), now);
        gl.uniform1i(gl.getUniformLocation(shaderProgram, 'colorTexture'), 0);
        /* SET UP SHADER ATTRIBUTES */

        Object.keys(attribs).forEach((key, i) => {
          gl.vertexAttribPointer(attribs[key].pointer, attribs[key].count, gl[attribs[key].type], false, stride, attribs[key].offset); // number of primitives in this attribute
          // type of primitive in this attribute (e.g. gl.FLOAT)
          // never normalised
          // distance between values of the same attribute
          // offset of the first value
        });

        if (pointArray.length) {
          gl.bufferData(gl.ARRAY_BUFFER, pointArray, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, pointArray.length / TxSprite.vertexSize);
        }
        /* LOOP */


        if (running) {
          animationFrameRequest = requestAnimationFrame(run);
        }
      }

      function computeColorTextureData(width, height) {
        return [...Array(Math.floor(height)).keys()].flatMap(row => {
          return [...Array(width).keys()].flatMap(step => {
            let rgb = color(hcl$1(row / height * 360, 78.225, step / width * 150)).rgb();
            return [rgb.r, rgb.g, rgb.b, 255];
          });
        });
      } // Precomputes an 2d color texture projected from HCL space with chroma=78.225
      // transitions between points in this space are much more aesthetically pleasing than RGB interpolations


      function loadColorTexture(gl, width, height) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const colorData = computeColorTextureData(width, height);
        const level = 0;
        const internalFormat = gl.RGBA;
        const border = 0;
        const srcFormat = gl.RGBA;
        const srcType = gl.UNSIGNED_BYTE;
        const pixels = new Uint8Array(colorData);
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixels);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        return texture;
      }

      function initCanvas() {
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        const shaderSet = [{
          type: gl.VERTEX_SHADER,
          src: vertShaderSrc
        }, {
          type: gl.FRAGMENT_SHADER,
          src: fragShaderSrc
        }];
        shaderProgram = buildShaderProgram(shaderSet);
        gl.useProgram(shaderProgram); // Set up alpha blending

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        colorTexture = loadColorTexture(gl, 512, 512);
        const glBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
        /* SET UP SHADER UNIFORMS */
        // Color mapping textures

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
        /* SET UP SHADER ATTRIBUTES */

        Object.keys(attribs).forEach((key, i) => {
          attribs[key].pointer = gl.getAttribLocation(shaderProgram, key);
          gl.enableVertexAttribArray(attribs[key].pointer);
        });
        $$invalidate(7, running = true);
      }

      function handleContextLost(event) {
        console.log('webgl context lost');
        event.preventDefault();
        cancelAnimationFrame(animationFrameRequest);
        animationFrameRequest = null;
        $$invalidate(7, running = false);
      }

      function handleContextRestored(event) {
        console.log('webgl context restored');
        initCanvas();
        $$invalidate(7, running = true);
      }

      onMount(() => {
        canvas.addEventListener("webglcontextlost", handleContextLost, false);
        canvas.addEventListener("webglcontextrestored", handleContextRestored, false);
        gl = canvas.getContext('webgl');
        initCanvas();
      });
      const writable_props = ['controller', 'running'];
      Object_1$4.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<TxRender> was created with unknown prop '${key}'`);
      });

      function canvas_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          canvas = $$value;
          $$invalidate(0, canvas);
        });
      }

      $$self.$$set = $$props => {
        if ('controller' in $$props) $$invalidate(8, controller = $$props.controller);
        if ('running' in $$props) $$invalidate(7, running = $$props.running);
      };

      $$self.$capture_state = () => ({
        onMount,
        vertShaderSrc,
        fragShaderSrc,
        TxSprite,
        color,
        hcl: hcl$1,
        darkMode,
        settings,
        devSettings,
        freezeResize,
        config: config$1,
        canvas,
        gl,
        animationFrameRequest,
        displayWidth,
        displayHeight,
        cssWidth,
        cssHeight,
        shaderProgram,
        aspectRatio,
        sceneScale,
        pointArray,
        debugPointArray,
        lastTime,
        nullPointArray,
        controller,
        running,
        sizeFrozen,
        attribs,
        stride,
        colorTexture,
        windowReady,
        resizeTimer,
        resizeCanvas,
        getTxPointArray,
        getDebugTxPointArray,
        compileShader,
        buildShaderProgram,
        run,
        computeColorTextureData,
        loadColorTexture,
        initCanvas,
        handleContextLost,
        handleContextRestored,
        $devSettings
      });

      $$self.$inject_state = $$props => {
        if ('canvas' in $$props) $$invalidate(0, canvas = $$props.canvas);
        if ('gl' in $$props) gl = $$props.gl;
        if ('animationFrameRequest' in $$props) animationFrameRequest = $$props.animationFrameRequest;
        if ('displayWidth' in $$props) $$invalidate(1, displayWidth = $$props.displayWidth);
        if ('displayHeight' in $$props) $$invalidate(2, displayHeight = $$props.displayHeight);
        if ('cssWidth' in $$props) $$invalidate(3, cssWidth = $$props.cssWidth);
        if ('cssHeight' in $$props) $$invalidate(4, cssHeight = $$props.cssHeight);
        if ('shaderProgram' in $$props) shaderProgram = $$props.shaderProgram;
        if ('aspectRatio' in $$props) aspectRatio = $$props.aspectRatio;
        if ('sceneScale' in $$props) sceneScale = $$props.sceneScale;
        if ('pointArray' in $$props) pointArray = $$props.pointArray;
        if ('debugPointArray' in $$props) debugPointArray = $$props.debugPointArray;
        if ('lastTime' in $$props) lastTime = $$props.lastTime;
        if ('controller' in $$props) $$invalidate(8, controller = $$props.controller);
        if ('running' in $$props) $$invalidate(7, running = $$props.running);
        if ('sizeFrozen' in $$props) sizeFrozen = $$props.sizeFrozen;
        if ('colorTexture' in $$props) colorTexture = $$props.colorTexture;
        if ('resizeTimer' in $$props) resizeTimer = $$props.resizeTimer;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*running*/
        128) {
          // Computed
          {
            if (running) run();
          }
        }
      };

      return [canvas, displayWidth, displayHeight, cssWidth, cssHeight, windowReady, resizeCanvas, running, controller, canvas_1_binding];
    }

    class TxRender extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$D, create_fragment$D, safe_not_equal, {
          controller: 8,
          running: 7
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TxRender",
          options,
          id: create_fragment$D.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*controller*/
        ctx[8] === undefined && !('controller' in props)) {
          console_1$3.warn("<TxRender> was created without expected prop 'controller'");
        }
      }

      get controller() {
        throw new Error("<TxRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set controller(value) {
        throw new Error("<TxRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get running() {
        throw new Error("<TxRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set running(value) {
        throw new Error("<TxRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    let lastBlockSeen;
    lastBlockId.subscribe(val => {
      lastBlockSeen = val;
    });
    let latestBlockHeightVal;
    latestBlockHeight.subscribe(val => {
      latestBlockHeightVal = val;
    });

    class TxStream {
      constructor() {
        console.log('connecting to ', api.uri);
        this.reconnectBackoff = 250;
        this.websocket = null;
        this.setConnected(false);
        this.setDelay(0);
        this.lastBeat = performance.now();
        this.reconnectTimeout = null;
        this.heartbeatTimeout = null;
        this.delayInterval = setInterval(() => {
          if (this.lastBeat && this.connected) {
            this.setDelay(performance.now() - this.lastBeat);
          }
        }, 789);
        this.init();
      }

      setConnected(connected) {
        this.connected = connected;
        serverConnected.set(connected);
      }

      setDelay(delay) {
        this.delay = delay;
        serverDelay.set(delay);
      }

      init() {
        console.log('initialising websocket');

        if (!this.connected && (!this.websocket || this.websocket.readyState === WebSocket.CLOSED)) {
          if (this.websocket) this.disconnect();else {
            try {
              this.websocket = new WebSocket(api.websocketUri);

              this.websocket.onopen = evt => {
                this.onopen(evt);
              };

              this.websocket.onclose = evt => {
                this.onclose(evt);
              };

              this.websocket.onmessage = evt => {
                this.onmessage(evt);
              };

              this.websocket.onerror = evt => {
                this.onerror(evt);
              };
            } catch (error) {
              this.reconnect();
            }
          }
        } else this.reconnect();
      }

      reconnect() {
        if (this.reconnectBackoff) clearTimeout(this.reconnectBackoff);

        if (!this.connected) {
          console.log('......trying to reconnect websocket');
          if (this.reconnectBackoff < 8000) this.reconnectBackoff *= Math.random() + 1;
          this.reconnectTimeout = setTimeout(() => {
            this.init();
          }, this.reconnectBackoff);
        }
      }

      onHeartbeat() {
        if (this.heartbeatTimeout) clearTimeout(this.heartbeatTimeout);
        if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
        this.setDelay(performance.now() - this.lastBeat);
        this.lastBeat = null;
        this.setConnected(true);
        this.heartbeatTimeout = setTimeout(() => {
          this.sendHeartbeat();
        }, 5000);
      }

      sendHeartbeat() {
        if (this.heartbeatTimeout) clearTimeout(this.heartbeatTimeout);
        this.lastBeat = performance.now();

        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
          this.lastBeat = performance.now();
          this.websocket.send('hb');
          this.heartbeatTimeout = setTimeout(() => {
            this.setDelay(performance.now() - this.lastBeat);
          }, 5000);
        }
      }

      sendBlockRequest() {
        if (config$1.noBlockFeed) return;
        console.log('Checking for missed blocks...');
        this.websocket.send("block_id");
      }

      disconnect() {
        console.log('disconnecting websocket');

        if (this.websocket) {
          this.websocket.onopen = null;
          this.websocket.onclose = null;
          this.websocket.onmessage = null;
          this.websocket.onerror = null;
          this.websocket.close();
          this.websocket = null;
        }

        this.setConnected(false);
        this.setDelay(0);
        this.reconnect();
      }

      onopen(event) {
        console.log('websocket opened');
        this.setConnected(true);
        this.setDelay(0);
        this.reconnectBackoff = 128;
        this.sendHeartbeat();
        this.sendBlockRequest();
      }

      async fetchBlock(id, calledOnLoad) {
        if (!id) return;

        if (id !== lastBlockSeen) {
          const block = await fetchBlockByHash(id); // ignore this block if we've downloaded a newer one while we were waiting

          if (block.height >= latestBlockHeightVal) {
            window.dispatchEvent(new CustomEvent('bitcoin_block', {
              detail: {
                block,
                realtime: !calledOnLoad
              }
            }));
          }
        } else {
          console.log('already seen block ', lastBlockSeen);
        }
      }

      onmessage(event) {
        if (!event) return;

        if (event.data === 'hb') {
          this.onHeartbeat();
        } else if (event.data === 'error') ; else {
          try {
            const msg = JSON.parse(event.data);
            if (!msg) throw new Error('null websocket message');

            switch (msg.type) {
              // reply to a last block_id request message
              case 'block_id':
                this.fetchBlock(msg.block_id, true);
                break;
              // notification of tx added to mempool

              case 'txn':
                window.dispatchEvent(new CustomEvent('bitcoin_tx', {
                  detail: msg.txn
                }));
                break;
              // notification of tx dropped from mempool

              case 'drop':
                window.dispatchEvent(new CustomEvent('bitcoin_drop_tx', {
                  detail: msg.txid
                }));
                break;
              // notification of a new block

              case 'block':
                if (msg.block && msg.block.id) {
                  this.fetchBlock(msg.block.id);
                }

                break;
            } // all events can include a count field, with the latest mempool size


            if (msg.count) window.dispatchEvent(new CustomEvent('bitcoin_mempool_count', {
              detail: msg.count
            }));
          } catch (err) {
            console.log('error parsing msg json: ', err);
          }
        }
      }

      onerror(event) {
        console.log('websocket error: ', event);
      }

      onclose(event) {
        console.log('websocket closed');
        this.setConnected(false);
        this.reconnect();
      }

      dosend(message) {
        this.websocket.send(message);
      }

      close() {
        console.log('closing websocket');
        if (this.websocket) this.websocket.close();
      }

      subscribe(type, callback) {
        console.log(`subscribing to bitcoin ${type} events`);
        window.addEventListener('bitcoin_' + type, event => {
          callback(event.detail);
        });
      }

    }

    let txStream;
    function getTxStream() {
      if (!txStream) {
        txStream = new TxStream();
      }

      return txStream;
    }

    let analyticsEnabled = false;
    var analytics = {
      init: function () {
        analyticsEnabled = true;

        var _paq = window._paq = window._paq || [];
        /* tracker methods like "setCustomDimension" should be called before "trackPageView" */


        _paq.push(['trackPageView']);

        _paq.push(['enableLinkTracking']);

        _paq.push(['enableHeartBeatTimer']);

        (function () {
          var u = "//matomo.monospace.live/";

          _paq.push(['setTrackerUrl', u + 'matomo.php']);

          _paq.push(['setSiteId', config$1.dev ? '2' : '1']);

          var d = document,
              g = d.createElement('script'),
              s = d.getElementsByTagName('script')[0];
          g.type = 'text/javascript';
          g.async = true;
          g.src = u + 'matomo.js';
          s.parentNode.insertBefore(g, s);
        })();
      },
      trackEvent: function (category, action, name, value) {
        if (analyticsEnabled) {
          if (config$1.dev) console.log('tracking event: ', {
            category,
            action,
            name,
            value
          });

          if (_paq) {
            _paq.push(['trackEvent', category, action, name, value]);
          }
        }
      }
    };

    function fade(node) {
      let {
        delay = 0,
        duration = 400,
        easing = identity
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const o = +getComputedStyle(node).opacity;
      return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
      };
    }

    function fly(node) {
      let {
        delay = 0,
        duration = 400,
        easing = cubicOut,
        x = 0,
        y = 0,
        opacity = 0
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
      };
    }

    /* src/components/Icon.svelte generated by Svelte v3.44.3 */
    const file$A = "src/components/Icon.svelte"; // (26:0) {:else}

    function create_else_block$e(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "svg-icon svelte-10b4xd8");
          set_style(div, "fill",
          /*color*/
          ctx[2]);
          set_style(div, "stroke",
          /*color*/
          ctx[2]);
          set_style(div, "color",
          /*color*/
          ctx[2]);
          add_location(div, file$A, 26, 0, 478);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          div.innerHTML =
          /*icon*/
          ctx[0];
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*icon*/
          1) div.innerHTML =
          /*icon*/
          ctx[0];

          if (dirty &
          /*color*/
          4) {
            set_style(div, "fill",
            /*color*/
            ctx[2]);
          }

          if (dirty &
          /*color*/
          4) {
            set_style(div, "stroke",
            /*color*/
            ctx[2]);
          }

          if (dirty &
          /*color*/
          4) {
            set_style(div, "color",
            /*color*/
            ctx[2]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$e.name,
        type: "else",
        source: "(26:0) {:else}",
        ctx
      });
      return block;
    } // (22:0) {#if inline}


    function create_if_block$o(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "class", "svg-icon inline svelte-10b4xd8");
          set_style(span, "fill",
          /*color*/
          ctx[2]);
          set_style(span, "stroke",
          /*color*/
          ctx[2]);
          set_style(span, "color",
          /*color*/
          ctx[2]);
          add_location(span, file$A, 22, 0, 360);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          span.innerHTML =
          /*icon*/
          ctx[0];
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*icon*/
          1) span.innerHTML =
          /*icon*/
          ctx[0];

          if (dirty &
          /*color*/
          4) {
            set_style(span, "fill",
            /*color*/
            ctx[2]);
          }

          if (dirty &
          /*color*/
          4) {
            set_style(span, "stroke",
            /*color*/
            ctx[2]);
          }

          if (dirty &
          /*color*/
          4) {
            set_style(span, "color",
            /*color*/
            ctx[2]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$o.name,
        type: "if",
        source: "(22:0) {#if inline}",
        ctx
      });
      return block;
    }

    function create_fragment$C(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (
        /*inline*/
        ctx[1]) return create_if_block$o;
        return create_else_block$e;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$C.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Icon', slots, []);
      let {
        icon
      } = $$props;
      let {
        inline = false
      } = $$props;
      let {
        color = "inherit"
      } = $$props;
      const writable_props = ['icon', 'inline', 'color'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
        if ('inline' in $$props) $$invalidate(1, inline = $$props.inline);
        if ('color' in $$props) $$invalidate(2, color = $$props.color);
      };

      $$self.$capture_state = () => ({
        icon,
        inline,
        color
      });

      $$self.$inject_state = $$props => {
        if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
        if ('inline' in $$props) $$invalidate(1, inline = $$props.inline);
        if ('color' in $$props) $$invalidate(2, color = $$props.color);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [icon, inline, color];
    }

    class Icon extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$C, create_fragment$C, safe_not_equal, {
          icon: 0,
          inline: 1,
          color: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Icon",
          options,
          id: create_fragment$C.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*icon*/
        ctx[0] === undefined && !('icon' in props)) {
          console.warn("<Icon> was created without expected prop 'icon'");
        }
      }

      get icon() {
        throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set icon(value) {
        throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get inline() {
        throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set inline(value) {
        throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get color() {
        throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set color(value) {
        throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    var closeIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <polygon fill="var(--ci-primary-color, currentColor)" points="348.071 141.302 260.308 229.065 172.545 141.302 149.917 163.929 237.681 251.692 149.917 339.456 172.545 362.083 260.308 274.32 348.071 362.083 370.699 339.456 282.935 251.692 370.699 163.929 348.071 141.302" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M425.706,86.294A240,240,0,0,0,86.294,425.706,240,240,0,0,0,425.706,86.294ZM256,464C141.309,464,48,370.691,48,256S141.309,48,256,48s208,93.309,208,208S370.691,464,256,464Z" class="ci-primary"/></svg>';

    // Use Intl formatting utilities where available, else fall back to simple formatting
    const shortBtcFormat = Intl && Intl.NumberFormat ? new Intl.NumberFormat(undefined, {
      minimumSignificantDigits: 8,
      maximumSignificantDigits: 8
    }) : {
      format(number) {
        return Number(number).toPrecision(8).slice(0, 9);
      }

    };
    const longBtcFormat = Intl && Intl.NumberFormat ? new Intl.NumberFormat(undefined, {
      maximumFractionDigits: 8
    }) : {
      format(number) {
        return Number(number).toFixed(8);
      }

    };
    const feeRateFormat = Intl && Intl.NumberFormat ? new Intl.NumberFormat(undefined, {
      maximumFractionDigits: 2,
      maximumSignificantDigits: 2
    }) : {
      format(number) {
        return Number(number).toPrecision(2).slice(0, 3);
      }

    };
    const dateFormat = {
      format(date) {
        const d = new Date(date);
        return `${d.getFullYear()}-${('' + (d.getMonth() + 1)).padStart(2, '0')}-${('' + d.getDate()).padStart(2, '0')} ${('' + d.getHours()).padStart(2, '0')}:${('' + d.getMinutes()).padStart(2, '0')}`;
      }

    };
    const numberFormat = Intl && Intl.NumberFormat ? new Intl.NumberFormat(undefined) : {
      format(number) {
        return Number(number).toLocaleString();
      }

    };
    const relativeTimeFormat = Intl && Intl.RelativeTimeFormat && false ? new Intl.RelativeTimeFormat(undefined, {
      numeric: 'auto'
    }) : {
      format(time, unit) {
        return `${Number(Math.abs(time)).toLocaleString()} ${unit}${time < 0 ? ' ago' : ''}`;
      }

    };
    const durationFormat = {
      format(milliseconds) {
        const seconds = milliseconds / 1000;
        const absSeconds = Math.abs(seconds);
        if (absSeconds < 1) return 'now';else if (absSeconds < 60) return relativeTimeFormat.format(seconds, absSeconds == 1 ? 'second' : 'seconds');else return relativeTimeFormat.format(Math.round(seconds / 60), Math.abs(Math.round(seconds / 60)) == 1 ? 'minute' : 'minutes');
      }

    };

    /* src/components/BlockInfo.svelte generated by Svelte v3.44.3 */
    const file$z = "src/components/BlockInfo.svelte";

    function get_each_context$d(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list[i];
      return child_ctx;
    } // (322:80) {#if block.height == $latestBlockHeight}


    function create_if_block_5$5(ctx) {
      let t;
      const block_1 = {
        c: function create() {
          t = text("Latest ");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block_5$5.name,
        type: "if",
        source: "(322:80) {#if block.height == $latestBlockHeight}",
        ctx
      });
      return block_1;
    } // (338:14) {:else}


    function create_else_block_1$5(ctx) {
      let span;
      const block_1 = {
        c: function create() {
          span = element("span");
          span.textContent = "unavailable";
          attr_dev(span, "class", "data-field svelte-itmjm5");
          add_location(span, file$z, 338, 16, 8765);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_else_block_1$5.name,
        type: "else",
        source: "(338:14) {:else}",
        ctx
      });
      return block_1;
    } // (336:14) {#if block.fees != null}


    function create_if_block_4$5(ctx) {
      let span;
      let t0_value =
      /*formatFee*/
      ctx[16](
      /*block*/
      ctx[1].avgFeerate) + "";
      let t0;
      let t1;
      const block_1 = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = text(" sats/vbyte");
          attr_dev(span, "class", "data-field svelte-itmjm5");
          add_location(span, file$z, 336, 16, 8652);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && t0_value !== (t0_value =
          /*formatFee*/
          ctx[16](
          /*block*/
          ctx[1].avgFeerate) + "")) set_data_dev(t0, t0_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block_4$5.name,
        type: "if",
        source: "(336:14) {#if block.fees != null}",
        ctx
      });
      return block_1;
    } // (345:80) {#if block.height == $latestBlockHeight}


    function create_if_block_3$7(ctx) {
      let t;
      const block_1 = {
        c: function create() {
          t = text("Latest ");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block_3$7.name,
        type: "if",
        source: "(345:80) {#if block.height == $latestBlockHeight}",
        ctx
      });
      return block_1;
    } // (356:14) {:else}


    function create_else_block$d(ctx) {
      let span;
      let t_value =
      /*formatBytes*/
      ctx[14](
      /*block*/
      ctx[1].bytes) + "";
      let t;
      const block_1 = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "data-field svelte-itmjm5");
          add_location(span, file$z, 356, 16, 9797);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && t_value !== (t_value =
          /*formatBytes*/
          ctx[14](
          /*block*/
          ctx[1].bytes) + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_else_block$d.name,
        type: "else",
        source: "(356:14) {:else}",
        ctx
      });
      return block_1;
    } // (354:14) {#if block.fees != null}


    function create_if_block_2$9(ctx) {
      let span;
      let t0_value =
      /*formatFee*/
      ctx[16](
      /*block*/
      ctx[1].avgFeerate) + "";
      let t0;
      let t1;
      const block_1 = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = text(" sats/vb");
          attr_dev(span, "class", "data-field svelte-itmjm5");
          add_location(span, file$z, 354, 16, 9687);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && t0_value !== (t0_value =
          /*formatFee*/
          ctx[16](
          /*block*/
          ctx[1].avgFeerate) + "")) set_data_dev(t0, t0_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block_2$9.name,
        type: "if",
        source: "(354:14) {#if block.fees != null}",
        ctx
      });
      return block_1;
    } // (363:6) {#if hasPrevBlock }


    function create_if_block_1$d(ctx) {
      let a;
      let svg;
      let path;
      let a_href_value;
      let mounted;
      let dispose;
      const block_1 = {
        c: function create() {
          a = element("a");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-itmjm5");
          add_location(path, file$z, 365, 12, 10162);
          attr_dev(svg, "class", "chevron left");
          attr_dev(svg, "height", "1.5em");
          attr_dev(svg, "width", "1.5em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$z, 364, 10, 10072);
          attr_dev(a, "href", a_href_value = "/block/height/" + (
          /*block*/
          ctx[1].height - 1));
          attr_dev(a, "class", "explore-button prev svelte-itmjm5");
          add_location(a, file$z, 363, 8, 9962);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, svg);
          append_dev(svg, path);

          if (!mounted) {
            dispose = listen_dev(a, "click",
            /*explorePrevBlock*/
            ctx[18], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && a_href_value !== (a_href_value = "/block/height/" + (
          /*block*/
          ctx[1].height - 1))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block_1$d.name,
        type: "if",
        source: "(363:6) {#if hasPrevBlock }",
        ctx
      });
      return block_1;
    } // (370:6) {#if hasNextBlock }


    function create_if_block$n(ctx) {
      let a;
      let svg;
      let path;
      let a_href_value;
      let mounted;
      let dispose;
      const block_1 = {
        c: function create() {
          a = element("a");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-itmjm5");
          add_location(path, file$z, 372, 12, 10557);
          attr_dev(svg, "class", "chevron right svelte-itmjm5");
          attr_dev(svg, "height", "1.5em");
          attr_dev(svg, "width", "1.5em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$z, 371, 10, 10466);
          attr_dev(a, "href", a_href_value = "/block/height/" + (
          /*block*/
          ctx[1].height + 1));
          attr_dev(a, "class", "explore-button next svelte-itmjm5");
          add_location(a, file$z, 370, 8, 10356);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, svg);
          append_dev(svg, path);

          if (!mounted) {
            dispose = listen_dev(a, "click",
            /*exploreNextBlock*/
            ctx[19], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && a_href_value !== (a_href_value = "/block/height/" + (
          /*block*/
          ctx[1].height + 1))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_if_block$n.name,
        type: "if",
        source: "(370:6) {#if hasNextBlock }",
        ctx
      });
      return block_1;
    } // (316:2) {#each ((block != null && visible && $blocksEnabled) ? [block] : []) as block (block.id)}


    function create_each_block$d(key_1, ctx) {
      let div11;
      let div10;
      let div5;
      let div0;
      let span0;
      let b0;
      let t0;
      let t1_value = numberFormat.format(
      /*block*/
      ctx[1].height) + "";
      let t1;
      let span0_title_value;
      let t2;
      let button0;
      let icon0;
      let t3;
      let div1;
      let span1;
      let t4_value =
      /*formatDateTime*/
      ctx[13](
      /*block*/
      ctx[1].time) + "";
      let t4;
      let t5;
      let span2;
      let t6;
      let t7;
      let div2;
      let span3;
      let t8_value =
      /*formatBytes*/
      ctx[14](
      /*block*/
      ctx[1].bytes) + "";
      let t8;
      let t9;
      let span4;
      let t10_value =
      /*formatCount*/
      ctx[15](
      /*block*/
      ctx[1].txnCount) + "";
      let t10;
      let t11;
      let t12_value = (
      /*block*/
      ctx[1].txnCount == 1 ? '' : 's') + "";
      let t12;
      let t13;
      let div3;
      let t15;
      let div4;
      let span5;
      let t17;
      let t18;
      let div9;
      let div6;
      let span6;
      let b1;
      let t19;
      let t20_value = numberFormat.format(
      /*block*/
      ctx[1].height) + "";
      let t20;
      let span6_title_value;
      let t21;
      let button1;
      let icon1;
      let t22;
      let div7;
      let span7;
      let t23_value =
      /*formatDateTime*/
      ctx[13](
      /*block*/
      ctx[1].time) + "";
      let t23;
      let t24;
      let span8;
      let t25;
      let t26;
      let div8;
      let span9;
      let t27_value =
      /*formatCount*/
      ctx[15](
      /*block*/
      ctx[1].txnCount) + "";
      let t27;
      let t28;
      let t29_value = (
      /*block*/
      ctx[1].txnCount == 1 ? '' : 's') + "";
      let t29;
      let t30;
      let t31;
      let t32;
      let t33;
      let button2;
      let icon2;
      let t34;
      let div11_intro;
      let div11_outro;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*block*/
      ctx[1].height ==
      /*$latestBlockHeight*/
      ctx[2] && create_if_block_5$5(ctx);
      icon0 = new Icon({
        props: {
          icon: closeIcon,
          color: "var(--palette-x)"
        },
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*block*/
        ctx[1].fees != null) return create_if_block_4$5;
        return create_else_block_1$5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block1 = current_block_type(ctx);
      let if_block2 =
      /*block*/
      ctx[1].height ==
      /*$latestBlockHeight*/
      ctx[2] && create_if_block_3$7(ctx);
      icon1 = new Icon({
        props: {
          icon: closeIcon,
          color: "var(--palette-x)"
        },
        $$inline: true
      });

      function select_block_type_1(ctx, dirty) {
        if (
        /*block*/
        ctx[1].fees != null) return create_if_block_2$9;
        return create_else_block$d;
      }

      let current_block_type_1 = select_block_type_1(ctx);
      let if_block3 = current_block_type_1(ctx);
      let if_block4 =
      /*hasPrevBlock*/
      ctx[8] && create_if_block_1$d(ctx);
      let if_block5 =
      /*hasNextBlock*/
      ctx[9] && create_if_block$n(ctx);
      icon2 = new Icon({
        props: {
          icon: closeIcon,
          color: "var(--palette-x)"
        },
        $$inline: true
      });
      const block_1 = {
        key: key_1,
        first: null,
        c: function create() {
          div11 = element("div");
          div10 = element("div");
          div5 = element("div");
          div0 = element("div");
          span0 = element("span");
          b0 = element("b");
          if (if_block0) if_block0.c();
          t0 = text("Block: ");
          t1 = text(t1_value);
          t2 = space();
          button0 = element("button");
          create_component(icon0.$$.fragment);
          t3 = space();
          div1 = element("div");
          span1 = element("span");
          t4 = text(t4_value);
          t5 = space();
          span2 = element("span");
          t6 = text(
          /*formattedBlockValue*/
          ctx[4]);
          t7 = space();
          div2 = element("div");
          span3 = element("span");
          t8 = text(t8_value);
          t9 = space();
          span4 = element("span");
          t10 = text(t10_value);
          t11 = text(" transaction");
          t12 = text(t12_value);
          t13 = space();
          div3 = element("div");
          div3.textContent = " ";
          t15 = space();
          div4 = element("div");
          span5 = element("span");
          span5.textContent = "avg fee rate";
          t17 = space();
          if_block1.c();
          t18 = space();
          div9 = element("div");
          div6 = element("div");
          span6 = element("span");
          b1 = element("b");
          if (if_block2) if_block2.c();
          t19 = text("Block: ");
          t20 = text(t20_value);
          t21 = space();
          button1 = element("button");
          create_component(icon1.$$.fragment);
          t22 = space();
          div7 = element("div");
          span7 = element("span");
          t23 = text(t23_value);
          t24 = space();
          span8 = element("span");
          t25 = text(
          /*formattedBlockValue*/
          ctx[4]);
          t26 = space();
          div8 = element("div");
          span9 = element("span");
          t27 = text(t27_value);
          t28 = text(" transaction");
          t29 = text(t29_value);
          t30 = space();
          if_block3.c();
          t31 = space();
          if (if_block4) if_block4.c();
          t32 = space();
          if (if_block5) if_block5.c();
          t33 = space();
          button2 = element("button");
          create_component(icon2.$$.fragment);
          t34 = space();
          add_location(b0, file$z, 321, 77, 7708);
          attr_dev(span0, "class", "data-field title-field svelte-itmjm5");
          attr_dev(span0, "title", span0_title_value =
          /*block*/
          ctx[1].miner_sig);
          add_location(span0, file$z, 321, 14, 7645);
          attr_dev(button0, "class", "data-field close-button svelte-itmjm5");
          add_location(button0, file$z, 322, 14, 7833);
          attr_dev(div0, "class", "data-row svelte-itmjm5");
          add_location(div0, file$z, 320, 12, 7608);
          attr_dev(span1, "class", "data-field svelte-itmjm5");
          attr_dev(span1, "title", "block timestamp");
          add_location(span1, file$z, 325, 14, 8022);
          attr_dev(span2, "class", "data-field svelte-itmjm5");
          add_location(span2, file$z, 326, 14, 8123);
          attr_dev(div1, "class", "data-row svelte-itmjm5");
          add_location(div1, file$z, 324, 12, 7985);
          attr_dev(span3, "class", "data-field svelte-itmjm5");
          add_location(span3, file$z, 329, 14, 8247);
          attr_dev(span4, "class", "data-field svelte-itmjm5");
          add_location(span4, file$z, 330, 14, 8322);
          attr_dev(div2, "class", "data-row svelte-itmjm5");
          add_location(div2, file$z, 328, 12, 8210);
          attr_dev(div3, "class", "data-row spacer svelte-itmjm5");
          add_location(div3, file$z, 332, 12, 8461);
          attr_dev(span5, "class", "data-field svelte-itmjm5");
          add_location(span5, file$z, 334, 14, 8552);
          attr_dev(div4, "class", "data-row svelte-itmjm5");
          add_location(div4, file$z, 333, 12, 8515);
          attr_dev(div5, "class", "full-size svelte-itmjm5");
          add_location(div5, file$z, 319, 10, 7572);
          add_location(b1, file$z, 344, 77, 9009);
          attr_dev(span6, "class", "data-field title-field svelte-itmjm5");
          attr_dev(span6, "title", span6_title_value =
          /*block*/
          ctx[1].miner_sig);
          add_location(span6, file$z, 344, 14, 8946);
          attr_dev(button1, "class", "data-field close-button svelte-itmjm5");
          add_location(button1, file$z, 345, 14, 9134);
          attr_dev(div6, "class", "data-row svelte-itmjm5");
          add_location(div6, file$z, 343, 12, 8909);
          attr_dev(span7, "class", "data-field svelte-itmjm5");
          add_location(span7, file$z, 348, 14, 9323);
          attr_dev(span8, "class", "data-field svelte-itmjm5");
          add_location(span8, file$z, 349, 14, 9400);
          attr_dev(div7, "class", "data-row svelte-itmjm5");
          add_location(div7, file$z, 347, 12, 9286);
          attr_dev(span9, "class", "data-field svelte-itmjm5");
          add_location(span9, file$z, 352, 14, 9524);
          attr_dev(div8, "class", "data-row svelte-itmjm5");
          add_location(div8, file$z, 351, 12, 9487);
          attr_dev(div9, "class", "compact svelte-itmjm5");
          add_location(div9, file$z, 342, 10, 8875);
          attr_dev(div10, "class", "block-info svelte-itmjm5");
          toggle_class(div10, "compact",
          /*compactView*/
          ctx[5]);
          toggle_class(div10, "landscape",
          /*landscape*/
          ctx[6]);
          add_location(div10, file$z, 317, 6, 7411);
          attr_dev(button2, "class", "close-button standalone svelte-itmjm5");
          toggle_class(button2, "landscape",
          /*landscape*/
          ctx[6]);
          toggle_class(button2, "tinyscreen",
          /*tinyView*/
          ctx[7]);
          add_location(button2, file$z, 376, 6, 10723);
          attr_dev(div11, "class", "block-info-container svelte-itmjm5");
          add_location(div11, file$z, 316, 4, 7326);
          this.first = div11;
        },
        m: function mount(target, anchor) {
          insert_dev(target, div11, anchor);
          append_dev(div11, div10);
          append_dev(div10, div5);
          append_dev(div5, div0);
          append_dev(div0, span0);
          append_dev(span0, b0);
          if (if_block0) if_block0.m(b0, null);
          append_dev(b0, t0);
          append_dev(span0, t1);
          append_dev(div0, t2);
          append_dev(div0, button0);
          mount_component(icon0, button0, null);
          append_dev(div5, t3);
          append_dev(div5, div1);
          append_dev(div1, span1);
          append_dev(span1, t4);
          append_dev(div1, t5);
          append_dev(div1, span2);
          append_dev(span2, t6);
          append_dev(div5, t7);
          append_dev(div5, div2);
          append_dev(div2, span3);
          append_dev(span3, t8);
          append_dev(div2, t9);
          append_dev(div2, span4);
          append_dev(span4, t10);
          append_dev(span4, t11);
          append_dev(span4, t12);
          append_dev(div5, t13);
          append_dev(div5, div3);
          append_dev(div5, t15);
          append_dev(div5, div4);
          append_dev(div4, span5);
          append_dev(div4, t17);
          if_block1.m(div4, null);
          append_dev(div10, t18);
          append_dev(div10, div9);
          append_dev(div9, div6);
          append_dev(div6, span6);
          append_dev(span6, b1);
          if (if_block2) if_block2.m(b1, null);
          append_dev(b1, t19);
          append_dev(span6, t20);
          append_dev(div6, t21);
          append_dev(div6, button1);
          mount_component(icon1, button1, null);
          append_dev(div9, t22);
          append_dev(div9, div7);
          append_dev(div7, span7);
          append_dev(span7, t23);
          append_dev(div7, t24);
          append_dev(div7, span8);
          append_dev(span8, t25);
          append_dev(div9, t26);
          append_dev(div9, div8);
          append_dev(div8, span9);
          append_dev(span9, t27);
          append_dev(span9, t28);
          append_dev(span9, t29);
          append_dev(div8, t30);
          if_block3.m(div8, null);
          append_dev(div11, t31);
          if (if_block4) if_block4.m(div11, null);
          append_dev(div11, t32);
          if (if_block5) if_block5.m(div11, null);
          append_dev(div11, t33);
          append_dev(div11, button2);
          mount_component(icon2, button2, null);
          append_dev(div11, t34);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(button0, "click",
            /*hideBlock*/
            ctx[17], false, false, false), listen_dev(button1, "click",
            /*hideBlock*/
            ctx[17], false, false, false), listen_dev(button2, "click",
            /*hideBlock*/
            ctx[17], false, false, false)];
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (
          /*block*/
          ctx[1].height ==
          /*$latestBlockHeight*/
          ctx[2]) {
            if (if_block0) ; else {
              if_block0 = create_if_block_5$5(ctx);
              if_block0.c();
              if_block0.m(b0, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t1_value !== (t1_value = numberFormat.format(
          /*block*/
          ctx[1].height) + "")) set_data_dev(t1, t1_value);

          if (!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && span0_title_value !== (span0_title_value =
          /*block*/
          ctx[1].miner_sig)) {
            attr_dev(span0, "title", span0_title_value);
          }

          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t4_value !== (t4_value =
          /*formatDateTime*/
          ctx[13](
          /*block*/
          ctx[1].time) + "")) set_data_dev(t4, t4_value);
          if (!current || dirty[0] &
          /*formattedBlockValue*/
          16) set_data_dev(t6,
          /*formattedBlockValue*/
          ctx[4]);
          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t8_value !== (t8_value =
          /*formatBytes*/
          ctx[14](
          /*block*/
          ctx[1].bytes) + "")) set_data_dev(t8, t8_value);
          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t10_value !== (t10_value =
          /*formatCount*/
          ctx[15](
          /*block*/
          ctx[1].txnCount) + "")) set_data_dev(t10, t10_value);
          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t12_value !== (t12_value = (
          /*block*/
          ctx[1].txnCount == 1 ? '' : 's') + "")) set_data_dev(t12, t12_value);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1.d(1);
            if_block1 = current_block_type(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(div4, null);
            }
          }

          if (
          /*block*/
          ctx[1].height ==
          /*$latestBlockHeight*/
          ctx[2]) {
            if (if_block2) ; else {
              if_block2 = create_if_block_3$7(ctx);
              if_block2.c();
              if_block2.m(b1, t19);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t20_value !== (t20_value = numberFormat.format(
          /*block*/
          ctx[1].height) + "")) set_data_dev(t20, t20_value);

          if (!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11 && span6_title_value !== (span6_title_value =
          /*block*/
          ctx[1].miner_sig)) {
            attr_dev(span6, "title", span6_title_value);
          }

          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t23_value !== (t23_value =
          /*formatDateTime*/
          ctx[13](
          /*block*/
          ctx[1].time) + "")) set_data_dev(t23, t23_value);
          if (!current || dirty[0] &
          /*formattedBlockValue*/
          16) set_data_dev(t25,
          /*formattedBlockValue*/
          ctx[4]);
          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t27_value !== (t27_value =
          /*formatCount*/
          ctx[15](
          /*block*/
          ctx[1].txnCount) + "")) set_data_dev(t27, t27_value);
          if ((!current || dirty[0] &
          /*block, visible, $blocksEnabled*/
          11) && t29_value !== (t29_value = (
          /*block*/
          ctx[1].txnCount == 1 ? '' : 's') + "")) set_data_dev(t29, t29_value);

          if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block3) {
            if_block3.p(ctx, dirty);
          } else {
            if_block3.d(1);
            if_block3 = current_block_type_1(ctx);

            if (if_block3) {
              if_block3.c();
              if_block3.m(div8, null);
            }
          }

          if (dirty[0] &
          /*compactView*/
          32) {
            toggle_class(div10, "compact",
            /*compactView*/
            ctx[5]);
          }

          if (dirty[0] &
          /*landscape*/
          64) {
            toggle_class(div10, "landscape",
            /*landscape*/
            ctx[6]);
          }

          if (
          /*hasPrevBlock*/
          ctx[8]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block_1$d(ctx);
              if_block4.c();
              if_block4.m(div11, t32);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }

          if (
          /*hasNextBlock*/
          ctx[9]) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block$n(ctx);
              if_block5.c();
              if_block5.m(div11, t33);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if (dirty[0] &
          /*landscape*/
          64) {
            toggle_class(button2, "landscape",
            /*landscape*/
            ctx[6]);
          }

          if (dirty[0] &
          /*tinyView*/
          128) {
            toggle_class(button2, "tinyscreen",
            /*tinyView*/
            ctx[7]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon0.$$.fragment, local);
          transition_in(icon1.$$.fragment, local);
          transition_in(icon2.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (div11_outro) div11_outro.end(1);
              div11_intro = create_in_transition(div11, fly,
              /*flyIn*/
              ctx[11]);
              div11_intro.start();
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(icon0.$$.fragment, local);
          transition_out(icon1.$$.fragment, local);
          transition_out(icon2.$$.fragment, local);
          if (div11_intro) div11_intro.invalidate();

          if (local) {
            div11_outro = create_out_transition(div11, fly,
            /*flyOut*/
            ctx[12]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div11);
          if (if_block0) if_block0.d();
          destroy_component(icon0);
          if_block1.d();
          if (if_block2) if_block2.d();
          destroy_component(icon1);
          if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          destroy_component(icon2);
          if (detaching && div11_outro) div11_outro.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_each_block$d.name,
        type: "each",
        source: "(316:2) {#each ((block != null && visible && $blocksEnabled) ? [block] : []) as block (block.id)}",
        ctx
      });
      return block_1;
    } // (315:0) {#key transitionDirection}


    function create_key_block$1(ctx) {
      let each_blocks = [];
      let each_1_lookup = new Map();
      let each_1_anchor;
      let current;
      let each_value =
      /*block*/
      ctx[1] != null &&
      /*visible*/
      ctx[0] &&
      /*$blocksEnabled*/
      ctx[3] ? [
      /*block*/
      ctx[1]] : [];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*block*/
      ctx[1].id;

      validate_each_keys(ctx, each_value, get_each_context$d, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$d(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
      }

      const block_1 = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*flyOut, landscape, tinyView, hideBlock, block, visible, $blocksEnabled, exploreNextBlock, hasNextBlock, explorePrevBlock, hasPrevBlock, compactView, formatFee, formatBytes, formatCount, formattedBlockValue, formatDateTime, $latestBlockHeight*/
          1045503) {
            each_value =
            /*block*/
            ctx[1] != null &&
            /*visible*/
            ctx[0] &&
            /*$blocksEnabled*/
            ctx[3] ? [
            /*block*/
            ctx[1]] : [];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$d, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$d, each_1_anchor, get_each_context$d);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d(detaching);
          }

          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_key_block$1.name,
        type: "key",
        source: "(315:0) {#key transitionDirection}",
        ctx
      });
      return block_1;
    }

    function create_fragment$B(ctx) {
      let previous_key =
      /*transitionDirection*/
      ctx[10];
      let key_block_anchor;
      let current;
      let key_block = create_key_block$1(ctx);
      const block_1 = {
        c: function create() {
          key_block.c();
          key_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          key_block.m(target, anchor);
          insert_dev(target, key_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*transitionDirection*/
          1024 && safe_not_equal(previous_key, previous_key =
          /*transitionDirection*/
          ctx[10])) {
            group_outros();
            transition_out(key_block, 1, 1, noop);
            check_outros();
            key_block = create_key_block$1(ctx);
            key_block.c();
            transition_in(key_block);
            key_block.m(key_block_anchor.parentNode, key_block_anchor);
          } else {
            key_block.p(ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(key_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(key_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(key_block_anchor);
          key_block.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block: block_1,
        id: create_fragment$B.name,
        type: "component",
        source: "",
        ctx
      });
      return block_1;
    }

    const newBlockDelay = 2000;

    function instance$B($$self, $$props, $$invalidate) {
      let $latestBlockHeight;
      let $loading;
      let $blockTransitionDirection;
      let $blocksEnabled;
      let $settings;
      let $exchangeRates;
      let $pageHeight;
      let $pageWidth;
      let $freezeResize;
      validate_store(latestBlockHeight, 'latestBlockHeight');
      component_subscribe($$self, latestBlockHeight, $$value => $$invalidate(2, $latestBlockHeight = $$value));
      validate_store(loading, 'loading');
      component_subscribe($$self, loading, $$value => $$invalidate(29, $loading = $$value));
      validate_store(blockTransitionDirection, 'blockTransitionDirection');
      component_subscribe($$self, blockTransitionDirection, $$value => $$invalidate(23, $blockTransitionDirection = $$value));
      validate_store(blocksEnabled, 'blocksEnabled');
      component_subscribe($$self, blocksEnabled, $$value => $$invalidate(3, $blocksEnabled = $$value));
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(24, $settings = $$value));
      validate_store(exchangeRates, 'exchangeRates');
      component_subscribe($$self, exchangeRates, $$value => $$invalidate(25, $exchangeRates = $$value));
      validate_store(pageHeight, 'pageHeight');
      component_subscribe($$self, pageHeight, $$value => $$invalidate(26, $pageHeight = $$value));
      validate_store(pageWidth, 'pageWidth');
      component_subscribe($$self, pageWidth, $$value => $$invalidate(27, $pageWidth = $$value));
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(28, $freezeResize = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('BlockInfo', slots, []);
      const dispatch = createEventDispatcher();
      let prevBlockId;
      let blockId;
      let {
        block
      } = $$props;
      let {
        visible
      } = $$props;
      let restoring = false;
      let formattedBlockValue = '';
      let compactView;
      let landscape;
      let tinyView;
      let hasPrevBlock;
      let hasNextBlock;
      let transitionDirection;
      let flyIn;
      let flyOut;

      function formatDateTime(time) {
        return dateFormat.format(time);
      }

      function formatBTC(sats) {
        return `₿ ${shortBtcFormat.format(sats / 100000000)}`;
      }

      function formatBytes(bytes) {
        if (bytes) {
          return `${numberFormat.format(bytes)} bytes`;
        } else return `unknown size`;
      }

      function formatCount(n) {
        if (n) {
          return numberFormat.format(n);
        } else return '0';
      }

      function formatFee(n) {
        if (n) {
          return numberFormat.format(n.toFixed(2));
        } else return '0';
      }

      function hideBlock() {
        if (block && block.height != $latestBlockHeight) {
          dispatch('quitExploring');
        } else {
          analytics.trackEvent('viz', 'block', 'hide');
          dispatch('hideBlock');
        }
      }

      async function explorePrevBlock(e) {
        e.preventDefault();

        if (!$loading && block) {
          loading.increment();
          await searchBlockHeight(block.height - 1);
          loading.decrement();
        }
      }

      async function exploreNextBlock(e) {
        e.preventDefault();

        if (!$loading && block) {
          if (block.height + 1 < $latestBlockHeight) {
            loading.increment();
            await searchBlockHeight(block.height + 1);
            loading.decrement();
          } else {
            dispatch('quitExploring');
          }
        }
      }

      const writable_props = ['block', 'visible'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlockInfo> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('block' in $$props) $$invalidate(1, block = $$props.block);
        if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
      };

      $$self.$capture_state = () => ({
        analytics,
        fly,
        smootherstep,
        createEventDispatcher,
        Icon,
        closeIcon,
        shortBtcFormat,
        longBtcFormat,
        dateFormat,
        numberFormat,
        exchangeRates,
        settings,
        blocksEnabled,
        latestBlockHeight,
        blockTransitionDirection,
        loading,
        freezeResize,
        pageWidth,
        pageHeight,
        formatCurrency,
        searchBlockHeight,
        dispatch,
        prevBlockId,
        blockId,
        block,
        visible,
        newBlockDelay,
        restoring,
        formattedBlockValue,
        compactView,
        landscape,
        tinyView,
        hasPrevBlock,
        hasNextBlock,
        transitionDirection,
        flyIn,
        flyOut,
        formatDateTime,
        formatBTC,
        formatBytes,
        formatCount,
        formatFee,
        hideBlock,
        explorePrevBlock,
        exploreNextBlock,
        $latestBlockHeight,
        $loading,
        $blockTransitionDirection,
        $blocksEnabled,
        $settings,
        $exchangeRates,
        $pageHeight,
        $pageWidth,
        $freezeResize
      });

      $$self.$inject_state = $$props => {
        if ('prevBlockId' in $$props) $$invalidate(20, prevBlockId = $$props.prevBlockId);
        if ('blockId' in $$props) $$invalidate(21, blockId = $$props.blockId);
        if ('block' in $$props) $$invalidate(1, block = $$props.block);
        if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
        if ('restoring' in $$props) $$invalidate(22, restoring = $$props.restoring);
        if ('formattedBlockValue' in $$props) $$invalidate(4, formattedBlockValue = $$props.formattedBlockValue);
        if ('compactView' in $$props) $$invalidate(5, compactView = $$props.compactView);
        if ('landscape' in $$props) $$invalidate(6, landscape = $$props.landscape);
        if ('tinyView' in $$props) $$invalidate(7, tinyView = $$props.tinyView);
        if ('hasPrevBlock' in $$props) $$invalidate(8, hasPrevBlock = $$props.hasPrevBlock);
        if ('hasNextBlock' in $$props) $$invalidate(9, hasNextBlock = $$props.hasNextBlock);
        if ('transitionDirection' in $$props) $$invalidate(10, transitionDirection = $$props.transitionDirection);
        if ('flyIn' in $$props) $$invalidate(11, flyIn = $$props.flyIn);
        if ('flyOut' in $$props) $$invalidate(12, flyOut = $$props.flyOut);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*$pageWidth, $pageHeight, $freezeResize*/
        469762048) {
          {
            if ($pageWidth && $pageHeight && !$freezeResize) {
              const aspectRatio = $pageWidth / $pageHeight;
              $$invalidate(6, landscape = aspectRatio >= 1);
              $$invalidate(5, compactView = aspectRatio < 1 && $pageHeight < 760);
              $$invalidate(7, tinyView = aspectRatio < 1 && $pageHeight <= 400);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*block, $exchangeRates, $settings*/
        50331650) {
          {
            if (block && block.value) {
              const rate = $exchangeRates[$settings.currency];
              let local;

              if (rate && rate.last) {
                local = formatCurrency($settings.currency, block.value / 100000000 * rate.last, {
                  compact: true
                });
              } else {
                local = null;
              }

              $$invalidate(4, formattedBlockValue = `${formatBTC(block.value)}${local != null ? ' ≈ ' + local : ''}`);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*block, visible, blockId*/
        2097155) {
          {
            if (block && visible) {
              $$invalidate(20, prevBlockId = blockId);
              $$invalidate(21, blockId = block.id);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*visible, block, prevBlockId*/
        1048579) {
          {
            if (visible && block && block.id === prevBlockId) {
              $$invalidate(22, restoring = true);
            } else {
              $$invalidate(22, restoring = false);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*block, $latestBlockHeight*/
        6) {
          {
            if (block) {
              if (block.height > 0) $$invalidate(8, hasPrevBlock = true);else $$invalidate(8, hasPrevBlock = false);
              if (block.height < $latestBlockHeight) $$invalidate(9, hasNextBlock = true);else $$invalidate(9, hasNextBlock = false);
            } else {
              $$invalidate(8, hasPrevBlock = false);
              $$invalidate(9, hasNextBlock = false);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$blockTransitionDirection, visible, block, $blocksEnabled, restoring*/
        12582923) {
          {
            if (!$blockTransitionDirection || !visible || !block || !$blocksEnabled) {
              $$invalidate(10, transitionDirection = 'up');
              $$invalidate(11, flyIn = {
                y: restoring ? -50 : 50,
                duration: restoring ? 1500 : 1000,
                easing: smootherstep,
                delay: restoring ? 0 : newBlockDelay
              });
              $$invalidate(12, flyOut = {
                y: -50,
                duration: 1500,
                easing: smootherstep,
                delay: 0
              });
            } else if ($blockTransitionDirection && $blockTransitionDirection === 'right') {
              $$invalidate(10, transitionDirection = 'right');
              $$invalidate(11, flyIn = {
                x: 100,
                easing: smootherstep,
                delay: 1000,
                duration: 1000
              });
              $$invalidate(12, flyOut = {
                x: -100,
                easing: smootherstep,
                delay: 0,
                duration: 1000
              });
            } else if ($blockTransitionDirection && $blockTransitionDirection === 'left') {
              $$invalidate(10, transitionDirection = 'left');
              $$invalidate(11, flyIn = {
                x: -100,
                easing: smootherstep,
                delay: 1000,
                duration: 1000
              });
              $$invalidate(12, flyOut = {
                x: 100,
                easing: smootherstep,
                delay: 0,
                duration: 1000
              });
            } else {
              $$invalidate(10, transitionDirection = 'down');
            }
          }
        }
      };

      return [visible, block, $latestBlockHeight, $blocksEnabled, formattedBlockValue, compactView, landscape, tinyView, hasPrevBlock, hasNextBlock, transitionDirection, flyIn, flyOut, formatDateTime, formatBytes, formatCount, formatFee, hideBlock, explorePrevBlock, exploreNextBlock, prevBlockId, blockId, restoring, $blockTransitionDirection, $settings, $exchangeRates, $pageHeight, $pageWidth, $freezeResize];
    }

    class BlockInfo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$B, create_fragment$B, safe_not_equal, {
          block: 1,
          visible: 0
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "BlockInfo",
          options,
          id: create_fragment$B.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*block*/
        ctx[1] === undefined && !('block' in props)) {
          console.warn("<BlockInfo> was created without expected prop 'block'");
        }

        if (
        /*visible*/
        ctx[0] === undefined && !('visible' in props)) {
          console.warn("<BlockInfo> was created without expected prop 'visible'");
        }
      }

      get block() {
        throw new Error("<BlockInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set block(value) {
        throw new Error("<BlockInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<BlockInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<BlockInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    function flip(node, _ref) {
      let {
        from,
        to
      } = _ref;
      let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const style = getComputedStyle(node);
      const transform = style.transform === 'none' ? '' : style.transform;
      const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
      const dx = from.left + from.width * ox / to.width - (to.left + ox);
      const dy = from.top + from.height * oy / to.height - (to.top + oy);
      const {
        delay = 0,
        duration = d => Math.sqrt(d) * 120,
        easing = cubicOut
      } = params;
      return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
          const x = u * dx;
          const y = u * dy;
          const sx = t + u * from.width / to.width;
          const sy = t + u * from.height / to.height;
          return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
      };
    }

    var SearchIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M479.6,399.716l-81.084-81.084-62.368-25.767A175.014,175.014,0,0,0,368,192c0-97.047-78.953-176-176-176S16,94.953,16,192,94.953,368,192,368a175.034,175.034,0,0,0,101.619-32.377l25.7,62.2L400.4,478.911a56,56,0,1,0,79.2-79.195ZM48,192c0-79.4,64.6-144,144-144s144,64.6,144,144S271.4,336,192,336,48,271.4,48,192ZM456.971,456.284a24.028,24.028,0,0,1-33.942,0l-76.572-76.572-23.894-57.835L380.4,345.771l76.573,76.572A24.028,24.028,0,0,1,456.971,456.284Z" class="ci-primary"/></svg>';

    var AddressIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M489.972,119.059a23.839,23.839,0,0,0-17-7.059H456V72a24.027,24.027,0,0,0-24-24H86.627A70.628,70.628,0,0,0,16,118.627V393.373A70.628,70.628,0,0,0,86.627,464h385.4a24.047,24.047,0,0,0,24-23.923l.944-303.995A23.837,23.837,0,0,0,489.972,119.059ZM464.053,432H86.627A38.627,38.627,0,0,1,48,393.373V118.627A38.627,38.627,0,0,1,86.627,80H424v32H88v32H464.947Z" class="ci-primary"/>  <rect x="392" y="264" fill="var(--ci-primary-color, currentColor)" class="ci-primary"/></svg>';

    var TxIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M256.25,16.042c-132.548,0-240,107.451-240,240s107.452,240,240,240,240-107.452,240-240S388.8,16.042,256.25,16.042ZM403.328,403.12A207.253,207.253,0,1,1,447.917,337,207.364,207.364,0,0,1,403.328,403.12Z" class="ci-primary"/>  <polygon fill="var(--ci-primary-color, currentColor)" points="239.637 164.987 314.69 240.041 128.137 240.041 128.137 272.041 314.69 272.041 239.637 347.095 262.264 369.722 375.945 256.041 262.264 142.36 239.637 164.987" class="ci-primary"/></svg>';

    var gridIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-grid"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>';

    /* src/components/SearchBar.svelte generated by Svelte v3.44.3 */
    const file$y = "src/components/SearchBar.svelte"; // (222:4) {#if matchedQuery && matchedQuery.query && queryIcons[matchedQuery.query]}

    function create_if_block_1$c(ctx) {
      let div;
      let icon;
      let div_title_value;
      let div_transition;
      let current;
      icon = new Icon({
        props: {
          icon:
          /*queryIcons*/
          ctx[3][
          /*matchedQuery*/
          ctx[1].query]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(icon.$$.fragment);
          attr_dev(div, "class", "input-icon query-type svelte-kd7wxm");
          attr_dev(div, "title", div_title_value =
          /*matchedQuery*/
          ctx[1].label);
          add_location(div, file$y, 222, 6, 5400);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(icon, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const icon_changes = {};
          if (dirty &
          /*matchedQuery*/
          2) icon_changes.icon =
          /*queryIcons*/
          ctx[3][
          /*matchedQuery*/
          ctx[1].query];
          icon.$set(icon_changes);

          if (!current || dirty &
          /*matchedQuery*/
          2 && div_title_value !== (div_title_value =
          /*matchedQuery*/
          ctx[1].label)) {
            attr_dev(div, "title", div_title_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
              duration: 300
            }, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
            duration: 300
          }, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(icon);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$c.name,
        type: "if",
        source: "(222:4) {#if matchedQuery && matchedQuery.query && queryIcons[matchedQuery.query]}",
        ctx
      });
      return block;
    } // (227:4) {#if errorMessage }


    function create_if_block$m(ctx) {
      let p;
      let t;
      let p_transition;
      let current;
      const block = {
        c: function create() {
          p = element("p");
          t = text(
          /*errorMessage*/
          ctx[2]);
          attr_dev(p, "class", "error-msg svelte-kd7wxm");
          add_location(p, file$y, 227, 6, 5607);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*errorMessage*/
          4) set_data_dev(t,
          /*errorMessage*/
          ctx[2]);
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!p_transition) p_transition = create_bidirectional_transition(p, fade, {
              duration: 300
            }, true);
            p_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!p_transition) p_transition = create_bidirectional_transition(p, fade, {
            duration: 300
          }, false);
          p_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
          if (detaching && p_transition) p_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$m.name,
        type: "if",
        source: "(227:4) {#if errorMessage }",
        ctx
      });
      return block;
    }

    function create_fragment$A(ctx) {
      let div4;
      let form;
      let input;
      let t0;
      let div0;
      let icon0;
      let t1;
      let div1;
      let t2;
      let div2;
      let t3;
      let button;
      let t4;
      let t5;
      let t6;
      let div3;
      let icon1;
      let div4_transition;
      let current;
      let mounted;
      let dispose;
      icon0 = new Icon({
        props: {
          icon: closeIcon
        },
        $$inline: true
      });
      let if_block0 =
      /*matchedQuery*/
      ctx[1] &&
      /*matchedQuery*/
      ctx[1].query &&
      /*queryIcons*/
      ctx[3][
      /*matchedQuery*/
      ctx[1].query] && create_if_block_1$c(ctx);
      let if_block1 =
      /*errorMessage*/
      ctx[2] && create_if_block$m(ctx);
      icon1 = new Icon({
        props: {
          icon: SearchIcon
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div4 = element("div");
          form = element("form");
          input = element("input");
          t0 = space();
          div0 = element("div");
          create_component(icon0.$$.fragment);
          t1 = space();
          div1 = element("div");
          t2 = space();
          div2 = element("div");
          t3 = space();
          button = element("button");
          t4 = space();
          if (if_block0) if_block0.c();
          t5 = space();
          if (if_block1) if_block1.c();
          t6 = space();
          div3 = element("div");
          create_component(icon1.$$.fragment);
          attr_dev(input, "class", "search-input svelte-kd7wxm");
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "txid, block id or block height");
          add_location(input, file$y, 214, 4, 4892);
          attr_dev(div0, "class", "clear-button svelte-kd7wxm");
          attr_dev(div0, "title", "Clear");
          toggle_class(div0, "disabled",
          /*query*/
          ctx[0] == null ||
          /*query*/
          ctx[0] === '');
          add_location(div0, file$y, 215, 4, 5045);
          attr_dev(div1, "class", "underline svelte-kd7wxm");
          add_location(div1, file$y, 218, 4, 5201);
          attr_dev(div2, "class", "underline active svelte-kd7wxm");
          add_location(div2, file$y, 219, 4, 5231);
          attr_dev(button, "type", "submit");
          attr_dev(button, "class", "search-submit svelte-kd7wxm");
          add_location(button, file$y, 220, 4, 5268);
          attr_dev(form, "class", "search-form svelte-kd7wxm");
          attr_dev(form, "action", "");
          add_location(form, file$y, 213, 2, 4826);
          attr_dev(div3, "class", "input-icon search icon-button svelte-kd7wxm");
          attr_dev(div3, "title", "Search");
          add_location(div3, file$y, 230, 2, 5707);
          attr_dev(div4, "class", "input-wrapper svelte-kd7wxm");
          add_location(div4, file$y, 212, 0, 4768);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          append_dev(div4, form);
          append_dev(form, input);
          set_input_value(input,
          /*query*/
          ctx[0]);
          append_dev(form, t0);
          append_dev(form, div0);
          mount_component(icon0, div0, null);
          append_dev(form, t1);
          append_dev(form, div1);
          append_dev(form, t2);
          append_dev(form, div2);
          append_dev(form, t3);
          append_dev(form, button);
          append_dev(form, t4);
          if (if_block0) if_block0.m(form, null);
          append_dev(form, t5);
          if (if_block1) if_block1.m(form, null);
          append_dev(div4, t6);
          append_dev(div4, div3);
          mount_component(icon1, div3, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(input, "input",
            /*input_input_handler*/
            ctx[8]), listen_dev(input, "focusin",
            /*focusIn*/
            ctx[6], false, false, false), listen_dev(input, "focusout",
            /*focusOut*/
            ctx[7], false, false, false), listen_dev(div0, "click",
            /*clearInput*/
            ctx[4], false, false, false), listen_dev(form, "submit",
            /*searchSubmit*/
            ctx[5], false, false, false), listen_dev(div3, "click",
            /*searchSubmit*/
            ctx[5], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*query*/
          1 && input.value !==
          /*query*/
          ctx[0]) {
            set_input_value(input,
            /*query*/
            ctx[0]);
          }

          if (dirty &
          /*query*/
          1) {
            toggle_class(div0, "disabled",
            /*query*/
            ctx[0] == null ||
            /*query*/
            ctx[0] === '');
          }

          if (
          /*matchedQuery*/
          ctx[1] &&
          /*matchedQuery*/
          ctx[1].query &&
          /*queryIcons*/
          ctx[3][
          /*matchedQuery*/
          ctx[1].query]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*matchedQuery*/
              2) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_1$c(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(form, t5);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*errorMessage*/
          ctx[2]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*errorMessage*/
              4) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$m(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(form, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon0.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(icon1.$$.fragment, local);
          add_render_callback(() => {
            if (!div4_transition) div4_transition = create_bidirectional_transition(div4, fly, {
              y: -25
            }, true);
            div4_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(icon0.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(icon1.$$.fragment, local);
          if (!div4_transition) div4_transition = create_bidirectional_transition(div4, fly, {
            y: -25
          }, false);
          div4_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div4);
          destroy_component(icon0);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          destroy_component(icon1);
          if (detaching && div4_transition) div4_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$A.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
      let $freezeResize;
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(10, $freezeResize = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SearchBar', slots, []);
      const queryIcons = {
        txid: TxIcon,
        input: TxIcon,
        output: TxIcon,
        // address: AddressIcon,
        blockhash: gridIcon,
        blockheight: gridIcon
      };
      let query;
      let matchedQuery;
      let errorMessage;

      function clearInput() {
        $$invalidate(0, query = null);
      }

      function handleSearchError(err) {
        switch (err) {
          case '404':
            if (matchedQuery && matchedQuery.label) {
              $$invalidate(2, errorMessage = `${matchedQuery.label} not found`);
            }

            break;

          default:
            $$invalidate(2, errorMessage = 'server error');
        }
      }

      async function searchSubmit(e) {
        e.preventDefault();
        if (document.activeElement) document.activeElement.blur();

        if (matchedQuery && matchedQuery.query !== 'address') {
          loading.increment();
          let searchErr;

          switch (matchedQuery.query) {
            case 'txid':
              searchErr = await searchTx(matchedQuery.txid);
              break;

            case 'input':
              searchErr = await searchTx(matchedQuery.txid, matchedQuery.input, null);
              break;

            case 'output':
              searchErr = await searchTx(matchedQuery.txid, null, matchedQuery.output);
              break;

            case 'blockheight':
              searchErr = await searchBlockHeight(matchedQuery.height);
              break;

            case 'blockhash':
              searchErr = await searchBlockHash(matchedQuery.hash);
              break;
          }

          if (searchErr == null) $$invalidate(2, errorMessage = null);else handleSearchError(searchErr);
          loading.decrement();
        } else {
          $$invalidate(2, errorMessage = 'enter a transaction id, block hash or block height');
        }

        return false;
      }

      let freezeTimeout;

      function focusIn(e) {
        if (freezeTimeout) clearTimeout(freezeTimeout);
        set_store_value(freezeResize, $freezeResize = true, $freezeResize);
      }

      async function focusOut(e) {
        freezeTimeout = setTimeout(() => {
          set_store_value(freezeResize, $freezeResize = false, $freezeResize);
        }, 500);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchBar> was created with unknown prop '${key}'`);
      });

      function input_input_handler() {
        query = this.value;
        $$invalidate(0, query);
      }

      $$self.$capture_state = () => ({
        tick,
        fade,
        flip,
        Icon,
        SearchIcon,
        CrossIcon: closeIcon,
        AddressIcon,
        TxIcon,
        BlockIcon: gridIcon,
        fly,
        matchQuery,
        searchTx,
        searchBlockHeight,
        searchBlockHash,
        selectedTx,
        detailTx,
        overlay,
        loading,
        freezeResize,
        queryIcons,
        query,
        matchedQuery,
        errorMessage,
        clearInput,
        handleSearchError,
        searchSubmit,
        freezeTimeout,
        focusIn,
        focusOut,
        $freezeResize
      });

      $$self.$inject_state = $$props => {
        if ('query' in $$props) $$invalidate(0, query = $$props.query);
        if ('matchedQuery' in $$props) $$invalidate(1, matchedQuery = $$props.matchedQuery);
        if ('errorMessage' in $$props) $$invalidate(2, errorMessage = $$props.errorMessage);
        if ('freezeTimeout' in $$props) freezeTimeout = $$props.freezeTimeout;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*query*/
        1) {
          {
            if (query) {
              $$invalidate(1, matchedQuery = matchQuery(query));
            } else {
              $$invalidate(1, matchedQuery = null);
            }

            $$invalidate(2, errorMessage = null);
          }
        }
      };

      return [query, matchedQuery, errorMessage, queryIcons, clearInput, searchSubmit, focusIn, focusOut, input_input_handler];
    }

    class SearchBar extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$A, create_fragment$A, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SearchBar",
          options,
          id: create_fragment$A.name
        });
      }

    }

    var BookmarkIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M424,496H388.75L256.008,381.19,123.467,496H88V16H424ZM120,48V456.667l135.992-117.8L392,456.5V48Z" class="ci-primary"/></svg>';

    /* src/components/TxInfo.svelte generated by Svelte v3.44.3 */
    const file$x = "src/components/TxInfo.svelte"; // (142:25) 

    function create_if_block_6$4(ctx) {
      let t0;
      let p;
      let t1_value =
      /*tx*/
      ctx[0].outputs.length + "";
      let t1;
      let t2;

      function select_block_type_1(ctx, dirty) {
        if (
        /*tx*/
        ctx[0].coinbase.sigAscii) return create_if_block_8$4;
        return create_else_block$c;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block0 = current_block_type(ctx);
      let if_block1 =
      /*tx*/
      ctx[0].outputs.length != 1 && create_if_block_7$4(ctx);
      const block = {
        c: function create() {
          if_block0.c();
          t0 = space();
          p = element("p");
          t1 = text(t1_value);
          t2 = text(" output");
          if (if_block1) if_block1.c();
          attr_dev(p, "class", "field inputs svelte-1absxd3");
          add_location(p, file$x, 147, 4, 3580);
        },
        m: function mount(target, anchor) {
          if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, p, anchor);
          append_dev(p, t1);
          append_dev(p, t2);
          if (if_block1) if_block1.m(p, null);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          }

          if (dirty &
          /*tx*/
          1 && t1_value !== (t1_value =
          /*tx*/
          ctx[0].outputs.length + "")) set_data_dev(t1, t1_value);

          if (
          /*tx*/
          ctx[0].outputs.length != 1) {
            if (if_block1) ; else {
              if_block1 = create_if_block_7$4(ctx);
              if_block1.c();
              if_block1.m(p, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if_block0.d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(p);
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$4.name,
        type: "if",
        source: "(142:25) ",
        ctx
      });
      return block;
    } // (136:2) {#if inputCount && outputCount && !tx.coinbase }


    function create_if_block_3$6(ctx) {
      let p;
      let span0;
      let t0;
      let t1;
      let t2;
      let span1;
      let t4;
      let span2;
      let t5;
      let t6;
      let if_block0 =
      /*inputCount*/
      ctx[5] != 1 && create_if_block_5$4(ctx);
      let if_block1 =
      /*outputCount*/
      ctx[6] != 1 && create_if_block_4$4(ctx);
      const block = {
        c: function create() {
          p = element("p");
          span0 = element("span");
          t0 = text(
          /*inputCount*/
          ctx[5]);
          t1 = text(" input");
          if (if_block0) if_block0.c();
          t2 = space();
          span1 = element("span");
          span1.textContent = "⟶";
          t4 = space();
          span2 = element("span");
          t5 = text(
          /*outputCount*/
          ctx[6]);
          t6 = text(" output");
          if (if_block1) if_block1.c();
          attr_dev(span0, "class", "svelte-1absxd3");
          add_location(span0, file$x, 137, 6, 3196);
          attr_dev(span1, "class", "arrow svelte-1absxd3");
          add_location(span1, file$x, 138, 6, 3263);
          attr_dev(span2, "class", "svelte-1absxd3");
          add_location(span2, file$x, 139, 6, 3307);
          attr_dev(p, "class", "field inputs svelte-1absxd3");
          add_location(p, file$x, 136, 4, 3165);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, span0);
          append_dev(span0, t0);
          append_dev(span0, t1);
          if (if_block0) if_block0.m(span0, null);
          append_dev(p, t2);
          append_dev(p, span1);
          append_dev(p, t4);
          append_dev(p, span2);
          append_dev(span2, t5);
          append_dev(span2, t6);
          if (if_block1) if_block1.m(span2, null);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*inputCount*/
          32) set_data_dev(t0,
          /*inputCount*/
          ctx[5]);

          if (
          /*inputCount*/
          ctx[5] != 1) {
            if (if_block0) ; else {
              if_block0 = create_if_block_5$4(ctx);
              if_block0.c();
              if_block0.m(span0, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (dirty &
          /*outputCount*/
          64) set_data_dev(t5,
          /*outputCount*/
          ctx[6]);

          if (
          /*outputCount*/
          ctx[6] != 1) {
            if (if_block1) ; else {
              if_block1 = create_if_block_4$4(ctx);
              if_block1.c();
              if_block1.m(span2, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$6.name,
        type: "if",
        source: "(136:2) {#if inputCount && outputCount && !tx.coinbase }",
        ctx
      });
      return block;
    } // (145:4) {:else}


    function create_else_block$c(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "Coinbase";
          attr_dev(p, "class", "field coinbase svelte-1absxd3");
          add_location(p, file$x, 145, 6, 3527);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$c.name,
        type: "else",
        source: "(145:4) {:else}",
        ctx
      });
      return block;
    } // (143:4) {#if tx.coinbase.sigAscii }


    function create_if_block_8$4(ctx) {
      let p;
      let t0;
      let t1_value =
      /*tx*/
      ctx[0].coinbase.sigAscii + "";
      let t1;
      const block = {
        c: function create() {
          p = element("p");
          t0 = text("Coinbase: ");
          t1 = text(t1_value);
          attr_dev(p, "class", "field coinbase svelte-1absxd3");
          add_location(p, file$x, 143, 6, 3444);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t0);
          append_dev(p, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*tx*/
          1 && t1_value !== (t1_value =
          /*tx*/
          ctx[0].coinbase.sigAscii + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$4.name,
        type: "if",
        source: "(143:4) {#if tx.coinbase.sigAscii }",
        ctx
      });
      return block;
    } // (148:56) {#if tx.outputs.length != 1}


    function create_if_block_7$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("s");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$4.name,
        type: "if",
        source: "(148:56) {#if tx.outputs.length != 1}",
        ctx
      });
      return block;
    } // (138:32) {#if inputCount != 1}


    function create_if_block_5$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("s");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$4.name,
        type: "if",
        source: "(138:32) {#if inputCount != 1}",
        ctx
      });
      return block;
    } // (140:34) {#if outputCount != 1}


    function create_if_block_4$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("s");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$4.name,
        type: "if",
        source: "(140:34) {#if outputCount != 1}",
        ctx
      });
      return block;
    } // (154:43) 


    function create_if_block_2$8(ctx) {
      let p0;
      let t1;
      let p1;
      const block = {
        c: function create() {
          p0 = element("p");
          p0.textContent = "Fee rate: unavailable";
          t1 = space();
          p1 = element("p");
          p1.textContent = "Fee: unavailable";
          attr_dev(p0, "class", "field feerate svelte-1absxd3");
          add_location(p0, file$x, 154, 4, 4017);
          attr_dev(p1, "class", "field fee svelte-1absxd3");
          add_location(p1, file$x, 155, 4, 4072);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, p1, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(p0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(p1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$8.name,
        type: "if",
        source: "(154:43) ",
        ctx
      });
      return block;
    } // (151:2) {#if !tx.coinbase && tx.fee != null }


    function create_if_block_1$b(ctx) {
      let p0;
      let t0;
      let t1_value = numberFormat.format(
      /*tx*/
      ctx[0].feerate.toFixed(2)) + "";
      let t1;
      let t2;
      let t3;
      let p1;
      let t4;
      let t5_value = numberFormat.format(
      /*tx*/
      ctx[0].fee) + "";
      let t5;
      let t6;
      const block = {
        c: function create() {
          p0 = element("p");
          t0 = text("Fee rate: ");
          t1 = text(t1_value);
          t2 = text(" sats/vbyte");
          t3 = space();
          p1 = element("p");
          t4 = text("Fee: ");
          t5 = text(t5_value);
          t6 = text(" sats");
          attr_dev(p0, "class", "field feerate svelte-1absxd3");
          add_location(p0, file$x, 151, 4, 3801);
          attr_dev(p1, "class", "field fee svelte-1absxd3");
          add_location(p1, file$x, 152, 4, 3902);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p0, anchor);
          append_dev(p0, t0);
          append_dev(p0, t1);
          append_dev(p0, t2);
          insert_dev(target, t3, anchor);
          insert_dev(target, p1, anchor);
          append_dev(p1, t4);
          append_dev(p1, t5);
          append_dev(p1, t6);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*tx*/
          1 && t1_value !== (t1_value = numberFormat.format(
          /*tx*/
          ctx[0].feerate.toFixed(2)) + "")) set_data_dev(t1, t1_value);
          if (dirty &
          /*tx*/
          1 && t5_value !== (t5_value = numberFormat.format(
          /*tx*/
          ctx[0].fee) + "")) set_data_dev(t5, t5_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p0);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(p1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$b.name,
        type: "if",
        source: "(151:2) {#if !tx.coinbase && tx.fee != null }",
        ctx
      });
      return block;
    } // (160:4) {#if formattedLocalValue != null }


    function create_if_block$l(ctx) {
      let span;
      let t0;
      let t1;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text("≈ ");
          t1 = text(
          /*formattedLocalValue*/
          ctx[4]);
          attr_dev(span, "class", "local-value svelte-1absxd3");
          add_location(span, file$x, 160, 6, 4234);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*formattedLocalValue*/
          16) set_data_dev(t1,
          /*formattedLocalValue*/
          ctx[4]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$l.name,
        type: "if",
        source: "(160:4) {#if formattedLocalValue != null }",
        ctx
      });
      return block;
    }

    function create_fragment$z(ctx) {
      let div1;
      let div0;
      let icon;
      let t0;
      let p0;
      let t1;
      let t2_value =
      /*tx*/
      ctx[0].id + "";
      let t2;
      let t3;
      let t4;
      let p1;
      let t5;
      let t6_value = numberFormat.format(
      /*tx*/
      ctx[0].vbytes) + "";
      let t6;
      let t7;
      let t8;
      let t9;
      let p2;
      let t10;
      let t11_value =
      /*formatBTC*/
      ctx[8](
      /*tx*/
      ctx[0].value) + "";
      let t11;
      let t12;
      let current;
      let mounted;
      let dispose;
      icon = new Icon({
        props: {
          icon: BookmarkIcon
        },
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*inputCount*/
        ctx[5] &&
        /*outputCount*/
        ctx[6] && !
        /*tx*/
        ctx[0].coinbase) return create_if_block_3$6;
        if (
        /*tx*/
        ctx[0].coinbase) return create_if_block_6$4;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type && current_block_type(ctx);

      function select_block_type_2(ctx, dirty) {
        if (!
        /*tx*/
        ctx[0].coinbase &&
        /*tx*/
        ctx[0].fee != null) return create_if_block_1$b;
        if (!
        /*tx*/
        ctx[0].coinbase &&
        /*tx*/
        ctx[0].fee == null) return create_if_block_2$8;
      }

      let current_block_type_1 = select_block_type_2(ctx);
      let if_block1 = current_block_type_1 && current_block_type_1(ctx);
      let if_block2 =
      /*formattedLocalValue*/
      ctx[4] != null && create_if_block$l(ctx);
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          create_component(icon.$$.fragment);
          t0 = space();
          p0 = element("p");
          t1 = text("TxID: ");
          t2 = text(t2_value);
          t3 = space();
          if (if_block0) if_block0.c();
          t4 = space();
          p1 = element("p");
          t5 = text("Size: ");
          t6 = text(t6_value);
          t7 = text(" vbytes");
          t8 = space();
          if (if_block1) if_block1.c();
          t9 = space();
          p2 = element("p");
          t10 = text("Total value: ");
          t11 = text(t11_value);
          t12 = space();
          if (if_block2) if_block2.c();
          attr_dev(div0, "class", "icon-button svelte-1absxd3");
          attr_dev(div0, "title", "Add to watchlist");
          toggle_class(div0, "disabled",
          /*$highlightingFull*/
          ctx[7]);
          add_location(div0, file$x, 129, 2, 2910);
          attr_dev(p0, "class", "field hash svelte-1absxd3");
          add_location(p0, file$x, 132, 2, 3060);
          attr_dev(p1, "class", "field vbytes svelte-1absxd3");
          add_location(p1, file$x, 149, 2, 3681);
          attr_dev(p2, "class", "field value svelte-1absxd3");
          add_location(p2, file$x, 157, 2, 4124);
          attr_dev(div1, "class", "tx-info svelte-1absxd3");
          set_style(div1, "left",
          /*clampedX*/
          ctx[1] + "px");
          set_style(div1, "top",
          /*clampedY*/
          ctx[2] + "px");
          toggle_class(div1, "above",
          /*above*/
          ctx[3]);
          add_location(div1, file$x, 128, 0, 2828);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          mount_component(icon, div0, null);
          append_dev(div1, t0);
          append_dev(div1, p0);
          append_dev(p0, t1);
          append_dev(p0, t2);
          append_dev(div1, t3);
          if (if_block0) if_block0.m(div1, null);
          append_dev(div1, t4);
          append_dev(div1, p1);
          append_dev(p1, t5);
          append_dev(p1, t6);
          append_dev(p1, t7);
          append_dev(div1, t8);
          if (if_block1) if_block1.m(div1, null);
          append_dev(div1, t9);
          append_dev(div1, p2);
          append_dev(p2, t10);
          append_dev(p2, t11);
          append_dev(p2, t12);
          if (if_block2) if_block2.m(p2, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*highlight*/
            ctx[9], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*$highlightingFull*/
          128) {
            toggle_class(div0, "disabled",
            /*$highlightingFull*/
            ctx[7]);
          }

          if ((!current || dirty &
          /*tx*/
          1) && t2_value !== (t2_value =
          /*tx*/
          ctx[0].id + "")) set_data_dev(t2, t2_value);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if (if_block0) if_block0.d(1);
            if_block0 = current_block_type && current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div1, t4);
            }
          }

          if ((!current || dirty &
          /*tx*/
          1) && t6_value !== (t6_value = numberFormat.format(
          /*tx*/
          ctx[0].vbytes) + "")) set_data_dev(t6, t6_value);

          if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if (if_block1) if_block1.d(1);
            if_block1 = current_block_type_1 && current_block_type_1(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(div1, t9);
            }
          }

          if ((!current || dirty &
          /*tx*/
          1) && t11_value !== (t11_value =
          /*formatBTC*/
          ctx[8](
          /*tx*/
          ctx[0].value) + "")) set_data_dev(t11, t11_value);

          if (
          /*formattedLocalValue*/
          ctx[4] != null) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
            } else {
              if_block2 = create_if_block$l(ctx);
              if_block2.c();
              if_block2.m(p2, null);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if (!current || dirty &
          /*clampedX*/
          2) {
            set_style(div1, "left",
            /*clampedX*/
            ctx[1] + "px");
          }

          if (!current || dirty &
          /*clampedY*/
          4) {
            set_style(div1, "top",
            /*clampedY*/
            ctx[2] + "px");
          }

          if (dirty &
          /*above*/
          8) {
            toggle_class(div1, "above",
            /*above*/
            ctx[3]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(icon);

          if (if_block0) {
            if_block0.d();
          }

          if (if_block1) {
            if_block1.d();
          }

          if (if_block2) if_block2.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$z.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
      let $sidebarToggle;
      let $newHighlightQuery;
      let $highlightingFull;
      let $settings;
      let $exchangeRates;
      validate_store(sidebarToggle, 'sidebarToggle');
      component_subscribe($$self, sidebarToggle, $$value => $$invalidate(13, $sidebarToggle = $$value));
      validate_store(newHighlightQuery, 'newHighlightQuery');
      component_subscribe($$self, newHighlightQuery, $$value => $$invalidate(14, $newHighlightQuery = $$value));
      validate_store(highlightingFull, 'highlightingFull');
      component_subscribe($$self, highlightingFull, $$value => $$invalidate(7, $highlightingFull = $$value));
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(11, $settings = $$value));
      validate_store(exchangeRates, 'exchangeRates');
      component_subscribe($$self, exchangeRates, $$value => $$invalidate(12, $exchangeRates = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('TxInfo', slots, []);
      let {
        tx
      } = $$props;
      let {
        position
      } = $$props;
      let clampedX;
      let clampedY;
      let above = false;
      let formattedLocalValue;
      let inputCount;
      let outputCount;

      function formatBTC(sats) {
        return `₿ ${longBtcFormat.format(sats / 100000000)}`;
      }

      function highlight() {
        if (!$highlightingFull && tx && tx.id) {
          set_store_value(newHighlightQuery, $newHighlightQuery = tx.id, $newHighlightQuery);
          set_store_value(sidebarToggle, $sidebarToggle = 'search', $sidebarToggle);
        }
      }

      const writable_props = ['tx', 'position'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TxInfo> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('tx' in $$props) $$invalidate(0, tx = $$props.tx);
        if ('position' in $$props) $$invalidate(10, position = $$props.position);
      };

      $$self.$capture_state = () => ({
        Icon,
        BookmarkIcon,
        longBtcFormat,
        numberFormat,
        feeRateFormat,
        exchangeRates,
        settings,
        sidebarToggle,
        newHighlightQuery,
        highlightingFull,
        formatCurrency,
        tx,
        position,
        clampedX,
        clampedY,
        above,
        formattedLocalValue,
        inputCount,
        outputCount,
        formatBTC,
        highlight,
        $sidebarToggle,
        $newHighlightQuery,
        $highlightingFull,
        $settings,
        $exchangeRates
      });

      $$self.$inject_state = $$props => {
        if ('tx' in $$props) $$invalidate(0, tx = $$props.tx);
        if ('position' in $$props) $$invalidate(10, position = $$props.position);
        if ('clampedX' in $$props) $$invalidate(1, clampedX = $$props.clampedX);
        if ('clampedY' in $$props) $$invalidate(2, clampedY = $$props.clampedY);
        if ('above' in $$props) $$invalidate(3, above = $$props.above);
        if ('formattedLocalValue' in $$props) $$invalidate(4, formattedLocalValue = $$props.formattedLocalValue);
        if ('inputCount' in $$props) $$invalidate(5, inputCount = $$props.inputCount);
        if ('outputCount' in $$props) $$invalidate(6, outputCount = $$props.outputCount);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*position*/
        1024) {
          $$invalidate(1, clampedX = Math.max(20, Math.min(position.x - 30, window.innerWidth - 300)));
        }

        if ($$self.$$.dirty &
        /*position*/
        1024) {
          $$invalidate(2, clampedY = Math.max(50, Math.min(position.y, window.innerHeight - 30)));
        }

        if ($$self.$$.dirty &
        /*position*/
        1024) {
          {
            $$invalidate(3, above = position.y > window.innerHeight / 2);
          }
        }

        if ($$self.$$.dirty &
        /*tx, $exchangeRates, $settings*/
        6145) {
          {
            if (tx && tx.value) {
              const rate = $exchangeRates[$settings.currency];

              if (rate && rate.last) {
                $$invalidate(4, formattedLocalValue = formatCurrency($settings.currency, tx.value / 100000000 * rate.last, {
                  compact: true
                }));
              } else {
                $$invalidate(4, formattedLocalValue = null);
              }
            }
          }
        }

        if ($$self.$$.dirty &
        /*tx*/
        1) {
          {
            if (tx) {
              if (tx.inputs) $$invalidate(5, inputCount = tx.inputs.length);else $$invalidate(5, inputCount = tx.numInputs || 0);
              if (tx.outputs) $$invalidate(6, outputCount = tx.outputs.length);else $$invalidate(6, outputCount = tx.numOutputs || 0);
            }
          }
        }
      };

      return [tx, clampedX, clampedY, above, formattedLocalValue, inputCount, outputCount, $highlightingFull, formatBTC, highlight, position, $settings, $exchangeRates];
    }

    class TxInfo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$z, create_fragment$z, safe_not_equal, {
          tx: 0,
          position: 10
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TxInfo",
          options,
          id: create_fragment$z.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*tx*/
        ctx[0] === undefined && !('tx' in props)) {
          console.warn("<TxInfo> was created without expected prop 'tx'");
        }

        if (
        /*position*/
        ctx[10] === undefined && !('position' in props)) {
          console.warn("<TxInfo> was created without expected prop 'position'");
        }
      }

      get tx() {
        throw new Error("<TxInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set tx(value) {
        throw new Error("<TxInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get position() {
        throw new Error("<TxInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set position(value) {
        throw new Error("<TxInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/SidebarTab.svelte generated by Svelte v3.44.3 */
    const file$w = "src/components/SidebarTab.svelte";

    const get_content_slot_changes = dirty => ({});

    const get_content_slot_context = ctx => ({});

    const get_tab_slot_changes = dirty => ({});

    const get_tab_slot_context = ctx => ({}); // (107:21)        ??     


    function fallback_block$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("??");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block$2.name,
        type: "fallback",
        source: "(107:21)        ??     ",
        ctx
      });
      return block;
    }

    function create_fragment$y(ctx) {
      let div2;
      let button;
      let t;
      let div1;
      let div0;
      let div2_transition;
      let current;
      let mounted;
      let dispose;
      const tab_slot_template =
      /*#slots*/
      ctx[7].tab;
      const tab_slot = create_slot(tab_slot_template, ctx,
      /*$$scope*/
      ctx[6], get_tab_slot_context);
      const tab_slot_or_fallback = tab_slot || fallback_block$2(ctx);
      const content_slot_template =
      /*#slots*/
      ctx[7].content;
      const content_slot = create_slot(content_slot_template, ctx,
      /*$$scope*/
      ctx[6], get_content_slot_context);
      const block = {
        c: function create() {
          div2 = element("div");
          button = element("button");
          if (tab_slot_or_fallback) tab_slot_or_fallback.c();
          t = space();
          div1 = element("div");
          div0 = element("div");
          if (content_slot) content_slot.c();
          attr_dev(button, "class", "tab-button svelte-zd8dxp");
          attr_dev(button, "title",
          /*tooltip*/
          ctx[1]);
          add_location(button, file$w, 105, 2, 2106);
          attr_dev(div0, "class", "inner-content");
          add_location(div0, file$w, 112, 4, 2278);
          attr_dev(div1, "class", "sidebar-content svelte-zd8dxp");
          add_location(div1, file$w, 111, 2, 2217);
          attr_dev(div2, "class", "sidebar-tab svelte-zd8dxp");
          toggle_class(div2, "open",
          /*open*/
          ctx[0]);
          toggle_class(div2, "active",
          /*entered*/
          ctx[2]);
          add_location(div2, file$w, 99, 0, 1985);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, button);

          if (tab_slot_or_fallback) {
            tab_slot_or_fallback.m(button, null);
          }

          append_dev(div2, t);
          append_dev(div2, div1);
          append_dev(div1, div0);

          if (content_slot) {
            content_slot.m(div0, null);
          }
          /*div0_binding*/


          ctx[9](div0);
          /*div1_binding*/

          ctx[10](div1);
          current = true;

          if (!mounted) {
            dispose = listen_dev(button, "click",
            /*click_handler*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (tab_slot) {
            if (tab_slot.p && (!current || dirty &
            /*$$scope*/
            64)) {
              update_slot_base(tab_slot, tab_slot_template, ctx,
              /*$$scope*/
              ctx[6], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[6]) : get_slot_changes(tab_slot_template,
              /*$$scope*/
              ctx[6], dirty, get_tab_slot_changes), get_tab_slot_context);
            }
          }

          if (!current || dirty &
          /*tooltip*/
          2) {
            attr_dev(button, "title",
            /*tooltip*/
            ctx[1]);
          }

          if (content_slot) {
            if (content_slot.p && (!current || dirty &
            /*$$scope*/
            64)) {
              update_slot_base(content_slot, content_slot_template, ctx,
              /*$$scope*/
              ctx[6], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[6]) : get_slot_changes(content_slot_template,
              /*$$scope*/
              ctx[6], dirty, get_content_slot_changes), get_content_slot_context);
            }
          }

          if (dirty &
          /*open*/
          1) {
            toggle_class(div2, "open",
            /*open*/
            ctx[0]);
          }

          if (dirty &
          /*entered*/
          4) {
            toggle_class(div2, "active",
            /*entered*/
            ctx[2]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tab_slot_or_fallback, local);
          transition_in(content_slot, local);
          add_render_callback(() => {
            if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
              x: 30,
              duration: 1000
            }, true);
            div2_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(tab_slot_or_fallback, local);
          transition_out(content_slot, local);
          if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
            x: 30,
            duration: 1000
          }, false);
          div2_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          if (tab_slot_or_fallback) tab_slot_or_fallback.d(detaching);
          if (content_slot) content_slot.d(detaching);
          /*div0_binding*/

          ctx[9](null);
          /*div1_binding*/

          ctx[10](null);
          if (detaching && div2_transition) div2_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$y.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SidebarTab', slots, ['tab', 'content']);
      let {
        open = false
      } = $$props;
      let {
        tooltip = null
      } = $$props;
      let entered = false;
      let contentElement;
      let contentSlotElement;

      async function updateContentHeight(isOpen) {
        if (contentElement && contentSlotElement) {
          if (isOpen) {
            $$invalidate(3, contentElement.style.height = `${contentSlotElement.clientHeight}px`, contentElement);
          } else if (contentElement) {
            $$invalidate(3, contentElement.style.height = null, contentElement);
          }
        }
      }

      function afterEnter() {
        $$invalidate(2, entered = true);
      }

      function beforeExit() {
        $$invalidate(2, entered = false);
      }

      const writable_props = ['open', 'tooltip'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SidebarTab> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble.call(this, $$self, event);
      }

      function div0_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          contentSlotElement = $$value;
          $$invalidate(4, contentSlotElement);
        });
      }

      function div1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          contentElement = $$value;
          $$invalidate(3, contentElement);
        });
      }

      $$self.$$set = $$props => {
        if ('open' in $$props) $$invalidate(0, open = $$props.open);
        if ('tooltip' in $$props) $$invalidate(1, tooltip = $$props.tooltip);
        if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        tick,
        fly,
        open,
        tooltip,
        entered,
        contentElement,
        contentSlotElement,
        updateContentHeight,
        afterEnter,
        beforeExit
      });

      $$self.$inject_state = $$props => {
        if ('open' in $$props) $$invalidate(0, open = $$props.open);
        if ('tooltip' in $$props) $$invalidate(1, tooltip = $$props.tooltip);
        if ('entered' in $$props) $$invalidate(2, entered = $$props.entered);
        if ('contentElement' in $$props) $$invalidate(3, contentElement = $$props.contentElement);
        if ('contentSlotElement' in $$props) $$invalidate(4, contentSlotElement = $$props.contentSlotElement);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*open*/
        1) {
          updateContentHeight(open);
        }

        if ($$self.$$.dirty &
        /*open*/
        1) {
          {
            if (open) setTimeout(afterEnter, 400);else beforeExit();
          }
        }
      };

      return [open, tooltip, entered, contentElement, contentSlotElement, updateContentHeight, $$scope, slots, click_handler, div0_binding, div1_binding];
    }

    class SidebarTab extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$y, create_fragment$y, safe_not_equal, {
          open: 0,
          tooltip: 1,
          updateContentHeight: 5
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SidebarTab",
          options,
          id: create_fragment$y.name
        });
      }

      get open() {
        throw new Error("<SidebarTab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set open(value) {
        throw new Error("<SidebarTab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get tooltip() {
        throw new Error("<SidebarTab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set tooltip(value) {
        throw new Error("<SidebarTab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get updateContentHeight() {
        return this.$$.ctx[5];
      }

      set updateContentHeight(value) {
        throw new Error("<SidebarTab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/util/Toggle.svelte generated by Svelte v3.44.3 */
    const file$v = "src/components/util/Toggle.svelte";

    function create_fragment$x(ctx) {
      let div2;
      let div1;
      let div0;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div2 = element("div");
          div1 = element("div");
          div0 = element("div");
          attr_dev(div0, "class", "handle svelte-249i4e");
          add_location(div0, file$v, 7, 4, 117);
          attr_dev(div1, "class", "track svelte-249i4e");
          add_location(div1, file$v, 6, 2, 93);
          attr_dev(div2, "class", "toggle svelte-249i4e");
          toggle_class(div2, "active",
          /*active*/
          ctx[0]);
          add_location(div2, file$v, 5, 0, 39);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div1);
          append_dev(div1, div0);

          if (!mounted) {
            dispose = listen_dev(div2, "click",
            /*click_handler*/
            ctx[1], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*active*/
          1) {
            toggle_class(div2, "active",
            /*active*/
            ctx[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$x.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Toggle', slots, []);
      let {
        active
      } = $$props;
      const writable_props = ['active'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggle> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble.call(this, $$self, event);
      }

      $$self.$$set = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
      };

      $$self.$capture_state = () => ({
        active
      });

      $$self.$inject_state = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [active, click_handler];
    }

    class Toggle extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$x, create_fragment$x, safe_not_equal, {
          active: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Toggle",
          options,
          id: create_fragment$x.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*active*/
        ctx[0] === undefined && !('active' in props)) {
          console.warn("<Toggle> was created without expected prop 'active'");
        }
      }

      get active() {
        throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set active(value) {
        throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/util/Pill.svelte generated by Svelte v3.44.3 */
    const file$u = "src/components/util/Pill.svelte";

    const get_right_slot_changes = dirty => ({});

    const get_right_slot_context = ctx => ({});

    const get_left_slot_changes = dirty => ({});

    const get_left_slot_context = ctx => ({}); // (11:2) {#if !leftDisabled}


    function create_if_block_1$a(ctx) {
      let span;
      let current;
      const left_slot_template =
      /*#slots*/
      ctx[6].left;
      const left_slot = create_slot(left_slot_template, ctx,
      /*$$scope*/
      ctx[5], get_left_slot_context);
      const left_slot_or_fallback = left_slot || fallback_block_1(ctx);
      const block = {
        c: function create() {
          span = element("span");
          if (left_slot_or_fallback) left_slot_or_fallback.c();
          attr_dev(span, "class", "side left svelte-1ib28qa");
          toggle_class(span, "selected", !
          /*active*/
          ctx[0]);
          add_location(span, file$u, 11, 4, 213);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);

          if (left_slot_or_fallback) {
            left_slot_or_fallback.m(span, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (left_slot) {
            if (left_slot.p && (!current || dirty &
            /*$$scope*/
            32)) {
              update_slot_base(left_slot, left_slot_template, ctx,
              /*$$scope*/
              ctx[5], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[5]) : get_slot_changes(left_slot_template,
              /*$$scope*/
              ctx[5], dirty, get_left_slot_changes), get_left_slot_context);
            }
          } else {
            if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty &
            /*left*/
            2)) {
              left_slot_or_fallback.p(ctx, !current ? -1 : dirty);
            }
          }

          if (dirty &
          /*active*/
          1) {
            toggle_class(span, "selected", !
            /*active*/
            ctx[0]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(left_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(left_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (left_slot_or_fallback) left_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$a.name,
        type: "if",
        source: "(11:2) {#if !leftDisabled}",
        ctx
      });
      return block;
    } // (12:71) { left }


    function fallback_block_1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text(
          /*left*/
          ctx[1]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*left*/
          2) set_data_dev(t,
          /*left*/
          ctx[1]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block_1.name,
        type: "fallback",
        source: "(12:71) { left }",
        ctx
      });
      return block;
    } // (14:2) {#if !rightDisabled}


    function create_if_block$k(ctx) {
      let span;
      let current;
      const right_slot_template =
      /*#slots*/
      ctx[6].right;
      const right_slot = create_slot(right_slot_template, ctx,
      /*$$scope*/
      ctx[5], get_right_slot_context);
      const right_slot_or_fallback = right_slot || fallback_block$1(ctx);
      const block = {
        c: function create() {
          span = element("span");
          if (right_slot_or_fallback) right_slot_or_fallback.c();
          attr_dev(span, "class", "side right svelte-1ib28qa");
          toggle_class(span, "selected",
          /*active*/
          ctx[0]);
          add_location(span, file$u, 14, 4, 338);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);

          if (right_slot_or_fallback) {
            right_slot_or_fallback.m(span, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (right_slot) {
            if (right_slot.p && (!current || dirty &
            /*$$scope*/
            32)) {
              update_slot_base(right_slot, right_slot_template, ctx,
              /*$$scope*/
              ctx[5], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[5]) : get_slot_changes(right_slot_template,
              /*$$scope*/
              ctx[5], dirty, get_right_slot_changes), get_right_slot_context);
            }
          } else {
            if (right_slot_or_fallback && right_slot_or_fallback.p && (!current || dirty &
            /*right*/
            4)) {
              right_slot_or_fallback.p(ctx, !current ? -1 : dirty);
            }
          }

          if (dirty &
          /*active*/
          1) {
            toggle_class(span, "selected",
            /*active*/
            ctx[0]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(right_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(right_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (right_slot_or_fallback) right_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$k.name,
        type: "if",
        source: "(14:2) {#if !rightDisabled}",
        ctx
      });
      return block;
    } // (15:72) { right }


    function fallback_block$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text(
          /*right*/
          ctx[2]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*right*/
          4) set_data_dev(t,
          /*right*/
          ctx[2]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block$1.name,
        type: "fallback",
        source: "(15:72) { right }",
        ctx
      });
      return block;
    }

    function create_fragment$w(ctx) {
      let div;
      let t;
      let current;
      let mounted;
      let dispose;
      let if_block0 = !
      /*leftDisabled*/
      ctx[3] && create_if_block_1$a(ctx);
      let if_block1 = !
      /*rightDisabled*/
      ctx[4] && create_if_block$k(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block0) if_block0.c();
          t = space();
          if (if_block1) if_block1.c();
          attr_dev(div, "class", "pill svelte-1ib28qa");
          toggle_class(div, "active",
          /*active*/
          ctx[0]);
          add_location(div, file$u, 9, 0, 137);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t);
          if (if_block1) if_block1.m(div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*click_handler*/
            ctx[7], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (!
          /*leftDisabled*/
          ctx[3]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*leftDisabled*/
              8) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_1$a(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (!
          /*rightDisabled*/
          ctx[4]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*rightDisabled*/
              16) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$k(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (dirty &
          /*active*/
          1) {
            toggle_class(div, "active",
            /*active*/
            ctx[0]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$w.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Pill', slots, ['left', 'right']);
      let {
        active
      } = $$props;
      let {
        left
      } = $$props;
      let {
        right
      } = $$props;
      let {
        leftDisabled = false
      } = $$props;
      let {
        rightDisabled = false
      } = $$props;
      const writable_props = ['active', 'left', 'right', 'leftDisabled', 'rightDisabled'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pill> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble.call(this, $$self, event);
      }

      $$self.$$set = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
        if ('left' in $$props) $$invalidate(1, left = $$props.left);
        if ('right' in $$props) $$invalidate(2, right = $$props.right);
        if ('leftDisabled' in $$props) $$invalidate(3, leftDisabled = $$props.leftDisabled);
        if ('rightDisabled' in $$props) $$invalidate(4, rightDisabled = $$props.rightDisabled);
        if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        active,
        left,
        right,
        leftDisabled,
        rightDisabled
      });

      $$self.$inject_state = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
        if ('left' in $$props) $$invalidate(1, left = $$props.left);
        if ('right' in $$props) $$invalidate(2, right = $$props.right);
        if ('leftDisabled' in $$props) $$invalidate(3, leftDisabled = $$props.leftDisabled);
        if ('rightDisabled' in $$props) $$invalidate(4, rightDisabled = $$props.rightDisabled);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [active, left, right, leftDisabled, rightDisabled, $$scope, slots, click_handler];
    }

    class Pill extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$w, create_fragment$w, safe_not_equal, {
          active: 0,
          left: 1,
          right: 2,
          leftDisabled: 3,
          rightDisabled: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Pill",
          options,
          id: create_fragment$w.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*active*/
        ctx[0] === undefined && !('active' in props)) {
          console.warn("<Pill> was created without expected prop 'active'");
        }

        if (
        /*left*/
        ctx[1] === undefined && !('left' in props)) {
          console.warn("<Pill> was created without expected prop 'left'");
        }

        if (
        /*right*/
        ctx[2] === undefined && !('right' in props)) {
          console.warn("<Pill> was created without expected prop 'right'");
        }
      }

      get active() {
        throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set active(value) {
        throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get left() {
        throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set left(value) {
        throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get right() {
        throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set right(value) {
        throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get leftDisabled() {
        throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set leftDisabled(value) {
        throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get rightDisabled() {
        throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set rightDisabled(value) {
        throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    function isOutOfViewport (parent, container) {
      const parentBounding = parent.getBoundingClientRect();
      const boundingContainer = container.getBoundingClientRect();
      const out = {};
      out.top = parentBounding.top < 0;
      out.left = parentBounding.left < 0;
      out.bottom = parentBounding.bottom + boundingContainer.height > (window.innerHeight || document.documentElement.clientHeight);
      out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;
      return out;
    }

    /* node_modules/svelte-select/src/Item.svelte generated by Svelte v3.44.3 */
    const file$t = "node_modules/svelte-select/src/Item.svelte";

    function create_fragment$v(ctx) {
      let div;
      let raw_value =
      /*getOptionLabel*/
      ctx[0](
      /*item*/
      ctx[1],
      /*filterText*/
      ctx[2]) + "";
      let div_class_value;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", div_class_value = "item " +
          /*itemClasses*/
          ctx[3] + " svelte-3e0qet");
          add_location(div, file$t, 78, 0, 1837);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          div.innerHTML = raw_value;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*getOptionLabel, item, filterText*/
          7 && raw_value !== (raw_value =
          /*getOptionLabel*/
          ctx[0](
          /*item*/
          ctx[1],
          /*filterText*/
          ctx[2]) + "")) div.innerHTML = raw_value;

          if (dirty &
          /*itemClasses*/
          8 && div_class_value !== (div_class_value = "item " +
          /*itemClasses*/
          ctx[3] + " svelte-3e0qet")) {
            attr_dev(div, "class", div_class_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$v.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Item', slots, []);
      let {
        isActive = false
      } = $$props;
      let {
        isFirst = false
      } = $$props;
      let {
        isHover = false
      } = $$props;
      let {
        isSelectable = false
      } = $$props;
      let {
        getOptionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let itemClasses = '';
      const writable_props = ['isActive', 'isFirst', 'isHover', 'isSelectable', 'getOptionLabel', 'item', 'filterText'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Item> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
        if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
        if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
        if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
        if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
        if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
      };

      $$self.$capture_state = () => ({
        isActive,
        isFirst,
        isHover,
        isSelectable,
        getOptionLabel,
        item,
        filterText,
        itemClasses
      });

      $$self.$inject_state = $$props => {
        if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
        if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
        if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
        if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
        if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
        if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
        if ('itemClasses' in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*isActive, isFirst, isHover, item, isSelectable*/
        242) {
          {
            const classes = [];

            if (isActive) {
              classes.push('active');
            }

            if (isFirst) {
              classes.push('first');
            }

            if (isHover) {
              classes.push('hover');
            }

            if (item.isGroupHeader) {
              classes.push('groupHeader');
            }

            if (item.isGroupItem) {
              classes.push('groupItem');
            }

            if (!isSelectable) {
              classes.push('notSelectable');
            }

            $$invalidate(3, itemClasses = classes.join(' '));
          }
        }
      };

      return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover, isSelectable];
    }

    class Item extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$v, create_fragment$v, safe_not_equal, {
          isActive: 4,
          isFirst: 5,
          isHover: 6,
          isSelectable: 7,
          getOptionLabel: 0,
          item: 1,
          filterText: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Item",
          options,
          id: create_fragment$v.name
        });
      }

      get isActive() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isActive(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isFirst() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isFirst(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isHover() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isHover(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isSelectable() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isSelectable(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getOptionLabel() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getOptionLabel(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get item() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set item(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get filterText() {
        throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set filterText(value) {
        throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules/svelte-select/src/List.svelte generated by Svelte v3.44.3 */
    const file$s = "node_modules/svelte-select/src/List.svelte";

    function get_each_context$c(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[41] = list[i];
      child_ctx[42] = i;
      return child_ctx;
    } // (309:4) {:else}


    function create_else_block$b(ctx) {
      let each_1_anchor;
      let current;
      let each_value =
      /*items*/
      ctx[1];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      let each_1_else = null;

      if (!each_value.length) {
        each_1_else = create_else_block_2$3(ctx);
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();

          if (each_1_else) {
            each_1_else.c();
          }
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);

          if (each_1_else) {
            each_1_else.m(target, anchor);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/
          114390) {
            each_value =
            /*items*/
            ctx[1];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$c(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$c(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();

            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block_2$3(ctx);
              each_1_else.c();
              each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
            } else if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
          if (each_1_else) each_1_else.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$b.name,
        type: "else",
        source: "(309:4) {:else}",
        ctx
      });
      return block;
    } // (286:4) {#if isVirtualList}


    function create_if_block$j(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value =
      /*VirtualList*/
      ctx[3];

      function switch_props(ctx) {
        return {
          props: {
            items:
            /*items*/
            ctx[1],
            itemHeight:
            /*itemHeight*/
            ctx[8],
            $$slots: {
              default: [create_default_slot$5, _ref => {
                let {
                  item,
                  i
                } = _ref;
                return {
                  41: item,
                  42: i
                };
              }, _ref2 => {
                let {
                  item,
                  i
                } = _ref2;
                return [0, (item ? 1024 : 0) | (i ? 2048 : 0)];
              }]
            },
            $$scope: {
              ctx
            }
          },
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.items =
          /*items*/
          ctx[1];
          if (dirty[0] &
          /*itemHeight*/
          256) switch_instance_changes.itemHeight =
          /*itemHeight*/
          ctx[8];

          if (dirty[0] &
          /*Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, items*/
          9814 | dirty[1] &
          /*$$scope, item, i*/
          11264) {
            switch_instance_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (switch_value !== (switch_value =
          /*VirtualList*/
          ctx[3])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$j.name,
        type: "if",
        source: "(286:4) {#if isVirtualList}",
        ctx
      });
      return block;
    } // (331:8) {:else}


    function create_else_block_2$3(ctx) {
      let if_block_anchor;
      let if_block = !
      /*hideEmptyState*/
      ctx[11] && create_if_block_2$7(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (!
          /*hideEmptyState*/
          ctx[11]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2$7(ctx);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$3.name,
        type: "else",
        source: "(331:8) {:else}",
        ctx
      });
      return block;
    } // (332:12) {#if !hideEmptyState}


    function create_if_block_2$7(ctx) {
      let div;
      let t;
      const block = {
        c: function create() {
          div = element("div");
          t = text(
          /*noOptionsMessage*/
          ctx[12]);
          attr_dev(div, "class", "empty svelte-1uyqfml");
          add_location(div, file$s, 332, 16, 10333);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*noOptionsMessage*/
          4096) set_data_dev(t,
          /*noOptionsMessage*/
          ctx[12]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$7.name,
        type: "if",
        source: "(332:12) {#if !hideEmptyState}",
        ctx
      });
      return block;
    } // (313:12) {:else}


    function create_else_block_1$4(ctx) {
      let div;
      let switch_instance;
      let t;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Item*/
      ctx[4];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*item*/
            ctx[41],
            filterText:
            /*filterText*/
            ctx[13],
            getOptionLabel:
            /*getOptionLabel*/
            ctx[6],
            isFirst: isItemFirst(
            /*i*/
            ctx[42]),
            isActive: isItemActive(
            /*item*/
            ctx[41],
            /*value*/
            ctx[9],
            /*optionIdentifier*/
            ctx[10]),
            isHover: isItemHover(
            /*hoverItemIndex*/
            ctx[2],
            /*item*/
            ctx[41],
            /*i*/
            ctx[42],
            /*items*/
            ctx[1]),
            isSelectable: isItemSelectable(
            /*item*/
            ctx[41])
          },
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      function mouseover_handler_1() {
        return (
          /*mouseover_handler_1*/
          ctx[29](
          /*i*/
          ctx[42])
        );
      }

      function focus_handler_1() {
        return (
          /*focus_handler_1*/
          ctx[30](
          /*i*/
          ctx[42])
        );
      }

      function click_handler_1() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (
          /*click_handler_1*/
          ctx[31](
          /*item*/
          ctx[41],
          /*i*/
          ctx[42], ...args)
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          t = space();
          attr_dev(div, "class", "listItem");
          attr_dev(div, "tabindex", "-1");
          add_location(div, file$s, 313, 16, 9513);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          append_dev(div, t);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(div, "mouseover", mouseover_handler_1, false, false, false), listen_dev(div, "focus", focus_handler_1, false, false, false), listen_dev(div, "click", click_handler_1, false, false, false)];
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const switch_instance_changes = {};
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.item =
          /*item*/
          ctx[41];
          if (dirty[0] &
          /*filterText*/
          8192) switch_instance_changes.filterText =
          /*filterText*/
          ctx[13];
          if (dirty[0] &
          /*getOptionLabel*/
          64) switch_instance_changes.getOptionLabel =
          /*getOptionLabel*/
          ctx[6];
          if (dirty[0] &
          /*items, value, optionIdentifier*/
          1538) switch_instance_changes.isActive = isItemActive(
          /*item*/
          ctx[41],
          /*value*/
          ctx[9],
          /*optionIdentifier*/
          ctx[10]);
          if (dirty[0] &
          /*hoverItemIndex, items*/
          6) switch_instance_changes.isHover = isItemHover(
          /*hoverItemIndex*/
          ctx[2],
          /*item*/
          ctx[41],
          /*i*/
          ctx[42],
          /*items*/
          ctx[1]);
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.isSelectable = isItemSelectable(
          /*item*/
          ctx[41]);

          if (switch_value !== (switch_value =
          /*Item*/
          ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, t);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$4.name,
        type: "else",
        source: "(313:12) {:else}",
        ctx
      });
      return block;
    } // (311:12) {#if item.isGroupHeader && !item.isSelectable}


    function create_if_block_1$9(ctx) {
      let div;
      let t_value =
      /*getGroupHeaderLabel*/
      ctx[7](
      /*item*/
      ctx[41]) + "";
      let t;
      const block = {
        c: function create() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "listGroupTitle svelte-1uyqfml");
          add_location(div, file$s, 311, 16, 9415);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*getGroupHeaderLabel, items*/
          130 && t_value !== (t_value =
          /*getGroupHeaderLabel*/
          ctx[7](
          /*item*/
          ctx[41]) + "")) set_data_dev(t, t_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$9.name,
        type: "if",
        source: "(311:12) {#if item.isGroupHeader && !item.isSelectable}",
        ctx
      });
      return block;
    } // (310:8) {#each items as item, i}


    function create_each_block$c(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_1$9, create_else_block_1$4];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (
        /*item*/
        ctx[41].isGroupHeader && !
        /*item*/
        ctx[41].isSelectable) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$c.name,
        type: "each",
        source: "(310:8) {#each items as item, i}",
        ctx
      });
      return block;
    } // (287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>


    function create_default_slot$5(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Item*/
      ctx[4];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*item*/
            ctx[41],
            filterText:
            /*filterText*/
            ctx[13],
            getOptionLabel:
            /*getOptionLabel*/
            ctx[6],
            isFirst: isItemFirst(
            /*i*/
            ctx[42]),
            isActive: isItemActive(
            /*item*/
            ctx[41],
            /*value*/
            ctx[9],
            /*optionIdentifier*/
            ctx[10]),
            isHover: isItemHover(
            /*hoverItemIndex*/
            ctx[2],
            /*item*/
            ctx[41],
            /*i*/
            ctx[42],
            /*items*/
            ctx[1]),
            isSelectable: isItemSelectable(
            /*item*/
            ctx[41])
          },
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      function mouseover_handler() {
        return (
          /*mouseover_handler*/
          ctx[26](
          /*i*/
          ctx[42])
        );
      }

      function focus_handler() {
        return (
          /*focus_handler*/
          ctx[27](
          /*i*/
          ctx[42])
        );
      }

      function click_handler() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return (
          /*click_handler*/
          ctx[28](
          /*item*/
          ctx[41],
          /*i*/
          ctx[42], ...args)
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(div, "class", "listItem");
          add_location(div, file$s, 292, 12, 8621);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = [listen_dev(div, "mouseover", mouseover_handler, false, false, false), listen_dev(div, "focus", focus_handler, false, false, false), listen_dev(div, "click", click_handler, false, false, false)];
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const switch_instance_changes = {};
          if (dirty[1] &
          /*item*/
          1024) switch_instance_changes.item =
          /*item*/
          ctx[41];
          if (dirty[0] &
          /*filterText*/
          8192) switch_instance_changes.filterText =
          /*filterText*/
          ctx[13];
          if (dirty[0] &
          /*getOptionLabel*/
          64) switch_instance_changes.getOptionLabel =
          /*getOptionLabel*/
          ctx[6];
          if (dirty[1] &
          /*i*/
          2048) switch_instance_changes.isFirst = isItemFirst(
          /*i*/
          ctx[42]);
          if (dirty[0] &
          /*value, optionIdentifier*/
          1536 | dirty[1] &
          /*item*/
          1024) switch_instance_changes.isActive = isItemActive(
          /*item*/
          ctx[41],
          /*value*/
          ctx[9],
          /*optionIdentifier*/
          ctx[10]);
          if (dirty[0] &
          /*hoverItemIndex, items*/
          6 | dirty[1] &
          /*item, i*/
          3072) switch_instance_changes.isHover = isItemHover(
          /*hoverItemIndex*/
          ctx[2],
          /*item*/
          ctx[41],
          /*i*/
          ctx[42],
          /*items*/
          ctx[1]);
          if (dirty[1] &
          /*item*/
          1024) switch_instance_changes.isSelectable = isItemSelectable(
          /*item*/
          ctx[41]);

          if (switch_value !== (switch_value =
          /*Item*/
          ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$5.name,
        type: "slot",
        source: "(287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>",
        ctx
      });
      return block;
    }

    function create_fragment$u(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$j, create_else_block$b];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*isVirtualList*/
        ctx[5]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          div = element("div");
          if_block.c();
          attr_dev(div, "class", "listContainer svelte-1uyqfml");
          attr_dev(div, "style",
          /*listStyle*/
          ctx[14]);
          toggle_class(div, "virtualList",
          /*isVirtualList*/
          ctx[5]);
          add_location(div, file$s, 280, 0, 8325);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          /*div_binding*/

          ctx[32](div);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(window, "keydown",
            /*handleKeyDown*/
            ctx[17], false, false, false), listen_dev(window, "resize",
            /*computePlacement*/
            ctx[18], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }

          if (!current || dirty[0] &
          /*listStyle*/
          16384) {
            attr_dev(div, "style",
            /*listStyle*/
            ctx[14]);
          }

          if (dirty[0] &
          /*isVirtualList*/
          32) {
            toggle_class(div, "virtualList",
            /*isVirtualList*/
            ctx[5]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_blocks[current_block_type_index].d();
          /*div_binding*/

          ctx[32](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$u.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function isItemActive(item, value, optionIdentifier) {
      return value && value[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
      return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
      return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
    }

    function isItemSelectable(item) {
      return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty('selectable'); // Default; if `selectable` was not specified, the object is selectable
    }

    function instance$u($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('List', slots, []);
      const dispatch = createEventDispatcher();
      let {
        container = undefined
      } = $$props;
      let {
        VirtualList = null
      } = $$props;
      let {
        Item: Item$1 = Item
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        items = []
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          if (option) return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        getGroupHeaderLabel = null
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        value = undefined
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        activeItemIndex = 0
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        parent = null
      } = $$props;
      let {
        listPlacement = null
      } = $$props;
      let {
        listAutoWidth = null
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let isScrollingTimer = 0;
      let isScrolling = false;
      let prev_items;
      onMount(() => {
        if (items.length > 0 && !isMulti && value) {
          const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === value[optionIdentifier]);

          if (_hoverItemIndex) {
            $$invalidate(2, hoverItemIndex = _hoverItemIndex);
          }
        }

        scrollToActiveItem('active');
        container.addEventListener('scroll', () => {
          clearTimeout(isScrollingTimer);
          isScrollingTimer = setTimeout(() => {
            isScrolling = false;
          }, 100);
        }, false);
      });
      beforeUpdate(() => {
        if (!items) $$invalidate(1, items = []);

        if (items !== prev_items && items.length > 0) {
          $$invalidate(2, hoverItemIndex = 0);
        }

        prev_items = items;
      });

      function handleSelect(item) {
        if (item.isCreator) return;
        dispatch('itemSelected', item);
      }

      function handleHover(i) {
        if (isScrolling) return;
        $$invalidate(2, hoverItemIndex = i);
      }

      function handleClick(args) {
        const {
          item,
          i,
          event
        } = args;
        event.stopPropagation();
        if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier]) return closeList();

        if (item.isCreator) {
          dispatch('itemCreated', filterText);
        } else if (isItemSelectable(item)) {
          $$invalidate(19, activeItemIndex = i);
          $$invalidate(2, hoverItemIndex = i);
          handleSelect(item);
        }
      }

      function closeList() {
        dispatch('closeList');
      }

      async function updateHoverItem(increment) {
        if (isVirtualList) return;
        let isNonSelectableItem = true;

        while (isNonSelectableItem) {
          if (increment > 0 && hoverItemIndex === items.length - 1) {
            $$invalidate(2, hoverItemIndex = 0);
          } else if (increment < 0 && hoverItemIndex === 0) {
            $$invalidate(2, hoverItemIndex = items.length - 1);
          } else {
            $$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
          }

          isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
        }

        await tick();
        scrollToActiveItem('hover');
      }

      function handleKeyDown(e) {
        switch (e.key) {
          case 'Escape':
            e.preventDefault();
            closeList();
            break;

          case 'ArrowDown':
            e.preventDefault();
            items.length && updateHoverItem(1);
            break;

          case 'ArrowUp':
            e.preventDefault();
            items.length && updateHoverItem(-1);
            break;

          case 'Enter':
            e.preventDefault();
            if (items.length === 0) break;
            const hoverItem = items[hoverItemIndex];

            if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
              closeList();
              break;
            }

            if (hoverItem.isCreator) {
              dispatch('itemCreated', filterText);
            } else {
              $$invalidate(19, activeItemIndex = hoverItemIndex);
              handleSelect(items[hoverItemIndex]);
            }

            break;

          case 'Tab':
            e.preventDefault();

            if (items.length === 0) {
              return closeList();
            }

            if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
            $$invalidate(19, activeItemIndex = hoverItemIndex);
            handleSelect(items[hoverItemIndex]);
            break;
        }
      }

      function scrollToActiveItem(className) {
        if (isVirtualList || !container) return;
        let offsetBounding;
        const focusedElemBounding = container.querySelector(`.listItem .${className}`);

        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }

        $$invalidate(0, container.scrollTop -= offsetBounding, container);
      }

      let listStyle;

      function computePlacement() {
        const {
          height,
          width
        } = parent.getBoundingClientRect();
        $$invalidate(14, listStyle = '');
        $$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? 'auto' : '100%'};`);

        if (listPlacement === 'top' || listPlacement === 'auto' && isOutOfViewport(parent, container).bottom) {
          $$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
        } else {
          $$invalidate(14, listStyle += `top:${height + listOffset}px;`);
        }
      }

      const writable_props = ['container', 'VirtualList', 'Item', 'isVirtualList', 'items', 'labelIdentifier', 'getOptionLabel', 'getGroupHeaderLabel', 'itemHeight', 'hoverItemIndex', 'value', 'optionIdentifier', 'hideEmptyState', 'noOptionsMessage', 'isMulti', 'activeItemIndex', 'filterText', 'parent', 'listPlacement', 'listAutoWidth', 'listOffset'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
      });

      const mouseover_handler = i => handleHover(i);

      const focus_handler = i => handleHover(i);

      const click_handler = (item, i, event) => handleClick({
        item,
        i,
        event
      });

      const mouseover_handler_1 = i => handleHover(i);

      const focus_handler_1 = i => handleHover(i);

      const click_handler_1 = (item, i, event) => handleClick({
        item,
        i,
        event
      });

      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }

      $$self.$$set = $$props => {
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
        if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
        if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
        if ('items' in $$props) $$invalidate(1, items = $$props.items);
        if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
        if ('value' in $$props) $$invalidate(9, value = $$props.value);
        if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
        if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
        if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
        if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
        if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
        if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
        if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
        if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
        if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
        if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
      };

      $$self.$capture_state = () => ({
        beforeUpdate,
        createEventDispatcher,
        onMount,
        tick,
        isOutOfViewport,
        ItemComponent: Item,
        dispatch,
        container,
        VirtualList,
        Item: Item$1,
        isVirtualList,
        items,
        labelIdentifier,
        getOptionLabel,
        getGroupHeaderLabel,
        itemHeight,
        hoverItemIndex,
        value,
        optionIdentifier,
        hideEmptyState,
        noOptionsMessage,
        isMulti,
        activeItemIndex,
        filterText,
        parent,
        listPlacement,
        listAutoWidth,
        listOffset,
        isScrollingTimer,
        isScrolling,
        prev_items,
        handleSelect,
        handleHover,
        handleClick,
        closeList,
        updateHoverItem,
        handleKeyDown,
        scrollToActiveItem,
        isItemActive,
        isItemFirst,
        isItemHover,
        isItemSelectable,
        listStyle,
        computePlacement
      });

      $$self.$inject_state = $$props => {
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
        if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
        if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
        if ('items' in $$props) $$invalidate(1, items = $$props.items);
        if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
        if ('value' in $$props) $$invalidate(9, value = $$props.value);
        if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
        if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
        if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
        if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
        if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
        if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
        if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
        if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
        if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
        if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
        if ('isScrollingTimer' in $$props) isScrollingTimer = $$props.isScrollingTimer;
        if ('isScrolling' in $$props) isScrolling = $$props.isScrolling;
        if ('prev_items' in $$props) prev_items = $$props.prev_items;
        if ('listStyle' in $$props) $$invalidate(14, listStyle = $$props.listStyle);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*parent, container*/
        4194305) {
          {
            if (parent && container) computePlacement();
          }
        }
      };

      return [container, items, hoverItemIndex, VirtualList, Item$1, isVirtualList, getOptionLabel, getGroupHeaderLabel, itemHeight, value, optionIdentifier, hideEmptyState, noOptionsMessage, filterText, listStyle, handleHover, handleClick, handleKeyDown, computePlacement, activeItemIndex, labelIdentifier, isMulti, parent, listPlacement, listAutoWidth, listOffset, mouseover_handler, focus_handler, click_handler, mouseover_handler_1, focus_handler_1, click_handler_1, div_binding];
    }

    class List extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$u, create_fragment$u, safe_not_equal, {
          container: 0,
          VirtualList: 3,
          Item: 4,
          isVirtualList: 5,
          items: 1,
          labelIdentifier: 20,
          getOptionLabel: 6,
          getGroupHeaderLabel: 7,
          itemHeight: 8,
          hoverItemIndex: 2,
          value: 9,
          optionIdentifier: 10,
          hideEmptyState: 11,
          noOptionsMessage: 12,
          isMulti: 21,
          activeItemIndex: 19,
          filterText: 13,
          parent: 22,
          listPlacement: 23,
          listAutoWidth: 24,
          listOffset: 25
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "List",
          options,
          id: create_fragment$u.name
        });
      }

      get container() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set container(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get VirtualList() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set VirtualList(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get Item() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set Item(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isVirtualList() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isVirtualList(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get items() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set items(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get labelIdentifier() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set labelIdentifier(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getOptionLabel() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getOptionLabel(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getGroupHeaderLabel() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getGroupHeaderLabel(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get itemHeight() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set itemHeight(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hoverItemIndex() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hoverItemIndex(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get value() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set value(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get optionIdentifier() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set optionIdentifier(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hideEmptyState() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hideEmptyState(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get noOptionsMessage() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set noOptionsMessage(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isMulti() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isMulti(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get activeItemIndex() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set activeItemIndex(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get filterText() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set filterText(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get parent() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set parent(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listPlacement() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listPlacement(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listAutoWidth() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listAutoWidth(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listOffset() {
        throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listOffset(value) {
        throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules/svelte-select/src/Selection.svelte generated by Svelte v3.44.3 */
    const file$r = "node_modules/svelte-select/src/Selection.svelte";

    function create_fragment$t(ctx) {
      let div;
      let raw_value =
      /*getSelectionLabel*/
      ctx[0](
      /*item*/
      ctx[1]) + "";
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "selection svelte-pu1q1n");
          add_location(div, file$r, 13, 0, 230);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          div.innerHTML = raw_value;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*getSelectionLabel, item*/
          3 && raw_value !== (raw_value =
          /*getSelectionLabel*/
          ctx[0](
          /*item*/
          ctx[1]) + "")) div.innerHTML = raw_value;
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$t.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Selection', slots, []);
      let {
        getSelectionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;
      const writable_props = ['getSelectionLabel', 'item'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Selection> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
      };

      $$self.$capture_state = () => ({
        getSelectionLabel,
        item
      });

      $$self.$inject_state = $$props => {
        if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$t, create_fragment$t, safe_not_equal, {
          getSelectionLabel: 0,
          item: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Selection",
          options,
          id: create_fragment$t.name
        });
      }

      get getSelectionLabel() {
        throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getSelectionLabel(value) {
        throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get item() {
        throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set item(value) {
        throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules/svelte-select/src/MultiSelection.svelte generated by Svelte v3.44.3 */
    const file$q = "node_modules/svelte-select/src/MultiSelection.svelte";

    function get_each_context$b(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      child_ctx[11] = i;
      return child_ctx;
    } // (87:8) {#if !isDisabled && !multiFullItemClearable}


    function create_if_block$i(ctx) {
      let div;
      let svg;
      let path;
      let mounted;
      let dispose;

      function click_handler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (
          /*click_handler*/
          ctx[6](
          /*i*/
          ctx[11], ...args)
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
          add_location(path, file$q, 97, 20, 3027);
          attr_dev(svg, "width", "100%");
          attr_dev(svg, "height", "100%");
          attr_dev(svg, "viewBox", "-2 -2 50 50");
          attr_dev(svg, "focusable", "false");
          attr_dev(svg, "aria-hidden", "true");
          attr_dev(svg, "role", "presentation");
          attr_dev(svg, "class", "svelte-liu9pa");
          add_location(svg, file$q, 90, 16, 2775);
          attr_dev(div, "class", "multiSelectItem_clear svelte-liu9pa");
          add_location(div, file$q, 87, 12, 2647);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, svg);
          append_dev(svg, path);

          if (!mounted) {
            dispose = listen_dev(div, "click", click_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$i.name,
        type: "if",
        source: "(87:8) {#if !isDisabled && !multiFullItemClearable}",
        ctx
      });
      return block;
    } // (77:0) {#each value as item, i}


    function create_each_block$b(ctx) {
      let div1;
      let div0;
      let raw_value =
      /*getSelectionLabel*/
      ctx[4](
      /*item*/
      ctx[9]) + "";
      let t0;
      let t1;
      let div1_class_value;
      let mounted;
      let dispose;
      let if_block = !
      /*isDisabled*/
      ctx[2] && !
      /*multiFullItemClearable*/
      ctx[3] && create_if_block$i(ctx);

      function click_handler_1() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return (
          /*click_handler_1*/
          ctx[7](
          /*i*/
          ctx[11], ...args)
        );
      }

      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          t0 = space();
          if (if_block) if_block.c();
          t1 = space();
          attr_dev(div0, "class", "multiSelectItem_label svelte-liu9pa");
          add_location(div0, file$q, 83, 8, 2487);
          attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (
          /*activeValue*/
          ctx[1] ===
          /*i*/
          ctx[11] ? 'active' : '') + " " + (
          /*isDisabled*/
          ctx[2] ? 'disabled' : '') + " svelte-liu9pa");
          add_location(div1, file$q, 77, 4, 2256);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          div0.innerHTML = raw_value;
          append_dev(div1, t0);
          if (if_block) if_block.m(div1, null);
          append_dev(div1, t1);

          if (!mounted) {
            dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*getSelectionLabel, value*/
          17 && raw_value !== (raw_value =
          /*getSelectionLabel*/
          ctx[4](
          /*item*/
          ctx[9]) + "")) div0.innerHTML = raw_value;

          if (!
          /*isDisabled*/
          ctx[2] && !
          /*multiFullItemClearable*/
          ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$i(ctx);
              if_block.c();
              if_block.m(div1, t1);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*activeValue, isDisabled*/
          6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (
          /*activeValue*/
          ctx[1] ===
          /*i*/
          ctx[11] ? 'active' : '') + " " + (
          /*isDisabled*/
          ctx[2] ? 'disabled' : '') + " svelte-liu9pa")) {
            attr_dev(div1, "class", div1_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$b.name,
        type: "each",
        source: "(77:0) {#each value as item, i}",
        ctx
      });
      return block;
    }

    function create_fragment$s(ctx) {
      let each_1_anchor;
      let each_value =
      /*value*/
      ctx[0];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*activeValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, value*/
          63) {
            each_value =
            /*value*/
            ctx[0];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$b(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$b(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$s.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('MultiSelection', slots, []);
      const dispatch = createEventDispatcher();
      let {
        value = []
      } = $$props;
      let {
        activeValue = undefined
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        getSelectionLabel = undefined
      } = $$props;

      function handleClear(i, event) {
        event.stopPropagation();
        dispatch('multiItemClear', {
          i
        });
      }

      const writable_props = ['value', 'activeValue', 'isDisabled', 'multiFullItemClearable', 'getSelectionLabel'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
      });

      const click_handler = (i, event) => handleClear(i, event);

      const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

      $$self.$$set = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
        if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
        if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
      };

      $$self.$capture_state = () => ({
        createEventDispatcher,
        dispatch,
        value,
        activeValue,
        isDisabled,
        multiFullItemClearable,
        getSelectionLabel,
        handleClear
      });

      $$self.$inject_state = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
        if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
        if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [value, activeValue, isDisabled, multiFullItemClearable, getSelectionLabel, handleClear, click_handler, click_handler_1];
    }

    class MultiSelection extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$s, create_fragment$s, safe_not_equal, {
          value: 0,
          activeValue: 1,
          isDisabled: 2,
          multiFullItemClearable: 3,
          getSelectionLabel: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MultiSelection",
          options,
          id: create_fragment$s.name
        });
      }

      get value() {
        throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set value(value) {
        throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get activeValue() {
        throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set activeValue(value) {
        throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isDisabled() {
        throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isDisabled(value) {
        throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get multiFullItemClearable() {
        throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set multiFullItemClearable(value) {
        throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getSelectionLabel() {
        throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getSelectionLabel(value) {
        throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules/svelte-select/src/VirtualList.svelte generated by Svelte v3.44.3 */
    const file$p = "node_modules/svelte-select/src/VirtualList.svelte";

    function get_each_context$a(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[23] = list[i];
      return child_ctx;
    }

    const get_default_slot_changes = dirty => ({
      item: dirty &
      /*visible*/
      32,
      i: dirty &
      /*visible*/
      32,
      hoverItemIndex: dirty &
      /*hoverItemIndex*/
      2
    });

    const get_default_slot_context = ctx => ({
      item:
      /*row*/
      ctx[23].data,
      i:
      /*row*/
      ctx[23].index,
      hoverItemIndex:
      /*hoverItemIndex*/
      ctx[1]
    }); // (154:69) Missing template


    function fallback_block(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Missing template");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block.name,
        type: "fallback",
        source: "(154:69) Missing template",
        ctx
      });
      return block;
    } // (152:8) {#each visible as row (row.index)}


    function create_each_block$a(key_1, ctx) {
      let svelte_virtual_list_row;
      let t;
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[15].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[14], get_default_slot_context);
      const default_slot_or_fallback = default_slot || fallback_block(ctx);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          svelte_virtual_list_row = element("svelte-virtual-list-row");
          if (default_slot_or_fallback) default_slot_or_fallback.c();
          t = space();
          set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
          add_location(svelte_virtual_list_row, file$p, 152, 12, 3778);
          this.first = svelte_virtual_list_row;
        },
        m: function mount(target, anchor) {
          insert_dev(target, svelte_virtual_list_row, anchor);

          if (default_slot_or_fallback) {
            default_slot_or_fallback.m(svelte_virtual_list_row, null);
          }

          append_dev(svelte_virtual_list_row, t);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope, visible, hoverItemIndex*/
            16418)) {
              update_slot_base(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[14], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]) : get_slot_changes(default_slot_template,
              /*$$scope*/
              ctx[14], dirty, get_default_slot_changes), get_default_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(svelte_virtual_list_row);
          if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$a.name,
        type: "each",
        source: "(152:8) {#each visible as row (row.index)}",
        ctx
      });
      return block;
    }

    function create_fragment$r(ctx) {
      let svelte_virtual_list_viewport;
      let svelte_virtual_list_contents;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let svelte_virtual_list_viewport_resize_listener;
      let current;
      let mounted;
      let dispose;
      let each_value =
      /*visible*/
      ctx[5];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*row*/
      ctx[23].index;

      validate_each_keys(ctx, each_value, get_each_context$a, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$a(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
      }

      const block = {
        c: function create() {
          svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
          svelte_virtual_list_contents = element("svelte-virtual-list-contents");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(svelte_virtual_list_contents, "padding-top",
          /*top*/
          ctx[6] + "px");
          set_style(svelte_virtual_list_contents, "padding-bottom",
          /*bottom*/
          ctx[7] + "px");
          set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
          add_location(svelte_virtual_list_contents, file$p, 148, 4, 3597);
          set_style(svelte_virtual_list_viewport, "height",
          /*height*/
          ctx[0]);
          set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
          add_render_callback(() =>
          /*svelte_virtual_list_viewport_elementresize_handler*/
          ctx[18].call(svelte_virtual_list_viewport));
          add_location(svelte_virtual_list_viewport, file$p, 143, 0, 3437);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svelte_virtual_list_viewport, anchor);
          append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(svelte_virtual_list_contents, null);
          }
          /*svelte_virtual_list_contents_binding*/


          ctx[16](svelte_virtual_list_contents);
          /*svelte_virtual_list_viewport_binding*/

          ctx[17](svelte_virtual_list_viewport);
          svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport,
          /*svelte_virtual_list_viewport_elementresize_handler*/
          ctx[18].bind(svelte_virtual_list_viewport));
          current = true;

          if (!mounted) {
            dispose = listen_dev(svelte_virtual_list_viewport, "scroll",
            /*handle_scroll*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*$$scope, visible, hoverItemIndex*/
          16418) {
            each_value =
            /*visible*/
            ctx[5];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$a, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
            check_outros();
          }

          if (!current || dirty &
          /*top*/
          64) {
            set_style(svelte_virtual_list_contents, "padding-top",
            /*top*/
            ctx[6] + "px");
          }

          if (!current || dirty &
          /*bottom*/
          128) {
            set_style(svelte_virtual_list_contents, "padding-bottom",
            /*bottom*/
            ctx[7] + "px");
          }

          if (!current || dirty &
          /*height*/
          1) {
            set_style(svelte_virtual_list_viewport, "height",
            /*height*/
            ctx[0]);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(svelte_virtual_list_viewport);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
          /*svelte_virtual_list_contents_binding*/


          ctx[16](null);
          /*svelte_virtual_list_viewport_binding*/

          ctx[17](null);
          svelte_virtual_list_viewport_resize_listener();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$r.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('VirtualList', slots, ['default']);
      let {
        items = undefined
      } = $$props;
      let {
        height = '100%'
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        start = 0
      } = $$props;
      let {
        end = 0
      } = $$props;
      let height_map = [];
      let rows;
      let viewport;
      let contents;
      let viewport_height = 0;
      let visible;
      let mounted;
      let top = 0;
      let bottom = 0;
      let average_height;

      async function refresh(items, viewport_height, itemHeight) {
        const {
          scrollTop
        } = viewport;
        await tick();
        let content_height = top - scrollTop;
        let i = start;

        while (content_height < viewport_height && i < items.length) {
          let row = rows[i - start];

          if (!row) {
            $$invalidate(10, end = i + 1);
            await tick();
            row = rows[i - start];
          }

          const row_height = height_map[i] = itemHeight || row.offsetHeight;
          content_height += row_height;
          i += 1;
        }

        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = (top + content_height) / end;
        $$invalidate(7, bottom = remaining * average_height);
        height_map.length = items.length;
        if (viewport) $$invalidate(3, viewport.scrollTop = 0, viewport);
      }

      async function handle_scroll() {
        const {
          scrollTop
        } = viewport;
        const old_start = start;

        for (let v = 0; v < rows.length; v += 1) {
          height_map[start + v] = itemHeight || rows[v].offsetHeight;
        }

        let i = 0;
        let y = 0;

        while (i < items.length) {
          const row_height = height_map[i] || average_height;

          if (y + row_height > scrollTop) {
            $$invalidate(9, start = i);
            $$invalidate(6, top = y);
            break;
          }

          y += row_height;
          i += 1;
        }

        while (i < items.length) {
          y += height_map[i] || average_height;
          i += 1;
          if (y > scrollTop + viewport_height) break;
        }

        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = y / end;

        while (i < items.length) height_map[i++] = average_height;

        $$invalidate(7, bottom = remaining * average_height);

        if (start < old_start) {
          await tick();
          let expected_height = 0;
          let actual_height = 0;

          for (let i = start; i < old_start; i += 1) {
            if (rows[i - start]) {
              expected_height += height_map[i];
              actual_height += itemHeight || rows[i - start].offsetHeight;
            }
          }

          const d = actual_height - expected_height;
          viewport.scrollTo(0, scrollTop + d);
        }
      }

      onMount(() => {
        rows = contents.getElementsByTagName('svelte-virtual-list-row');
        $$invalidate(13, mounted = true);
      });
      const writable_props = ['items', 'height', 'itemHeight', 'hoverItemIndex', 'start', 'end'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualList> was created with unknown prop '${key}'`);
      });

      function svelte_virtual_list_contents_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          contents = $$value;
          $$invalidate(4, contents);
        });
      }

      function svelte_virtual_list_viewport_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          viewport = $$value;
          $$invalidate(3, viewport);
        });
      }

      function svelte_virtual_list_viewport_elementresize_handler() {
        viewport_height = this.offsetHeight;
        $$invalidate(2, viewport_height);
      }

      $$self.$$set = $$props => {
        if ('items' in $$props) $$invalidate(11, items = $$props.items);
        if ('height' in $$props) $$invalidate(0, height = $$props.height);
        if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
        if ('start' in $$props) $$invalidate(9, start = $$props.start);
        if ('end' in $$props) $$invalidate(10, end = $$props.end);
        if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        onMount,
        tick,
        items,
        height,
        itemHeight,
        hoverItemIndex,
        start,
        end,
        height_map,
        rows,
        viewport,
        contents,
        viewport_height,
        visible,
        mounted,
        top,
        bottom,
        average_height,
        refresh,
        handle_scroll
      });

      $$self.$inject_state = $$props => {
        if ('items' in $$props) $$invalidate(11, items = $$props.items);
        if ('height' in $$props) $$invalidate(0, height = $$props.height);
        if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
        if ('start' in $$props) $$invalidate(9, start = $$props.start);
        if ('end' in $$props) $$invalidate(10, end = $$props.end);
        if ('height_map' in $$props) height_map = $$props.height_map;
        if ('rows' in $$props) rows = $$props.rows;
        if ('viewport' in $$props) $$invalidate(3, viewport = $$props.viewport);
        if ('contents' in $$props) $$invalidate(4, contents = $$props.contents);
        if ('viewport_height' in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
        if ('visible' in $$props) $$invalidate(5, visible = $$props.visible);
        if ('mounted' in $$props) $$invalidate(13, mounted = $$props.mounted);
        if ('top' in $$props) $$invalidate(6, top = $$props.top);
        if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
        if ('average_height' in $$props) average_height = $$props.average_height;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*items, start, end*/
        3584) {
          $$invalidate(5, visible = items.slice(start, end).map((data, i) => {
            return {
              index: i + start,
              data
            };
          }));
        }

        if ($$self.$$.dirty &
        /*mounted, items, viewport_height, itemHeight*/
        14340) {
          if (mounted) refresh(items, viewport_height, itemHeight);
        }
      };

      return [height, hoverItemIndex, viewport_height, viewport, contents, visible, top, bottom, handle_scroll, start, end, items, itemHeight, mounted, $$scope, slots, svelte_virtual_list_contents_binding, svelte_virtual_list_viewport_binding, svelte_virtual_list_viewport_elementresize_handler];
    }

    class VirtualList extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$r, create_fragment$r, safe_not_equal, {
          items: 11,
          height: 0,
          itemHeight: 12,
          hoverItemIndex: 1,
          start: 9,
          end: 10
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "VirtualList",
          options,
          id: create_fragment$r.name
        });
      }

      get items() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set items(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get height() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set height(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get itemHeight() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set itemHeight(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hoverItemIndex() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hoverItemIndex(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get start() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set start(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get end() {
        throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set end(value) {
        throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules/svelte-select/src/ClearIcon.svelte generated by Svelte v3.44.3 */
    const file$o = "node_modules/svelte-select/src/ClearIcon.svelte";

    function create_fragment$q(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "fill", "currentColor");
          attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
          add_location(path, file$o, 8, 4, 141);
          attr_dev(svg, "width", "100%");
          attr_dev(svg, "height", "100%");
          attr_dev(svg, "viewBox", "-2 -2 50 50");
          attr_dev(svg, "focusable", "false");
          attr_dev(svg, "aria-hidden", "true");
          attr_dev(svg, "role", "presentation");
          add_location(svg, file$o, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$q.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$q($$self, $$props) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('ClearIcon', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
      });
      return [];
    }

    class ClearIcon extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$q, create_fragment$q, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ClearIcon",
          options,
          id: create_fragment$q.name
        });
      }

    }

    function debounce(func, wait, immediate) {
      let timeout;
      return function executedFunction() {
        let context = this;
        let args = arguments;

        let later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }

    /* node_modules/svelte-select/src/Select.svelte generated by Svelte v3.44.3 */
    const {
      Object: Object_1$3,
      console: console_1$2
    } = globals;
    const file$n = "node_modules/svelte-select/src/Select.svelte";

    function get_each_context$9(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[103] = list[i];
      return child_ctx;
    } // (876:8) {#if isFocused}


    function create_if_block_10$3(ctx) {
      let span0;
      let t0;
      let t1;
      let span1;
      let t2;
      const block = {
        c: function create() {
          span0 = element("span");
          t0 = text(
          /*ariaSelection*/
          ctx[33]);
          t1 = space();
          span1 = element("span");
          t2 = text(
          /*ariaContext*/
          ctx[32]);
          attr_dev(span0, "id", "aria-selection");
          add_location(span0, file$n, 876, 12, 23842);
          attr_dev(span1, "id", "aria-context");
          add_location(span1, file$n, 877, 12, 23903);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span0, anchor);
          append_dev(span0, t0);
          insert_dev(target, t1, anchor);
          insert_dev(target, span1, anchor);
          append_dev(span1, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[1] &
          /*ariaSelection*/
          4) set_data_dev(t0,
          /*ariaSelection*/
          ctx[33]);
          if (dirty[1] &
          /*ariaContext*/
          2) set_data_dev(t2,
          /*ariaContext*/
          ctx[32]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(span1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10$3.name,
        type: "if",
        source: "(876:8) {#if isFocused}",
        ctx
      });
      return block;
    } // (884:4) {#if Icon}


    function create_if_block_9$3(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
      /*iconProps*/
      ctx[18]];
      var switch_value =
      /*Icon*/
      ctx[17];

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }

        return {
          props: switch_instance_props,
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = dirty[0] &
          /*iconProps*/
          262144 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*iconProps*/
          ctx[18])]) : {};

          if (switch_value !== (switch_value =
          /*Icon*/
          ctx[17])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9$3.name,
        type: "if",
        source: "(884:4) {#if Icon}",
        ctx
      });
      return block;
    } // (888:4) {#if showMultiSelect}


    function create_if_block_8$3(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value =
      /*MultiSelection*/
      ctx[26];

      function switch_props(ctx) {
        return {
          props: {
            value:
            /*value*/
            ctx[2],
            getSelectionLabel:
            /*getSelectionLabel*/
            ctx[12],
            activeValue:
            /*activeValue*/
            ctx[30],
            isDisabled:
            /*isDisabled*/
            ctx[9],
            multiFullItemClearable:
            /*multiFullItemClearable*/
            ctx[8]
          },
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        switch_instance.$on("multiItemClear",
        /*handleMultiItemClear*/
        ctx[38]);
        switch_instance.$on("focus",
        /*handleFocus*/
        ctx[40]);
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*value*/
          4) switch_instance_changes.value =
          /*value*/
          ctx[2];
          if (dirty[0] &
          /*getSelectionLabel*/
          4096) switch_instance_changes.getSelectionLabel =
          /*getSelectionLabel*/
          ctx[12];
          if (dirty[0] &
          /*activeValue*/
          1073741824) switch_instance_changes.activeValue =
          /*activeValue*/
          ctx[30];
          if (dirty[0] &
          /*isDisabled*/
          512) switch_instance_changes.isDisabled =
          /*isDisabled*/
          ctx[9];
          if (dirty[0] &
          /*multiFullItemClearable*/
          256) switch_instance_changes.multiFullItemClearable =
          /*multiFullItemClearable*/
          ctx[8];

          if (switch_value !== (switch_value =
          /*MultiSelection*/
          ctx[26])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              switch_instance.$on("multiItemClear",
              /*handleMultiItemClear*/
              ctx[38]);
              switch_instance.$on("focus",
              /*handleFocus*/
              ctx[40]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$3.name,
        type: "if",
        source: "(888:4) {#if showMultiSelect}",
        ctx
      });
      return block;
    } // (910:4) {#if !isMulti && showSelectedItem}


    function create_if_block_7$3(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Selection*/
      ctx[25];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*value*/
            ctx[2],
            getSelectionLabel:
            /*getSelectionLabel*/
            ctx[12]
          },
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(div, "class", "selectedItem svelte-17l1npl");
          add_location(div, file$n, 910, 8, 24725);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "focus",
            /*handleFocus*/
            ctx[40], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*value*/
          4) switch_instance_changes.item =
          /*value*/
          ctx[2];
          if (dirty[0] &
          /*getSelectionLabel*/
          4096) switch_instance_changes.getSelectionLabel =
          /*getSelectionLabel*/
          ctx[12];

          if (switch_value !== (switch_value =
          /*Selection*/
          ctx[25])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$3.name,
        type: "if",
        source: "(910:4) {#if !isMulti && showSelectedItem}",
        ctx
      });
      return block;
    } // (919:4) {#if showClearIcon}


    function create_if_block_6$3(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*ClearIcon*/
      ctx[23];

      function switch_props(ctx) {
        return {
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(div, "class", "clearSelect svelte-17l1npl");
          attr_dev(div, "aria-hidden", "true");
          add_location(div, file$n, 919, 8, 24964);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click", prevent_default(
            /*handleClear*/
            ctx[27]), false, true, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (switch_value !== (switch_value =
          /*ClearIcon*/
          ctx[23])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$3.name,
        type: "if",
        source: "(919:4) {#if showClearIcon}",
        ctx
      });
      return block;
    } // (928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}


    function create_if_block_4$3(ctx) {
      let div;

      function select_block_type(ctx, dirty) {
        if (
        /*indicatorSvg*/
        ctx[22]) return create_if_block_5$3;
        return create_else_block$a;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if_block.c();
          attr_dev(div, "class", "indicator svelte-17l1npl");
          attr_dev(div, "aria-hidden", "true");
          add_location(div, file$n, 928, 8, 25347);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_block.m(div, null);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div, null);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$3.name,
        type: "if",
        source: "(928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
        ctx
      });
      return block;
    } // (932:12) {:else}


    function create_else_block$a(ctx) {
      let svg;
      let path;
      const block = {
        c: function create() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
          add_location(path, file$n, 938, 20, 25704);
          attr_dev(svg, "width", "100%");
          attr_dev(svg, "height", "100%");
          attr_dev(svg, "viewBox", "0 0 20 20");
          attr_dev(svg, "focusable", "false");
          attr_dev(svg, "aria-hidden", "true");
          attr_dev(svg, "class", "svelte-17l1npl");
          add_location(svg, file$n, 932, 16, 25494);
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, path);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(svg);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$a.name,
        type: "else",
        source: "(932:12) {:else}",
        ctx
      });
      return block;
    } // (930:12) {#if indicatorSvg}


    function create_if_block_5$3(ctx) {
      let html_tag;
      let html_anchor;
      const block = {
        c: function create() {
          html_tag = new HtmlTag();
          html_anchor = empty();
          html_tag.a = html_anchor;
        },
        m: function mount(target, anchor) {
          html_tag.m(
          /*indicatorSvg*/
          ctx[22], target, anchor);
          insert_dev(target, html_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*indicatorSvg*/
          4194304) html_tag.p(
          /*indicatorSvg*/
          ctx[22]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(html_anchor);
          if (detaching) html_tag.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$3.name,
        type: "if",
        source: "(930:12) {#if indicatorSvg}",
        ctx
      });
      return block;
    } // (950:4) {#if isWaiting}


    function create_if_block_3$5(ctx) {
      let div;
      let svg;
      let circle;
      const block = {
        c: function create() {
          div = element("div");
          svg = svg_element("svg");
          circle = svg_element("circle");
          attr_dev(circle, "class", "spinner_path svelte-17l1npl");
          attr_dev(circle, "cx", "50");
          attr_dev(circle, "cy", "50");
          attr_dev(circle, "r", "20");
          attr_dev(circle, "fill", "none");
          attr_dev(circle, "stroke", "currentColor");
          attr_dev(circle, "stroke-width", "5");
          attr_dev(circle, "stroke-miterlimit", "10");
          add_location(circle, file$n, 952, 16, 26253);
          attr_dev(svg, "class", "spinner_icon svelte-17l1npl");
          attr_dev(svg, "viewBox", "25 25 50 50");
          add_location(svg, file$n, 951, 12, 26188);
          attr_dev(div, "class", "spinner svelte-17l1npl");
          add_location(div, file$n, 950, 8, 26154);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, svg);
          append_dev(svg, circle);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$5.name,
        type: "if",
        source: "(950:4) {#if isWaiting}",
        ctx
      });
      return block;
    } // (966:4) {#if listOpen}


    function create_if_block_2$6(ctx) {
      let switch_instance;
      let updating_hoverItemIndex;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
      /*listProps*/
      ctx[34]];

      function switch_instance_hoverItemIndex_binding(value) {
        /*switch_instance_hoverItemIndex_binding*/
        ctx[84](value);
      }

      var switch_value =
      /*List*/
      ctx[24];

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }

        if (
        /*hoverItemIndex*/
        ctx[28] !== void 0) {
          switch_instance_props.hoverItemIndex =
          /*hoverItemIndex*/
          ctx[28];
        }

        return {
          props: switch_instance_props,
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
        switch_instance.$on("itemSelected",
        /*itemSelected*/
        ctx[43]);
        switch_instance.$on("itemCreated",
        /*itemCreated*/
        ctx[44]);
        switch_instance.$on("closeList",
        /*closeList*/
        ctx[45]);
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = dirty[1] &
          /*listProps*/
          8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*listProps*/
          ctx[34])]) : {};

          if (!updating_hoverItemIndex && dirty[0] &
          /*hoverItemIndex*/
          268435456) {
            updating_hoverItemIndex = true;
            switch_instance_changes.hoverItemIndex =
            /*hoverItemIndex*/
            ctx[28];
            add_flush_callback(() => updating_hoverItemIndex = false);
          }

          if (switch_value !== (switch_value =
          /*List*/
          ctx[24])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
              switch_instance.$on("itemSelected",
              /*itemSelected*/
              ctx[43]);
              switch_instance.$on("itemCreated",
              /*itemCreated*/
              ctx[44]);
              switch_instance.$on("closeList",
              /*closeList*/
              ctx[45]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$6.name,
        type: "if",
        source: "(966:4) {#if listOpen}",
        ctx
      });
      return block;
    } // (976:4) {#if !isMulti || (isMulti && !showMultiSelect)}


    function create_if_block_1$8(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      const block = {
        c: function create() {
          input_1 = element("input");
          attr_dev(input_1, "name", input_1_name_value =
          /*inputAttributes*/
          ctx[16].name);
          attr_dev(input_1, "type", "hidden");
          input_1.value = input_1_value_value =
          /*value*/
          ctx[2] ?
          /*getSelectionLabel*/
          ctx[12](
          /*value*/
          ctx[2]) : null;
          attr_dev(input_1, "class", "svelte-17l1npl");
          add_location(input_1, file$n, 976, 8, 26910);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input_1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes*/
          65536 && input_1_name_value !== (input_1_name_value =
          /*inputAttributes*/
          ctx[16].name)) {
            attr_dev(input_1, "name", input_1_name_value);
          }

          if (dirty[0] &
          /*value, getSelectionLabel*/
          4100 && input_1_value_value !== (input_1_value_value =
          /*value*/
          ctx[2] ?
          /*getSelectionLabel*/
          ctx[12](
          /*value*/
          ctx[2]) : null)) {
            prop_dev(input_1, "value", input_1_value_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$8.name,
        type: "if",
        source: "(976:4) {#if !isMulti || (isMulti && !showMultiSelect)}",
        ctx
      });
      return block;
    } // (983:4) {#if isMulti && showMultiSelect}


    function create_if_block$h(ctx) {
      let each_1_anchor;
      let each_value =
      /*value*/
      ctx[2];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes, value, getSelectionLabel*/
          69636) {
            each_value =
            /*value*/
            ctx[2];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$9(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$9(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$h.name,
        type: "if",
        source: "(983:4) {#if isMulti && showMultiSelect}",
        ctx
      });
      return block;
    } // (984:8) {#each value as item}


    function create_each_block$9(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      const block = {
        c: function create() {
          input_1 = element("input");
          attr_dev(input_1, "name", input_1_name_value =
          /*inputAttributes*/
          ctx[16].name);
          attr_dev(input_1, "type", "hidden");
          input_1.value = input_1_value_value =
          /*item*/
          ctx[103] ?
          /*getSelectionLabel*/
          ctx[12](
          /*item*/
          ctx[103]) : null;
          attr_dev(input_1, "class", "svelte-17l1npl");
          add_location(input_1, file$n, 984, 12, 27136);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input_1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes*/
          65536 && input_1_name_value !== (input_1_name_value =
          /*inputAttributes*/
          ctx[16].name)) {
            attr_dev(input_1, "name", input_1_name_value);
          }

          if (dirty[0] &
          /*value, getSelectionLabel*/
          4100 && input_1_value_value !== (input_1_value_value =
          /*item*/
          ctx[103] ?
          /*getSelectionLabel*/
          ctx[12](
          /*item*/
          ctx[103]) : null)) {
            prop_dev(input_1, "value", input_1_value_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$9.name,
        type: "each",
        source: "(984:8) {#each value as item}",
        ctx
      });
      return block;
    }

    function create_fragment$p(ctx) {
      let div;
      let span;
      let t0;
      let t1;
      let t2;
      let input_1;
      let input_1_readonly_value;
      let t3;
      let t4;
      let t5;
      let t6;
      let t7;
      let t8;
      let t9;
      let div_class_value;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*isFocused*/
      ctx[1] && create_if_block_10$3(ctx);
      let if_block1 =
      /*Icon*/
      ctx[17] && create_if_block_9$3(ctx);
      let if_block2 =
      /*showMultiSelect*/
      ctx[35] && create_if_block_8$3(ctx);
      let input_1_levels = [{
        readOnly: input_1_readonly_value = !
        /*isSearchable*/
        ctx[13]
      },
      /*_inputAttributes*/
      ctx[31], {
        placeholder:
        /*placeholderText*/
        ctx[36]
      }, {
        style:
        /*inputStyles*/
        ctx[14]
      }, {
        disabled:
        /*isDisabled*/
        ctx[9]
      }];
      let input_1_data = {};

      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_1_data = assign(input_1_data, input_1_levels[i]);
      }

      let if_block3 = !
      /*isMulti*/
      ctx[7] &&
      /*showSelectedItem*/
      ctx[29] && create_if_block_7$3(ctx);
      let if_block4 =
      /*showClearIcon*/
      ctx[37] && create_if_block_6$3(ctx);
      let if_block5 = !
      /*showClearIcon*/
      ctx[37] && (
      /*showIndicator*/
      ctx[20] ||
      /*showChevron*/
      ctx[19] && !
      /*value*/
      ctx[2] || !
      /*isSearchable*/
      ctx[13] && !
      /*isDisabled*/
      ctx[9] && !
      /*isWaiting*/
      ctx[4] && (
      /*showSelectedItem*/
      ctx[29] && !
      /*isClearable*/
      ctx[15] || !
      /*showSelectedItem*/
      ctx[29])) && create_if_block_4$3(ctx);
      let if_block6 =
      /*isWaiting*/
      ctx[4] && create_if_block_3$5(ctx);
      let if_block7 =
      /*listOpen*/
      ctx[5] && create_if_block_2$6(ctx);
      let if_block8 = (!
      /*isMulti*/
      ctx[7] ||
      /*isMulti*/
      ctx[7] && !
      /*showMultiSelect*/
      ctx[35]) && create_if_block_1$8(ctx);
      let if_block9 =
      /*isMulti*/
      ctx[7] &&
      /*showMultiSelect*/
      ctx[35] && create_if_block$h(ctx);
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          if (if_block2) if_block2.c();
          t2 = space();
          input_1 = element("input");
          t3 = space();
          if (if_block3) if_block3.c();
          t4 = space();
          if (if_block4) if_block4.c();
          t5 = space();
          if (if_block5) if_block5.c();
          t6 = space();
          if (if_block6) if_block6.c();
          t7 = space();
          if (if_block7) if_block7.c();
          t8 = space();
          if (if_block8) if_block8.c();
          t9 = space();
          if (if_block9) if_block9.c();
          attr_dev(span, "aria-live", "polite");
          attr_dev(span, "aria-atomic", "false");
          attr_dev(span, "aria-relevant", "additions text");
          attr_dev(span, "class", "a11yText svelte-17l1npl");
          add_location(span, file$n, 870, 4, 23680);
          set_attributes(input_1, input_1_data);
          toggle_class(input_1, "svelte-17l1npl", true);
          add_location(input_1, file$n, 899, 4, 24419);
          attr_dev(div, "class", div_class_value = "selectContainer " +
          /*containerClasses*/
          ctx[21] + " svelte-17l1npl");
          attr_dev(div, "style",
          /*containerStyles*/
          ctx[11]);
          toggle_class(div, "hasError",
          /*hasError*/
          ctx[10]);
          toggle_class(div, "multiSelect",
          /*isMulti*/
          ctx[7]);
          toggle_class(div, "disabled",
          /*isDisabled*/
          ctx[9]);
          toggle_class(div, "focused",
          /*isFocused*/
          ctx[1]);
          add_location(div, file$n, 861, 0, 23429);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          if (if_block0) if_block0.m(span, null);
          append_dev(div, t0);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t1);
          if (if_block2) if_block2.m(div, null);
          append_dev(div, t2);
          append_dev(div, input_1);
          if (input_1.autofocus) input_1.focus();
          /*input_1_binding*/

          ctx[82](input_1);
          set_input_value(input_1,
          /*filterText*/
          ctx[3]);
          append_dev(div, t3);
          if (if_block3) if_block3.m(div, null);
          append_dev(div, t4);
          if (if_block4) if_block4.m(div, null);
          append_dev(div, t5);
          if (if_block5) if_block5.m(div, null);
          append_dev(div, t6);
          if (if_block6) if_block6.m(div, null);
          append_dev(div, t7);
          if (if_block7) if_block7.m(div, null);
          append_dev(div, t8);
          if (if_block8) if_block8.m(div, null);
          append_dev(div, t9);
          if (if_block9) if_block9.m(div, null);
          /*div_binding*/

          ctx[85](div);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(window, "click",
            /*handleWindowEvent*/
            ctx[41], false, false, false), listen_dev(window, "focusin",
            /*handleWindowEvent*/
            ctx[41], false, false, false), listen_dev(window, "keydown",
            /*handleKeyDown*/
            ctx[39], false, false, false), listen_dev(input_1, "focus",
            /*handleFocus*/
            ctx[40], false, false, false), listen_dev(input_1, "input",
            /*input_1_input_handler*/
            ctx[83]), listen_dev(div, "click",
            /*handleClick*/
            ctx[42], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (
          /*isFocused*/
          ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_10$3(ctx);
              if_block0.c();
              if_block0.m(span, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*Icon*/
          ctx[17]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*Icon*/
              131072) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_9$3(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty[1] &
              /*showMultiSelect*/
              16) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_8$3(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [(!current || dirty[0] &
          /*isSearchable*/
          8192 && input_1_readonly_value !== (input_1_readonly_value = !
          /*isSearchable*/
          ctx[13])) && {
            readOnly: input_1_readonly_value
          }, dirty[1] &
          /*_inputAttributes*/
          1 &&
          /*_inputAttributes*/
          ctx[31], (!current || dirty[1] &
          /*placeholderText*/
          32) && {
            placeholder:
            /*placeholderText*/
            ctx[36]
          }, (!current || dirty[0] &
          /*inputStyles*/
          16384) && {
            style:
            /*inputStyles*/
            ctx[14]
          }, (!current || dirty[0] &
          /*isDisabled*/
          512) && {
            disabled:
            /*isDisabled*/
            ctx[9]
          }]));

          if (dirty[0] &
          /*filterText*/
          8 && input_1.value !==
          /*filterText*/
          ctx[3]) {
            set_input_value(input_1,
            /*filterText*/
            ctx[3]);
          }

          toggle_class(input_1, "svelte-17l1npl", true);

          if (!
          /*isMulti*/
          ctx[7] &&
          /*showSelectedItem*/
          ctx[29]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty[0] &
              /*isMulti, showSelectedItem*/
              536871040) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_7$3(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, t4);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*showClearIcon*/
          ctx[37]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty[1] &
              /*showClearIcon*/
              64) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_6$3(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div, t5);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          if (!
          /*showClearIcon*/
          ctx[37] && (
          /*showIndicator*/
          ctx[20] ||
          /*showChevron*/
          ctx[19] && !
          /*value*/
          ctx[2] || !
          /*isSearchable*/
          ctx[13] && !
          /*isDisabled*/
          ctx[9] && !
          /*isWaiting*/
          ctx[4] && (
          /*showSelectedItem*/
          ctx[29] && !
          /*isClearable*/
          ctx[15] || !
          /*showSelectedItem*/
          ctx[29]))) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block_4$3(ctx);
              if_block5.c();
              if_block5.m(div, t6);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if (
          /*isWaiting*/
          ctx[4]) {
            if (if_block6) ; else {
              if_block6 = create_if_block_3$5(ctx);
              if_block6.c();
              if_block6.m(div, t7);
            }
          } else if (if_block6) {
            if_block6.d(1);
            if_block6 = null;
          }

          if (
          /*listOpen*/
          ctx[5]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);

              if (dirty[0] &
              /*listOpen*/
              32) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block_2$6(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div, t8);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }

          if (!
          /*isMulti*/
          ctx[7] ||
          /*isMulti*/
          ctx[7] && !
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);
            } else {
              if_block8 = create_if_block_1$8(ctx);
              if_block8.c();
              if_block8.m(div, t9);
            }
          } else if (if_block8) {
            if_block8.d(1);
            if_block8 = null;
          }

          if (
          /*isMulti*/
          ctx[7] &&
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block9) {
              if_block9.p(ctx, dirty);
            } else {
              if_block9 = create_if_block$h(ctx);
              if_block9.c();
              if_block9.m(div, null);
            }
          } else if (if_block9) {
            if_block9.d(1);
            if_block9 = null;
          }

          if (!current || dirty[0] &
          /*containerClasses*/
          2097152 && div_class_value !== (div_class_value = "selectContainer " +
          /*containerClasses*/
          ctx[21] + " svelte-17l1npl")) {
            attr_dev(div, "class", div_class_value);
          }

          if (!current || dirty[0] &
          /*containerStyles*/
          2048) {
            attr_dev(div, "style",
            /*containerStyles*/
            ctx[11]);
          }

          if (dirty[0] &
          /*containerClasses, hasError*/
          2098176) {
            toggle_class(div, "hasError",
            /*hasError*/
            ctx[10]);
          }

          if (dirty[0] &
          /*containerClasses, isMulti*/
          2097280) {
            toggle_class(div, "multiSelect",
            /*isMulti*/
            ctx[7]);
          }

          if (dirty[0] &
          /*containerClasses, isDisabled*/
          2097664) {
            toggle_class(div, "disabled",
            /*isDisabled*/
            ctx[9]);
          }

          if (dirty[0] &
          /*containerClasses, isFocused*/
          2097154) {
            toggle_class(div, "focused",
            /*isFocused*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(if_block7);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(if_block7);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          /*input_1_binding*/

          ctx[82](null);
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          /*div_binding*/

          ctx[85](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$p.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function convertStringItemsToObjects(_items) {
      return _items.map((item, index) => {
        return {
          index,
          value: item,
          label: `${item}`
        };
      });
    }

    function instance$p($$self, $$props, $$invalidate) {
      let filteredItems;
      let showSelectedItem;
      let showClearIcon;
      let placeholderText;
      let showMultiSelect;
      let listProps;
      let ariaSelection;
      let ariaContext;
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Select', slots, []);
      const dispatch = createEventDispatcher();
      let {
        id = null
      } = $$props;
      let {
        container = undefined
      } = $$props;
      let {
        input = undefined
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        isCreatable = false
      } = $$props;
      let {
        isFocused = false
      } = $$props;
      let {
        value = null
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        placeholder = 'Select...'
      } = $$props;
      let {
        placeholderAlwaysShow = false
      } = $$props;
      let {
        items = null
      } = $$props;
      let {
        itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase())
      } = $$props;
      let {
        groupBy = undefined
      } = $$props;
      let {
        groupFilter = groups => groups
      } = $$props;
      let {
        isGroupHeaderSelectable = false
      } = $$props;
      let {
        getGroupHeaderLabel = option => {
          return option[labelIdentifier] || option.id;
        }
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        loadOptions = undefined
      } = $$props;
      let {
        hasError = false
      } = $$props;
      let {
        containerStyles = ''
      } = $$props;
      let {
        getSelectionLabel = option => {
          if (option) return option[labelIdentifier];else return null;
        }
      } = $$props;
      let {
        createGroupHeaderItem = groupValue => {
          return {
            value: groupValue,
            label: groupValue
          };
        }
      } = $$props;
      let {
        createItem = filterText => {
          return {
            value: filterText,
            label: filterText
          };
        }
      } = $$props;

      const getFilteredItems = () => {
        return filteredItems;
      };

      let {
        isSearchable = true
      } = $$props;
      let {
        inputStyles = ''
      } = $$props;
      let {
        isClearable = true
      } = $$props;
      let {
        isWaiting = false
      } = $$props;
      let {
        listPlacement = 'auto'
      } = $$props;
      let {
        listOpen = false
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        loadOptionsInterval = 300
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        inputAttributes = {}
      } = $$props;
      let {
        listAutoWidth = true
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        Icon = undefined
      } = $$props;
      let {
        iconProps = {}
      } = $$props;
      let {
        showChevron = false
      } = $$props;
      let {
        showIndicator = false
      } = $$props;
      let {
        containerClasses = ''
      } = $$props;
      let {
        indicatorSvg = undefined
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let {
        ClearIcon: ClearIcon$1 = ClearIcon
      } = $$props;
      let {
        Item: Item$1 = Item
      } = $$props;
      let {
        List: List$1 = List
      } = $$props;
      let {
        Selection: Selection$1 = Selection
      } = $$props;
      let {
        MultiSelection: MultiSelection$1 = MultiSelection
      } = $$props;
      let {
        VirtualList: VirtualList$1 = VirtualList
      } = $$props;

      function filterMethod(args) {
        if (args.loadOptions && args.filterText.length > 0) return;
        if (!args.items) return [];

        if (args.items && args.items.length > 0 && typeof args.items[0] !== 'object') {
          args.items = convertStringItemsToObjects(args.items);
        }

        let filterResults = args.items.filter(item => {
          let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);

          if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
            matchesFilter = !args.value.some(x => {
              return x[args.optionIdentifier] === item[args.optionIdentifier];
            });
          }

          return matchesFilter;
        });

        if (args.groupBy) {
          filterResults = filterGroupedItems(filterResults);
        }

        if (args.isCreatable) {
          filterResults = addCreatableItem(filterResults, args.filterText);
        }

        return filterResults;
      }

      function addCreatableItem(_items, _filterText) {
        if (_filterText.length === 0) return _items;
        const itemToCreate = createItem(_filterText);
        if (_items[0] && _filterText === _items[0][labelIdentifier]) return _items;
        itemToCreate.isCreator = true;
        return [..._items, itemToCreate];
      }

      let {
        selectedValue = null
      } = $$props;
      let activeValue;
      let prev_value;
      let prev_filterText;
      let prev_isFocused;
      let prev_isMulti;
      let hoverItemIndex;
      const getItems = debounce(async () => {
        $$invalidate(4, isWaiting = true);
        let res = await loadOptions(filterText).catch(err => {
          console.warn('svelte-select loadOptions error :>> ', err);
          dispatch('error', {
            type: 'loadOptions',
            details: err
          });
        });

        if (res && !res.cancelled) {
          if (res) {
            if (res && res.length > 0 && typeof res[0] !== 'object') {
              res = convertStringItemsToObjects(res);
            }

            $$invalidate(81, filteredItems = [...res]);
            dispatch('loaded', {
              items: filteredItems
            });
          } else {
            $$invalidate(81, filteredItems = []);
          }

          if (isCreatable) {
            $$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
          }

          $$invalidate(4, isWaiting = false);
          $$invalidate(1, isFocused = true);
          $$invalidate(5, listOpen = true);
        }
      }, loadOptionsInterval);

      function setValue() {
        if (typeof value === 'string') {
          $$invalidate(2, value = {
            [optionIdentifier]: value,
            label: value
          });
        } else if (isMulti && Array.isArray(value) && value.length > 0) {
          $$invalidate(2, value = value.map(item => typeof item === 'string' ? {
            value: item,
            label: item
          } : item));
        }
      }

      let _inputAttributes;

      function assignInputAttributes() {
        $$invalidate(31, _inputAttributes = Object.assign({
          autocapitalize: 'none',
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: false,
          tabindex: 0,
          type: 'text',
          'aria-autocomplete': 'list'
        }, inputAttributes));

        if (id) {
          $$invalidate(31, _inputAttributes.id = id, _inputAttributes);
        }

        if (!isSearchable) {
          $$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
        }
      }

      function filterGroupedItems(_items) {
        const groupValues = [];
        const groups = {};

        _items.forEach(item => {
          const groupValue = groupBy(item);

          if (!groupValues.includes(groupValue)) {
            groupValues.push(groupValue);
            groups[groupValue] = [];

            if (groupValue) {
              groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
                id: groupValue,
                isGroupHeader: true,
                isSelectable: isGroupHeaderSelectable
              }));
            }
          }

          groups[groupValue].push(Object.assign({
            isGroupItem: !!groupValue
          }, item));
        });

        const sortedGroupedItems = [];
        groupFilter(groupValues).forEach(groupValue => {
          sortedGroupedItems.push(...groups[groupValue]);
        });
        return sortedGroupedItems;
      }

      function dispatchSelectedItem() {
        if (isMulti) {
          if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
            if (checkValueForDuplicates()) {
              dispatch('select', value);
            }
          }

          return;
        }

        if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
          dispatch('select', value);
        }
      }

      function setupFocus() {
        if (isFocused || listOpen) {
          handleFocus();
        } else {
          if (input) input.blur();
        }
      }

      function setupMulti() {
        if (value) {
          if (Array.isArray(value)) {
            $$invalidate(2, value = [...value]);
          } else {
            $$invalidate(2, value = [value]);
          }
        }
      }

      function setupSingle() {
        if (value) $$invalidate(2, value = null);
      }

      function setupFilterText() {
        if (filterText.length === 0) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = true);

        if (loadOptions) {
          getItems();
        } else {
          $$invalidate(5, listOpen = true);

          if (isMulti) {
            $$invalidate(30, activeValue = undefined);
          }
        }
      }

      beforeUpdate(async () => {
        $$invalidate(77, prev_value = value);
        $$invalidate(78, prev_filterText = filterText);
        $$invalidate(79, prev_isFocused = isFocused);
        $$invalidate(80, prev_isMulti = isMulti);
      });

      function checkValueForDuplicates() {
        let noDuplicates = true;

        if (value) {
          const ids = [];
          const uniqueValues = [];
          value.forEach(val => {
            if (!ids.includes(val[optionIdentifier])) {
              ids.push(val[optionIdentifier]);
              uniqueValues.push(val);
            } else {
              noDuplicates = false;
            }
          });
          if (!noDuplicates) $$invalidate(2, value = uniqueValues);
        }

        return noDuplicates;
      }

      function findItem(selection) {
        let matchTo = selection ? selection[optionIdentifier] : value[optionIdentifier];
        return items.find(item => item[optionIdentifier] === matchTo);
      }

      function updateValueDisplay(items) {
        if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;
        if (!value || (isMulti ? value.some(selection => !selection || !selection[optionIdentifier]) : !value[optionIdentifier])) return;

        if (Array.isArray(value)) {
          $$invalidate(2, value = value.map(selection => findItem(selection) || selection));
        } else {
          $$invalidate(2, value = findItem() || value);
        }
      }

      function handleMultiItemClear(event) {
        const {
          detail
        } = event;
        const itemToRemove = value[detail ? detail.i : value.length - 1];

        if (value.length === 1) {
          $$invalidate(2, value = undefined);
        } else {
          $$invalidate(2, value = value.filter(item => {
            return item !== itemToRemove;
          }));
        }

        dispatch('clear', itemToRemove);
      }

      function handleKeyDown(e) {
        if (!isFocused) return;

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;

          case 'ArrowUp':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;

          case 'Tab':
            if (!listOpen) $$invalidate(1, isFocused = false);
            break;

          case 'Backspace':
            if (!isMulti || filterText.length > 0) return;

            if (isMulti && value && value.length > 0) {
              handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);
              if (activeValue === 0 || activeValue === undefined) break;
              $$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
            }

            break;

          case 'ArrowLeft':
            if (!isMulti || filterText.length > 0) return;

            if (activeValue === undefined) {
              $$invalidate(30, activeValue = value.length - 1);
            } else if (value.length > activeValue && activeValue !== 0) {
              $$invalidate(30, activeValue -= 1);
            }

            break;

          case 'ArrowRight':
            if (!isMulti || filterText.length > 0 || activeValue === undefined) return;

            if (activeValue === value.length - 1) {
              $$invalidate(30, activeValue = undefined);
            } else if (activeValue < value.length - 1) {
              $$invalidate(30, activeValue += 1);
            }

            break;
        }
      }

      function handleFocus() {
        $$invalidate(1, isFocused = true);
        if (input) input.focus();
      }

      function handleWindowEvent(event) {
        if (!container) return;
        const eventTarget = event.path && event.path.length > 0 ? event.path[0] : event.target;

        if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
          return;
        }

        $$invalidate(1, isFocused = false);
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
        if (input) input.blur();
      }

      function handleClick() {
        if (isDisabled) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = !listOpen);
      }

      function handleClear() {
        $$invalidate(2, value = undefined);
        $$invalidate(5, listOpen = false);
        dispatch('clear', value);
        handleFocus();
      }

      onMount(() => {
        if (isFocused && input) input.focus();
      });

      function itemSelected(event) {
        const {
          detail
        } = event;

        if (detail) {
          $$invalidate(3, filterText = '');
          const item = Object.assign({}, detail);

          if (!item.isGroupHeader || item.isSelectable) {
            if (isMulti) {
              $$invalidate(2, value = value ? value.concat([item]) : [item]);
            } else {
              $$invalidate(2, value = item);
            }

            $$invalidate(2, value);
            setTimeout(() => {
              $$invalidate(5, listOpen = false);
              $$invalidate(30, activeValue = undefined);
            });
          }
        }
      }

      function itemCreated(event) {
        const {
          detail
        } = event;

        if (isMulti) {
          $$invalidate(2, value = value || []);
          $$invalidate(2, value = [...value, createItem(detail)]);
        } else {
          $$invalidate(2, value = createItem(detail));
        }

        dispatch('itemCreated', detail);
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
      }

      function closeList() {
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
      }

      let {
        ariaValues = values => {
          return `Option ${values}, selected.`;
        }
      } = $$props;
      let {
        ariaListOpen = (label, count) => {
          return `You are currently focused on option ${label}. There are ${count} results available.`;
        }
      } = $$props;
      let {
        ariaFocused = () => {
          return `Select is focused, type to refine list, press down to open the menu.`;
        }
      } = $$props;

      function handleAriaSelection() {
        let selected = undefined;

        if (isMulti && value.length > 0) {
          selected = value.map(v => getSelectionLabel(v)).join(', ');
        } else {
          selected = getSelectionLabel(value);
        }

        return ariaValues(selected);
      }

      function handleAriaContent() {
        if (!isFocused || !filteredItems || filteredItems.length === 0) return '';
        let _item = filteredItems[hoverItemIndex];

        if (listOpen && _item) {
          let label = getSelectionLabel(_item);
          let count = filteredItems ? filteredItems.length : 0;
          return ariaListOpen(label, count);
        } else {
          return ariaFocused();
        }
      }

      const writable_props = ['id', 'container', 'input', 'isMulti', 'multiFullItemClearable', 'isDisabled', 'isCreatable', 'isFocused', 'value', 'filterText', 'placeholder', 'placeholderAlwaysShow', 'items', 'itemFilter', 'groupBy', 'groupFilter', 'isGroupHeaderSelectable', 'getGroupHeaderLabel', 'labelIdentifier', 'getOptionLabel', 'optionIdentifier', 'loadOptions', 'hasError', 'containerStyles', 'getSelectionLabel', 'createGroupHeaderItem', 'createItem', 'isSearchable', 'inputStyles', 'isClearable', 'isWaiting', 'listPlacement', 'listOpen', 'isVirtualList', 'loadOptionsInterval', 'noOptionsMessage', 'hideEmptyState', 'inputAttributes', 'listAutoWidth', 'itemHeight', 'Icon', 'iconProps', 'showChevron', 'showIndicator', 'containerClasses', 'indicatorSvg', 'listOffset', 'ClearIcon', 'Item', 'List', 'Selection', 'MultiSelection', 'VirtualList', 'selectedValue', 'ariaValues', 'ariaListOpen', 'ariaFocused'];
      Object_1$3.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Select> was created with unknown prop '${key}'`);
      });

      function input_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          input = $$value;
          $$invalidate(6, input);
        });
      }

      function input_1_input_handler() {
        filterText = this.value;
        $$invalidate(3, filterText);
      }

      function switch_instance_hoverItemIndex_binding(value) {
        hoverItemIndex = value;
        $$invalidate(28, hoverItemIndex);
      }

      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }

      $$self.$$set = $$props => {
        if ('id' in $$props) $$invalidate(46, id = $$props.id);
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('input' in $$props) $$invalidate(6, input = $$props.input);
        if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
        if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
        if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
        if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
        if ('value' in $$props) $$invalidate(2, value = $$props.value);
        if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
        if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
        if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
        if ('items' in $$props) $$invalidate(50, items = $$props.items);
        if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
        if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
        if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
        if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
        if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
        if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
        if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
        if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
        if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
        if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
        if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
        if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
        if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
        if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
        if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
        if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
        if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
        if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
        if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
        if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
        if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
        if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
        if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
        if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
        if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
        if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
        if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
        if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
        if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
        if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
        if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
        if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
        if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
        if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
        if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
        if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
        if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
        if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
        if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
        if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
        if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
      };

      $$self.$capture_state = () => ({
        beforeUpdate,
        createEventDispatcher,
        onMount,
        _List: List,
        _Item: Item,
        _Selection: Selection,
        _MultiSelection: MultiSelection,
        _VirtualList: VirtualList,
        _ClearIcon: ClearIcon,
        debounce,
        dispatch,
        id,
        container,
        input,
        isMulti,
        multiFullItemClearable,
        isDisabled,
        isCreatable,
        isFocused,
        value,
        filterText,
        placeholder,
        placeholderAlwaysShow,
        items,
        itemFilter,
        groupBy,
        groupFilter,
        isGroupHeaderSelectable,
        getGroupHeaderLabel,
        labelIdentifier,
        getOptionLabel,
        optionIdentifier,
        loadOptions,
        hasError,
        containerStyles,
        getSelectionLabel,
        createGroupHeaderItem,
        createItem,
        getFilteredItems,
        isSearchable,
        inputStyles,
        isClearable,
        isWaiting,
        listPlacement,
        listOpen,
        isVirtualList,
        loadOptionsInterval,
        noOptionsMessage,
        hideEmptyState,
        inputAttributes,
        listAutoWidth,
        itemHeight,
        Icon,
        iconProps,
        showChevron,
        showIndicator,
        containerClasses,
        indicatorSvg,
        listOffset,
        ClearIcon: ClearIcon$1,
        Item: Item$1,
        List: List$1,
        Selection: Selection$1,
        MultiSelection: MultiSelection$1,
        VirtualList: VirtualList$1,
        filterMethod,
        addCreatableItem,
        selectedValue,
        activeValue,
        prev_value,
        prev_filterText,
        prev_isFocused,
        prev_isMulti,
        hoverItemIndex,
        getItems,
        setValue,
        _inputAttributes,
        assignInputAttributes,
        convertStringItemsToObjects,
        filterGroupedItems,
        dispatchSelectedItem,
        setupFocus,
        setupMulti,
        setupSingle,
        setupFilterText,
        checkValueForDuplicates,
        findItem,
        updateValueDisplay,
        handleMultiItemClear,
        handleKeyDown,
        handleFocus,
        handleWindowEvent,
        handleClick,
        handleClear,
        itemSelected,
        itemCreated,
        closeList,
        ariaValues,
        ariaListOpen,
        ariaFocused,
        handleAriaSelection,
        handleAriaContent,
        filteredItems,
        ariaContext,
        ariaSelection,
        listProps,
        showMultiSelect,
        placeholderText,
        showSelectedItem,
        showClearIcon
      });

      $$self.$inject_state = $$props => {
        if ('id' in $$props) $$invalidate(46, id = $$props.id);
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('input' in $$props) $$invalidate(6, input = $$props.input);
        if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
        if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
        if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
        if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
        if ('value' in $$props) $$invalidate(2, value = $$props.value);
        if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
        if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
        if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
        if ('items' in $$props) $$invalidate(50, items = $$props.items);
        if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
        if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
        if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
        if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
        if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
        if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
        if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
        if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
        if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
        if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
        if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
        if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
        if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
        if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
        if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
        if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
        if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
        if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
        if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
        if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
        if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
        if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
        if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
        if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
        if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
        if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
        if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
        if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
        if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
        if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
        if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
        if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
        if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
        if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
        if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
        if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
        if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
        if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
        if ('activeValue' in $$props) $$invalidate(30, activeValue = $$props.activeValue);
        if ('prev_value' in $$props) $$invalidate(77, prev_value = $$props.prev_value);
        if ('prev_filterText' in $$props) $$invalidate(78, prev_filterText = $$props.prev_filterText);
        if ('prev_isFocused' in $$props) $$invalidate(79, prev_isFocused = $$props.prev_isFocused);
        if ('prev_isMulti' in $$props) $$invalidate(80, prev_isMulti = $$props.prev_isMulti);
        if ('hoverItemIndex' in $$props) $$invalidate(28, hoverItemIndex = $$props.hoverItemIndex);
        if ('_inputAttributes' in $$props) $$invalidate(31, _inputAttributes = $$props._inputAttributes);
        if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
        if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
        if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
        if ('filteredItems' in $$props) $$invalidate(81, filteredItems = $$props.filteredItems);
        if ('ariaContext' in $$props) $$invalidate(32, ariaContext = $$props.ariaContext);
        if ('ariaSelection' in $$props) $$invalidate(33, ariaSelection = $$props.ariaSelection);
        if ('listProps' in $$props) $$invalidate(34, listProps = $$props.listProps);
        if ('showMultiSelect' in $$props) $$invalidate(35, showMultiSelect = $$props.showMultiSelect);
        if ('placeholderText' in $$props) $$invalidate(36, placeholderText = $$props.placeholderText);
        if ('showSelectedItem' in $$props) $$invalidate(29, showSelectedItem = $$props.showSelectedItem);
        if ('showClearIcon' in $$props) $$invalidate(37, showClearIcon = $$props.showClearIcon);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*filterText, value, isMulti*/
        140 | $$self.$$.dirty[1] &
        /*loadOptions, items, optionIdentifier, groupBy, isCreatable*/
        405340160) {
          $$invalidate(81, filteredItems = filterMethod({
            loadOptions,
            filterText,
            items,
            value,
            isMulti,
            optionIdentifier,
            groupBy,
            isCreatable
          }));
        }

        if ($$self.$$.dirty[2] &
        /*selectedValue*/
        2048) {
          {
            if (selectedValue) console.warn('selectedValue is no longer used. Please use value instead.');
          }
        }

        if ($$self.$$.dirty[1] &
        /*items*/
        524288) {
          updateValueDisplay(items);
        }

        if ($$self.$$.dirty[0] &
        /*value*/
        4) {
          {
            if (value) setValue();
          }
        }

        if ($$self.$$.dirty[0] &
        /*inputAttributes, isSearchable*/
        73728) {
          {
            if (inputAttributes || !isSearchable) assignInputAttributes();
          }
        }

        if ($$self.$$.dirty[0] &
        /*isMulti*/
        128 | $$self.$$.dirty[2] &
        /*prev_isMulti*/
        262144) {
          {
            if (isMulti) {
              setupMulti();
            }

            if (prev_isMulti && !isMulti) {
              setupSingle();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132) {
          {
            if (isMulti && value && value.length > 1) {
              checkValueForDuplicates();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*value*/
        4) {
          {
            if (value) dispatchSelectedItem();
          }
        }

        if ($$self.$$.dirty[0] &
        /*value, isMulti*/
        132 | $$self.$$.dirty[2] &
        /*prev_value*/
        32768) {
          {
            if (!value && isMulti && prev_value) {
              dispatch('select', value);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*isFocused*/
        2 | $$self.$$.dirty[2] &
        /*prev_isFocused*/
        131072) {
          {
            if (isFocused !== prev_isFocused) {
              setupFocus();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*filterText*/
        8 | $$self.$$.dirty[2] &
        /*prev_filterText*/
        65536) {
          {
            if (filterText !== prev_filterText) {
              setupFilterText();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*value, filterText*/
        12) {
          $$invalidate(29, showSelectedItem = value && filterText.length === 0);
        }

        if ($$self.$$.dirty[0] &
        /*showSelectedItem, isClearable, isDisabled, isWaiting*/
        536904208) {
          $$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132 | $$self.$$.dirty[1] &
        /*placeholderAlwaysShow, placeholder*/
        393216) {
          $$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti ? placeholder : value ? '' : placeholder);
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132) {
          $$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
        }

        if ($$self.$$.dirty[0] &
        /*filterText, value, isMulti, container*/
        141 | $$self.$$.dirty[1] &
        /*optionIdentifier, getGroupHeaderLabel, getOptionLabel*/
        218103808 | $$self.$$.dirty[2] &
        /*Item, noOptionsMessage, hideEmptyState, isVirtualList, VirtualList, filteredItems, itemHeight, listPlacement, listAutoWidth, listOffset*/
        526326) {
          $$invalidate(34, listProps = {
            Item: Item$1,
            filterText,
            optionIdentifier,
            noOptionsMessage,
            hideEmptyState,
            isVirtualList,
            VirtualList: VirtualList$1,
            value,
            isMulti,
            getGroupHeaderLabel,
            items: filteredItems,
            itemHeight,
            getOptionLabel,
            listPlacement,
            parent: container,
            listAutoWidth,
            listOffset
          });
        }

        if ($$self.$$.dirty[0] &
        /*value, isMulti*/
        132) {
          $$invalidate(33, ariaSelection = value ? handleAriaSelection() : '');
        }

        if ($$self.$$.dirty[0] &
        /*hoverItemIndex, isFocused, listOpen*/
        268435490 | $$self.$$.dirty[2] &
        /*filteredItems*/
        524288) {
          $$invalidate(32, ariaContext = handleAriaContent());
        }
      };

      return [container, isFocused, value, filterText, isWaiting, listOpen, input, isMulti, multiFullItemClearable, isDisabled, hasError, containerStyles, getSelectionLabel, isSearchable, inputStyles, isClearable, inputAttributes, Icon, iconProps, showChevron, showIndicator, containerClasses, indicatorSvg, ClearIcon$1, List$1, Selection$1, MultiSelection$1, handleClear, hoverItemIndex, showSelectedItem, activeValue, _inputAttributes, ariaContext, ariaSelection, listProps, showMultiSelect, placeholderText, showClearIcon, handleMultiItemClear, handleKeyDown, handleFocus, handleWindowEvent, handleClick, itemSelected, itemCreated, closeList, id, isCreatable, placeholder, placeholderAlwaysShow, items, itemFilter, groupBy, groupFilter, isGroupHeaderSelectable, getGroupHeaderLabel, labelIdentifier, getOptionLabel, optionIdentifier, loadOptions, createGroupHeaderItem, createItem, getFilteredItems, listPlacement, isVirtualList, loadOptionsInterval, noOptionsMessage, hideEmptyState, listAutoWidth, itemHeight, listOffset, Item$1, VirtualList$1, selectedValue, ariaValues, ariaListOpen, ariaFocused, prev_value, prev_filterText, prev_isFocused, prev_isMulti, filteredItems, input_1_binding, input_1_input_handler, switch_instance_hoverItemIndex_binding, div_binding];
    }

    class Select extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$p, create_fragment$p, safe_not_equal, {
          id: 46,
          container: 0,
          input: 6,
          isMulti: 7,
          multiFullItemClearable: 8,
          isDisabled: 9,
          isCreatable: 47,
          isFocused: 1,
          value: 2,
          filterText: 3,
          placeholder: 48,
          placeholderAlwaysShow: 49,
          items: 50,
          itemFilter: 51,
          groupBy: 52,
          groupFilter: 53,
          isGroupHeaderSelectable: 54,
          getGroupHeaderLabel: 55,
          labelIdentifier: 56,
          getOptionLabel: 57,
          optionIdentifier: 58,
          loadOptions: 59,
          hasError: 10,
          containerStyles: 11,
          getSelectionLabel: 12,
          createGroupHeaderItem: 60,
          createItem: 61,
          getFilteredItems: 62,
          isSearchable: 13,
          inputStyles: 14,
          isClearable: 15,
          isWaiting: 4,
          listPlacement: 63,
          listOpen: 5,
          isVirtualList: 64,
          loadOptionsInterval: 65,
          noOptionsMessage: 66,
          hideEmptyState: 67,
          inputAttributes: 16,
          listAutoWidth: 68,
          itemHeight: 69,
          Icon: 17,
          iconProps: 18,
          showChevron: 19,
          showIndicator: 20,
          containerClasses: 21,
          indicatorSvg: 22,
          listOffset: 70,
          ClearIcon: 23,
          Item: 71,
          List: 24,
          Selection: 25,
          MultiSelection: 26,
          VirtualList: 72,
          selectedValue: 73,
          handleClear: 27,
          ariaValues: 74,
          ariaListOpen: 75,
          ariaFocused: 76
        }, null, [-1, -1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Select",
          options,
          id: create_fragment$p.name
        });
      }

      get id() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set id(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get container() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set container(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get input() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set input(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isMulti() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isMulti(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get multiFullItemClearable() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set multiFullItemClearable(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isDisabled() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isDisabled(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isCreatable() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isCreatable(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isFocused() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isFocused(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get value() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set value(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get filterText() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set filterText(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get placeholder() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set placeholder(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get placeholderAlwaysShow() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set placeholderAlwaysShow(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get items() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set items(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get itemFilter() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set itemFilter(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get groupBy() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set groupBy(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get groupFilter() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set groupFilter(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isGroupHeaderSelectable() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isGroupHeaderSelectable(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getGroupHeaderLabel() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getGroupHeaderLabel(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get labelIdentifier() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set labelIdentifier(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getOptionLabel() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getOptionLabel(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get optionIdentifier() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set optionIdentifier(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get loadOptions() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set loadOptions(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hasError() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hasError(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get containerStyles() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set containerStyles(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getSelectionLabel() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set getSelectionLabel(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get createGroupHeaderItem() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set createGroupHeaderItem(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get createItem() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set createItem(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get getFilteredItems() {
        return this.$$.ctx[62];
      }

      set getFilteredItems(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isSearchable() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isSearchable(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get inputStyles() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set inputStyles(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isClearable() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isClearable(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isWaiting() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isWaiting(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listPlacement() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listPlacement(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listOpen() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listOpen(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get isVirtualList() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set isVirtualList(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get loadOptionsInterval() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set loadOptionsInterval(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get noOptionsMessage() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set noOptionsMessage(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hideEmptyState() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hideEmptyState(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get inputAttributes() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set inputAttributes(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listAutoWidth() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listAutoWidth(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get itemHeight() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set itemHeight(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get Icon() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set Icon(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get iconProps() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set iconProps(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get showChevron() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set showChevron(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get showIndicator() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set showIndicator(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get containerClasses() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set containerClasses(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get indicatorSvg() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set indicatorSvg(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get listOffset() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set listOffset(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get ClearIcon() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set ClearIcon(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get Item() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set Item(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get List() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set List(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get Selection() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set Selection(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get MultiSelection() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set MultiSelection(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get VirtualList() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set VirtualList(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get selectedValue() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set selectedValue(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get handleClear() {
        return this.$$.ctx[27];
      }

      set handleClear(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get ariaValues() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set ariaValues(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get ariaListOpen() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set ariaListOpen(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get ariaFocused() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set ariaFocused(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/SidebarMenuItem.svelte generated by Svelte v3.44.3 */
    const file$m = "src/components/SidebarMenuItem.svelte"; // (87:2) {:else}

    function create_else_block$9(ctx) {
      let span;
      let t0;
      let t1;
      let toggle;
      let current;
      toggle = new Toggle({
        props: {
          active:
          /*value*/
          ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(
          /*label*/
          ctx[2]);
          t1 = space();
          create_component(toggle.$$.fragment);
          attr_dev(span, "class", "label svelte-wt0zqi");
          add_location(span, file$m, 87, 4, 2389);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          insert_dev(target, t1, anchor);
          mount_component(toggle, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*label*/
          4) set_data_dev(t0,
          /*label*/
          ctx[2]);
          const toggle_changes = {};
          if (dirty &
          /*value*/
          1) toggle_changes.active =
          /*value*/
          ctx[0];
          toggle.$set(toggle_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(toggle.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(toggle.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching) detach_dev(t1);
          destroy_component(toggle, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$9.name,
        type: "else",
        source: "(87:2) {:else}",
        ctx
      });
      return block;
    } // (83:32) 


    function create_if_block_1$7(ctx) {
      let div;
      let select;
      let current;
      let mounted;
      let dispose;
      select = new Select({
        props: {
          items:
          /*options*/
          ctx[5],
          value:
          /*selectedOption*/
          ctx[6],
          isSearchable: true,
          isClearable: false,
          itemFilter: filterSelectItems,
          placeholder:
          /*label*/
          ctx[2],
          showIndicator: true
        },
        $$inline: true
      });
      select.$on("select",
      /*onSelect*/
      ctx[7]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(select.$$.fragment);
          attr_dev(div, "class", "select svelte-wt0zqi");
          add_location(div, file$m, 83, 4, 2108);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(select, div, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(div, "focusin",
            /*focusIn*/
            ctx[8], false, false, false), listen_dev(div, "focusOut",
            /*focusOut*/
            ctx[9], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const select_changes = {};
          if (dirty &
          /*options*/
          32) select_changes.items =
          /*options*/
          ctx[5];
          if (dirty &
          /*selectedOption*/
          64) select_changes.value =
          /*selectedOption*/
          ctx[6];
          if (dirty &
          /*label*/
          4) select_changes.placeholder =
          /*label*/
          ctx[2];
          select.$set(select_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(select);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$7.name,
        type: "if",
        source: "(83:32) ",
        ctx
      });
      return block;
    } // (80:2) {#if type === 'pill'}


    function create_if_block$g(ctx) {
      let span;
      let t0;
      let t1;
      let pill;
      let current;
      pill = new Pill({
        props: {
          active:
          /*value*/
          ctx[0],
          left:
          /*falseLabel*/
          ctx[3],
          right:
          /*trueLabel*/
          ctx[4]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(
          /*label*/
          ctx[2]);
          t1 = space();
          create_component(pill.$$.fragment);
          attr_dev(span, "class", "label svelte-wt0zqi");
          add_location(span, file$m, 80, 4, 1970);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          insert_dev(target, t1, anchor);
          mount_component(pill, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*label*/
          4) set_data_dev(t0,
          /*label*/
          ctx[2]);
          const pill_changes = {};
          if (dirty &
          /*value*/
          1) pill_changes.active =
          /*value*/
          ctx[0];
          if (dirty &
          /*falseLabel*/
          8) pill_changes.left =
          /*falseLabel*/
          ctx[3];
          if (dirty &
          /*trueLabel*/
          16) pill_changes.right =
          /*trueLabel*/
          ctx[4];
          pill.$set(pill_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(pill.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(pill.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching) detach_dev(t1);
          destroy_component(pill, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$g.name,
        type: "if",
        source: "(80:2) {#if type === 'pill'}",
        ctx
      });
      return block;
    }

    function create_fragment$o(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$g, create_if_block_1$7, create_else_block$9];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*type*/
        ctx[1] === 'pill') return 0;
        if (
        /*type*/
        ctx[1] === 'dropdown') return 1;
        return 2;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          div = element("div");
          if_block.c();
          attr_dev(div, "class", "sidebar-menu-item svelte-wt0zqi");
          toggle_class(div, "active",
          /*value*/
          ctx[0]);
          add_location(div, file$m, 78, 0, 1880);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*click_handler*/
            ctx[10], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }

          if (dirty &
          /*value*/
          1) {
            toggle_class(div, "active",
            /*value*/
            ctx[0]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_blocks[current_block_type_index].d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$o.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function filterSelectItems(label, filterText, option) {
      return [label, ...option.tags].join(' | ').toLowerCase().includes(filterText.toLowerCase());
    }

    function instance$o($$self, $$props, $$invalidate) {
      let $freezeResize;
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(12, $freezeResize = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SidebarMenuItem', slots, []);
      const dispatch = createEventDispatcher();
      let {
        value = false
      } = $$props;
      let {
        type = 'toggle'
      } = $$props;
      let {
        label = ''
      } = $$props;
      let {
        falseLabel
      } = $$props;
      let {
        trueLabel
      } = $$props;
      let {
        options
      } = $$props;
      let selectedOption;

      function onSelect(e) {
        $$invalidate(6, selectedOption = e.detail);
        dispatch('input', selectedOption.value);
        if (document.activeElement) document.activeElement.blur();
      }

      let freezeTimeout;

      function focusIn(e) {
        if (freezeTimeout) clearTimeout(freezeTimeout);
        set_store_value(freezeResize, $freezeResize = true, $freezeResize);
      }

      async function focusOut(e) {
        freezeTimeout = setTimeout(() => {
          set_store_value(freezeResize, $freezeResize = false, $freezeResize);
        }, 500);
      }

      const writable_props = ['value', 'type', 'label', 'falseLabel', 'trueLabel', 'options'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SidebarMenuItem> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble.call(this, $$self, event);
      }

      $$self.$$set = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('type' in $$props) $$invalidate(1, type = $$props.type);
        if ('label' in $$props) $$invalidate(2, label = $$props.label);
        if ('falseLabel' in $$props) $$invalidate(3, falseLabel = $$props.falseLabel);
        if ('trueLabel' in $$props) $$invalidate(4, trueLabel = $$props.trueLabel);
        if ('options' in $$props) $$invalidate(5, options = $$props.options);
      };

      $$self.$capture_state = () => ({
        tick,
        Toggle,
        Pill,
        Select,
        createEventDispatcher,
        freezeResize,
        dispatch,
        value,
        type,
        label,
        falseLabel,
        trueLabel,
        options,
        selectedOption,
        filterSelectItems,
        onSelect,
        freezeTimeout,
        focusIn,
        focusOut,
        $freezeResize
      });

      $$self.$inject_state = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('type' in $$props) $$invalidate(1, type = $$props.type);
        if ('label' in $$props) $$invalidate(2, label = $$props.label);
        if ('falseLabel' in $$props) $$invalidate(3, falseLabel = $$props.falseLabel);
        if ('trueLabel' in $$props) $$invalidate(4, trueLabel = $$props.trueLabel);
        if ('options' in $$props) $$invalidate(5, options = $$props.options);
        if ('selectedOption' in $$props) $$invalidate(6, selectedOption = $$props.selectedOption);
        if ('freezeTimeout' in $$props) freezeTimeout = $$props.freezeTimeout;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*options, value*/
        33) {
          {
            if (options && value) {
              $$invalidate(6, selectedOption = options.find(option => option.value === value));
            }
          }
        }
      };

      return [value, type, label, falseLabel, trueLabel, options, selectedOption, onSelect, focusIn, focusOut, click_handler];
    }

    class SidebarMenuItem extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$o, create_fragment$o, safe_not_equal, {
          value: 0,
          type: 1,
          label: 2,
          falseLabel: 3,
          trueLabel: 4,
          options: 5
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SidebarMenuItem",
          options,
          id: create_fragment$o.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*falseLabel*/
        ctx[3] === undefined && !('falseLabel' in props)) {
          console.warn("<SidebarMenuItem> was created without expected prop 'falseLabel'");
        }

        if (
        /*trueLabel*/
        ctx[4] === undefined && !('trueLabel' in props)) {
          console.warn("<SidebarMenuItem> was created without expected prop 'trueLabel'");
        }

        if (
        /*options*/
        ctx[5] === undefined && !('options' in props)) {
          console.warn("<SidebarMenuItem> was created without expected prop 'options'");
        }
      }

      get value() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set value(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get type() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set type(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get label() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set label(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get falseLabel() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set falseLabel(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get trueLabel() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set trueLabel(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get options() {
        throw new Error("<SidebarMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set options(value) {
        throw new Error("<SidebarMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/Settings.svelte generated by Svelte v3.44.3 */
    const {
      Object: Object_1$2
    } = globals;

    function get_each_context$8(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[10] = list[i];
      return child_ctx;
    } // (90:2) {#if settingConfig[setting]}


    function create_if_block$f(ctx) {
      let sidebarmenuitem;
      let current;
      const sidebarmenuitem_spread_levels = [
      /*getSettings*/
      ctx[4](
      /*setting*/
      ctx[10]), {
        value:
        /*$settings*/
        ctx[0][
        /*setting*/
        ctx[10]]
      }];

      function click_handler() {
        return (
          /*click_handler*/
          ctx[7](
          /*setting*/
          ctx[10])
        );
      }

      function input_handler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (
          /*input_handler*/
          ctx[8](
          /*setting*/
          ctx[10], ...args)
        );
      }

      let sidebarmenuitem_props = {};

      for (let i = 0; i < sidebarmenuitem_spread_levels.length; i += 1) {
        sidebarmenuitem_props = assign(sidebarmenuitem_props, sidebarmenuitem_spread_levels[i]);
      }

      sidebarmenuitem = new SidebarMenuItem({
        props: sidebarmenuitem_props,
        $$inline: true
      });
      sidebarmenuitem.$on("click", click_handler);
      sidebarmenuitem.$on("input", input_handler);
      const block = {
        c: function create() {
          create_component(sidebarmenuitem.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebarmenuitem, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const sidebarmenuitem_changes = dirty &
          /*getSettings, Object, $settings*/
          17 ? get_spread_update(sidebarmenuitem_spread_levels, [get_spread_object(
          /*getSettings*/
          ctx[4](
          /*setting*/
          ctx[10])), dirty &
          /*$settings, Object*/
          1 && {
            value:
            /*$settings*/
            ctx[0][
            /*setting*/
            ctx[10]]
          }]) : {};
          sidebarmenuitem.$set(sidebarmenuitem_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebarmenuitem.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebarmenuitem.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebarmenuitem, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$f.name,
        type: "if",
        source: "(90:2) {#if settingConfig[setting]}",
        ctx
      });
      return block;
    } // (89:0) {#each Object.keys($settings) as setting (setting) }


    function create_each_block$8(key_1, ctx) {
      let first;
      let if_block_anchor;
      let current;
      let if_block =
      /*settingConfig*/
      ctx[1][
      /*setting*/
      ctx[10]] && create_if_block$f(ctx);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (
          /*settingConfig*/
          ctx[1][
          /*setting*/
          ctx[10]]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*settingConfig, $settings*/
              3) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$f(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$8.name,
        type: "each",
        source: "(89:0) {#each Object.keys($settings) as setting (setting) }",
        ctx
      });
      return block;
    }

    function create_fragment$n(ctx) {
      let each_blocks = [];
      let each_1_lookup = new Map();
      let each_1_anchor;
      let current;
      let each_value = Object.keys(
      /*$settings*/
      ctx[0]);
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*setting*/
      ctx[10];

      validate_each_keys(ctx, each_value, get_each_context$8, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$8(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*getSettings, Object, $settings, toggle, onChange, settingConfig*/
          31) {
            each_value = Object.keys(
            /*$settings*/
            ctx[0]);
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$8, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$8, each_1_anchor, get_each_context$8);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d(detaching);
          }

          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$n.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
      let $settings;
      let $exchangeRates;
      let $haveMessages;
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(0, $settings = $$value));
      validate_store(exchangeRates, 'exchangeRates');
      component_subscribe($$self, exchangeRates, $$value => $$invalidate(5, $exchangeRates = $$value));
      validate_store(haveMessages, 'haveMessages');
      component_subscribe($$self, haveMessages, $$value => $$invalidate(6, $haveMessages = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Settings', slots, []);

      function toggle(setting) {
        if (settingConfig[setting] != null && settingConfig[setting].valueType === 'bool') {
          onChange(setting, !$settings[setting]);
        }
      }

      function onChange(setting, value) {
        set_store_value(settings, $settings[setting] = value, $settings);
        analytics.trackEvent('settings', setting, $settings[setting]);
      }

      const currencyOptions = Object.keys(currencies).map(code => {
        return {
          value: code,
          label: `${currencies[code].char} ${currencies[code].name}`,
          tags: [code, currencies[code].name, ...currencies[code].countries]
        };
      });
      let settingConfig = {
        showNetworkStatus: {
          label: 'Network Status',
          valueType: 'bool'
        },
        darkMode: {
          label: 'Dark Mode',
          valueType: 'bool'
        },
        currency: {
          label: 'Fiat Currency',
          type: 'dropdown',
          valueType: 'string',
          options: currencyOptions
        },
        vbytes: {
          label: 'Size by',
          type: 'pill',
          falseLabel: 'value',
          trueLabel: 'vbytes',
          valueType: 'bool'
        },
        colorByFee: {
          label: 'Color by',
          type: 'pill',
          falseLabel: 'age',
          trueLabel: 'fee rate',
          valueType: 'bool'
        },
        showSearch: {
          label: 'Search Bar',
          valueType: 'bool'
        }
      };

      function getSettings(setting) {
        return settingConfig[setting] || {};
      }

      const writable_props = [];
      Object_1$2.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Settings> was created with unknown prop '${key}'`);
      });

      const click_handler = setting => {
        toggle(setting);
      };

      const input_handler = (setting, e) => {
        onChange(setting, e.detail);
      };

      $$self.$capture_state = () => ({
        config: config$1,
        analytics,
        SidebarMenuItem,
        settings,
        exchangeRates,
        haveMessages,
        currencies,
        toggle,
        onChange,
        currencyOptions,
        settingConfig,
        getSettings,
        $settings,
        $exchangeRates,
        $haveMessages
      });

      $$self.$inject_state = $$props => {
        if ('settingConfig' in $$props) $$invalidate(1, settingConfig = $$props.settingConfig);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$haveMessages*/
        64) {
          {
            if (config$1.messagesEnabled && $haveMessages) {
              $$invalidate(1, settingConfig.showMessages = {
                label: 'Message Bar',
                valueType: 'bool'
              }, settingConfig);
            }
          }
        }

        if ($$self.$$.dirty &
        /*$exchangeRates, $settings*/
        33) {
          {
            const rate = $exchangeRates[$settings.currency];

            if (rate && rate.last) {
              $$invalidate(1, settingConfig.showFX = {
                label: '₿ Price',
                valueType: 'bool'
              }, settingConfig);
            } else {
              $$invalidate(1, settingConfig.showFX = false, settingConfig);
            }
          }
        }
      };

      return [$settings, settingConfig, toggle, onChange, getSettings, $exchangeRates, $haveMessages, click_handler, input_handler];
    }

    class Settings extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$n, create_fragment$n, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Settings",
          options,
          id: create_fragment$n.name
        });
      }

    }

    var cogIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M245.151,168a88,88,0,1,0,88,88A88.1,88.1,0,0,0,245.151,168Zm0,144a56,56,0,1,1,56-56A56.063,56.063,0,0,1,245.151,312Z" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M464.7,322.319l-31.77-26.153a193.081,193.081,0,0,0,0-80.332l31.77-26.153a19.941,19.941,0,0,0,4.606-25.439l-32.612-56.483a19.936,19.936,0,0,0-24.337-8.73l-38.561,14.447a192.038,192.038,0,0,0-69.54-40.192L297.49,32.713A19.936,19.936,0,0,0,277.762,16H212.54a19.937,19.937,0,0,0-19.728,16.712L186.05,73.284a192.03,192.03,0,0,0-69.54,40.192L77.945,99.027a19.937,19.937,0,0,0-24.334,8.731L21,164.245a19.94,19.94,0,0,0,4.61,25.438l31.767,26.151a193.081,193.081,0,0,0,0,80.332l-31.77,26.153A19.942,19.942,0,0,0,21,347.758l32.612,56.483a19.937,19.937,0,0,0,24.337,8.73l38.562-14.447a192.03,192.03,0,0,0,69.54,40.192l6.762,40.571A19.937,19.937,0,0,0,212.54,496h65.222a19.936,19.936,0,0,0,19.728-16.712l6.763-40.572a192.038,192.038,0,0,0,69.54-40.192l38.564,14.449a19.938,19.938,0,0,0,24.334-8.731L469.3,347.755A19.939,19.939,0,0,0,464.7,322.319Zm-50.636,57.12-48.109-18.024-7.285,7.334a159.955,159.955,0,0,1-72.625,41.973l-10,2.636L267.6,464h-44.89l-8.442-50.642-10-2.636a159.955,159.955,0,0,1-72.625-41.973l-7.285-7.334L76.241,379.439,53.8,340.562l39.629-32.624-2.7-9.973a160.9,160.9,0,0,1,0-83.93l2.7-9.972L53.8,171.439l22.446-38.878,48.109,18.024,7.285-7.334a159.955,159.955,0,0,1,72.625-41.973l10-2.636L222.706,48H267.6l8.442,50.642,10,2.636a159.955,159.955,0,0,1,72.625,41.973l7.285,7.334,48.109-18.024,22.447,38.877-39.629,32.625,2.7,9.972a160.9,160.9,0,0,1,0,83.93l-2.7,9.973,39.629,32.623Z" class="ci-primary"/></svg>';

    /* src/components/DevTools.svelte generated by Svelte v3.44.3 */

    function create_if_block$e(ctx) {
      let sidebarmenuitem;
      let current;
      sidebarmenuitem = new SidebarMenuItem({
        props: {
          active:
          /*$devSettings*/
          ctx[0].layoutHints,
          label: "Debug Layout"
        },
        $$inline: true
      });
      sidebarmenuitem.$on("click",
      /*click_handler_1*/
      ctx[6]);
      const block = {
        c: function create() {
          create_component(sidebarmenuitem.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebarmenuitem, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const sidebarmenuitem_changes = {};
          if (dirty &
          /*$devSettings*/
          1) sidebarmenuitem_changes.active =
          /*$devSettings*/
          ctx[0].layoutHints;
          sidebarmenuitem.$set(sidebarmenuitem_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebarmenuitem.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebarmenuitem.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebarmenuitem, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$e.name,
        type: "if",
        source: "(26:0) {#if config.layoutHints}",
        ctx
      });
      return block;
    }

    function create_fragment$m(ctx) {
      let sidebarmenuitem0;
      let t0;
      let sidebarmenuitem1;
      let t1;
      let sidebarmenuitem2;
      let t2;
      let sidebarmenuitem3;
      let t3;
      let if_block_anchor;
      let current;
      sidebarmenuitem0 = new SidebarMenuItem({
        props: {
          label: "Add One"
        },
        $$inline: true
      });
      sidebarmenuitem0.$on("click",
      /*addOne*/
      ctx[1]);
      sidebarmenuitem1 = new SidebarMenuItem({
        props: {
          label: "Add Many"
        },
        $$inline: true
      });
      sidebarmenuitem1.$on("click",
      /*addMany*/
      ctx[2]);
      sidebarmenuitem2 = new SidebarMenuItem({
        props: {
          label: "Add Block"
        },
        $$inline: true
      });
      sidebarmenuitem2.$on("click",
      /*addBlock*/
      ctx[3]);
      sidebarmenuitem3 = new SidebarMenuItem({
        props: {
          active:
          /*$devSettings*/
          ctx[0].guides,
          label: "Guides"
        },
        $$inline: true
      });
      sidebarmenuitem3.$on("click",
      /*click_handler*/
      ctx[5]);
      let if_block = config$1.layoutHints && create_if_block$e(ctx);
      const block = {
        c: function create() {
          create_component(sidebarmenuitem0.$$.fragment);
          t0 = space();
          create_component(sidebarmenuitem1.$$.fragment);
          t1 = space();
          create_component(sidebarmenuitem2.$$.fragment);
          t2 = space();
          create_component(sidebarmenuitem3.$$.fragment);
          t3 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(sidebarmenuitem0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(sidebarmenuitem1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(sidebarmenuitem2, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(sidebarmenuitem3, target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          const sidebarmenuitem3_changes = {};
          if (dirty &
          /*$devSettings*/
          1) sidebarmenuitem3_changes.active =
          /*$devSettings*/
          ctx[0].guides;
          sidebarmenuitem3.$set(sidebarmenuitem3_changes);
          if (config$1.layoutHints) if_block.p(ctx, dirty);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebarmenuitem0.$$.fragment, local);
          transition_in(sidebarmenuitem1.$$.fragment, local);
          transition_in(sidebarmenuitem2.$$.fragment, local);
          transition_in(sidebarmenuitem3.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebarmenuitem0.$$.fragment, local);
          transition_out(sidebarmenuitem1.$$.fragment, local);
          transition_out(sidebarmenuitem2.$$.fragment, local);
          transition_out(sidebarmenuitem3.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebarmenuitem0, detaching);
          if (detaching) detach_dev(t0);
          destroy_component(sidebarmenuitem1, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(sidebarmenuitem2, detaching);
          if (detaching) detach_dev(t2);
          destroy_component(sidebarmenuitem3, detaching);
          if (detaching) detach_dev(t3);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$m.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
      let $devSettings;
      let $devEvents;
      validate_store(devSettings, 'devSettings');
      component_subscribe($$self, devSettings, $$value => $$invalidate(0, $devSettings = $$value));
      validate_store(devEvents, 'devEvents');
      component_subscribe($$self, devEvents, $$value => $$invalidate(7, $devEvents = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('DevTools', slots, []);

      function addOne() {
        if ($devEvents.addOneCallback) $devEvents.addOneCallback();
      }

      function addMany() {
        if ($devEvents.addOneCallback) $devEvents.addManyCallback();
      }

      function addBlock() {
        if ($devEvents.addOneCallback) $devEvents.addBlockCallback();
      }

      function toggle(setting) {
        set_store_value(devSettings, $devSettings[setting] = !$devSettings[setting], $devSettings);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DevTools> was created with unknown prop '${key}'`);
      });

      const click_handler = () => {
        toggle('guides');
      };

      const click_handler_1 = () => {
        toggle('layoutHints');
      };

      $$self.$capture_state = () => ({
        SidebarMenuItem,
        devEvents,
        devSettings,
        config: config$1,
        addOne,
        addMany,
        addBlock,
        toggle,
        $devSettings,
        $devEvents
      });

      return [$devSettings, addOne, addMany, addBlock, toggle, click_handler, click_handler_1];
    }

    class DevTools extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$m, create_fragment$m, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "DevTools",
          options,
          id: create_fragment$m.name
        });
      }

    }

    var codeIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <polygon fill="var(--ci-primary-color, currentColor)" points="388.632 393.82 495.823 255.94 388.684 118.178 363.424 137.822 455.288 255.944 363.368 374.18 388.632 393.82" class="ci-primary"/>  <polygon fill="var(--ci-primary-color, currentColor)" points="148.579 374.181 56.712 255.999 148.629 137.823 123.371 118.177 16.177 255.993 123.314 393.819 148.579 374.181" class="ci-primary"/>  <polygon fill="var(--ci-primary-color, currentColor)" points="330.529 16 297.559 16 178.441 496 211.412 496 330.529 16" class="ci-primary"/></svg>';

    var questionIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>';

    var infoIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';

    var atIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M495.826,232a206.644,206.644,0,0,0-18.882-78.412,227.033,227.033,0,0,0-51.61-71.261C379.708,39.555,319.571,16,256,16A240,240,0,0,0,86.294,425.706a240,240,0,0,0,337.671,1.722l-22.4-22.856A206.824,206.824,0,0,1,256,464C141.309,464,48,370.691,48,256S141.309,48,256,48c112.748,0,208,87.925,208,192v36c0,28.673-25.122,52-56,52s-56-23.327-56-52V160H320v26.751a99.988,99.988,0,1,0,12.55,132.437C347.956,343.62,376.01,360,408,360c48.523,0,88-37.682,88-84V232ZM252,328a68,68,0,1,1,68-68A68.077,68.077,0,0,1,252,328Z" class="ci-primary"/></svg>';

    var peopleIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M462.541,316.3l-64.344-42.1,24.774-45.418A79.124,79.124,0,0,0,432.093,192V120A103.941,103.941,0,0,0,257.484,43.523L279.232,67a71.989,71.989,0,0,1,120.861,53v72a46.809,46.809,0,0,1-5.215,21.452L355.962,284.8l89.058,58.274a42.16,42.16,0,0,1,19.073,35.421V432h-72v32h104V378.494A74.061,74.061,0,0,0,462.541,316.3Z" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M318.541,348.3l-64.343-42.1,24.773-45.418A79.124,79.124,0,0,0,288.093,224V152A104.212,104.212,0,0,0,184.04,47.866C126.723,47.866,80.093,94.581,80.093,152v72a78,78,0,0,0,9.015,36.775l24.908,45.664L50.047,348.3A74.022,74.022,0,0,0,16.5,410.4L16,496H352.093V410.494A74.061,74.061,0,0,0,318.541,348.3ZM320.093,464H48.186l.31-53.506a42.158,42.158,0,0,1,19.073-35.421l88.682-58.029L117.2,245.452A46.838,46.838,0,0,1,112.093,224V152a72,72,0,1,1,144,0v72a46.809,46.809,0,0,1-5.215,21.452L211.962,316.8l89.058,58.274a42.16,42.16,0,0,1,19.073,35.421Z" class="ci-primary"/></svg>';

    var giftIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M472,128H371.833A71.962,71.962,0,0,0,256,42.815,71.962,71.962,0,0,0,140.167,128H40a24.028,24.028,0,0,0-24,24V473.556C16,485.932,26.767,496,40,496H472c13.233,0,24-10.068,24-22.444V152A24.028,24.028,0,0,0,472,128ZM312,48a40,40,0,0,1,0,80H272V88A40.045,40.045,0,0,1,312,48ZM160,88a40,40,0,0,1,80,0v40H200A40.045,40.045,0,0,1,160,88ZM48,464V256H192V464Zm176,0V256h64V464Zm240,0H320V256H464ZM48,224V160H464v64Z" class="ci-primary"/></svg>';

    var constant = (x => () => x);

    function linear(a, d) {
      return function (t) {
        return a + t * d;
      };
    }

    function hue(a, b) {
      var d = b - a;
      return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant(isNaN(a) ? b : a);
    }

    function hcl(hue) {
      return function (start, end) {
        var h = hue((start = hcl$1(start)).h, (end = hcl$1(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      };
    }

    var interpolateHcl = hcl(hue);

    /* src/components/MempoolLegend.svelte generated by Svelte v3.44.3 */
    const {
      window: window_1$1
    } = globals;
    const file$l = "src/components/MempoolLegend.svelte";

    function get_each_context_1$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[19] = list[i].size;
      child_ctx[23] = list[i].value;
      return child_ctx;
    }

    function get_each_context$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[19] = list[i].size;
      child_ctx[20] = list[i].vbytes;
      return child_ctx;
    } // (167:2) {:else}


    function create_else_block_3$2(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Total Value";
          attr_dev(h3, "class", "subheading");
          add_location(h3, file$l, 167, 4, 4246);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_3$2.name,
        type: "else",
        source: "(167:2) {:else}",
        ctx
      });
      return block;
    } // (165:2) {#if $settings.vbytes}


    function create_if_block_3$4(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Size in vBytes";
          attr_dev(h3, "class", "subheading");
          add_location(h3, file$l, 165, 4, 4189);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$4.name,
        type: "if",
        source: "(165:2) {#if $settings.vbytes}",
        ctx
      });
      return block;
    } // (178:4) {:else}


    function create_else_block_2$2(ctx) {
      let each_1_anchor;
      let each_value_1 =
      /*sizes*/
      ctx[1];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*formatValue, sizes, squareColor*/
          18) {
            each_value_1 =
            /*sizes*/
            ctx[1];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$2.name,
        type: "else",
        source: "(178:4) {:else}",
        ctx
      });
      return block;
    } // (171:4) {#if $settings.vbytes }


    function create_if_block_2$5(ctx) {
      let each_1_anchor;
      let each_value =
      /*sizes*/
      ctx[1];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*formatBytes, sizes, squareColor*/
          146) {
            each_value =
            /*sizes*/
            ctx[1];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$7(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$7(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$5.name,
        type: "if",
        source: "(171:4) {#if $settings.vbytes }",
        ctx
      });
      return block;
    } // (179:6) {#each sizes as { size, value }


    function create_each_block_1$3(ctx) {
      let div1;
      let span0;
      let div0;
      let t0;
      let span4;
      let span1;
      let t2;
      let span2;
      let span3;
      let t4_value = formatValue(
      /*value*/
      ctx[23]) + "";
      let t4;
      let t5;
      const block = {
        c: function create() {
          div1 = element("div");
          span0 = element("span");
          div0 = element("div");
          t0 = space();
          span4 = element("span");
          span1 = element("span");
          span1.textContent = "<";
          t2 = space();
          span2 = element("span");
          span2.textContent = "₿";
          span3 = element("span");
          t4 = text(t4_value);
          t5 = space();
          attr_dev(div0, "class", "square svelte-99n3xq");
          set_style(div0, "width",
          /*size*/
          ctx[19] + "px");
          set_style(div0, "height",
          /*size*/
          ctx[19] + "px");
          set_style(div0, "background",
          /*squareColor*/
          ctx[4]);
          add_location(div0, file$l, 180, 41, 4883);
          attr_dev(span0, "class", "square-container svelte-99n3xq");
          add_location(span0, file$l, 180, 10, 4852);
          attr_dev(span1, "class", "part left");
          add_location(span1, file$l, 181, 30, 5012);
          attr_dev(span2, "class", "part center");
          add_location(span2, file$l, 181, 66, 5048);
          attr_dev(span3, "class", "part right svelte-99n3xq");
          add_location(span3, file$l, 181, 106, 5088);
          attr_dev(span4, "class", "value svelte-99n3xq");
          add_location(span4, file$l, 181, 10, 4992);
          attr_dev(div1, "class", "size-row svelte-99n3xq");
          add_location(div1, file$l, 179, 8, 4819);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, span0);
          append_dev(span0, div0);
          append_dev(div1, t0);
          append_dev(div1, span4);
          append_dev(span4, span1);
          append_dev(span4, t2);
          append_dev(span4, span2);
          append_dev(span4, span3);
          append_dev(span3, t4);
          append_dev(div1, t5);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*sizes*/
          2) {
            set_style(div0, "width",
            /*size*/
            ctx[19] + "px");
          }

          if (dirty &
          /*sizes*/
          2) {
            set_style(div0, "height",
            /*size*/
            ctx[19] + "px");
          }

          if (dirty &
          /*squareColor*/
          16) {
            set_style(div0, "background",
            /*squareColor*/
            ctx[4]);
          }

          if (dirty &
          /*sizes*/
          2 && t4_value !== (t4_value = formatValue(
          /*value*/
          ctx[23]) + "")) set_data_dev(t4, t4_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$3.name,
        type: "each",
        source: "(179:6) {#each sizes as { size, value }",
        ctx
      });
      return block;
    } // (172:6) {#each sizes as { size, vbytes }


    function create_each_block$7(ctx) {
      let div1;
      let span0;
      let div0;
      let t0;
      let span4;
      let span1;
      let span2;
      let span3;
      let t3_value =
      /*formatBytes*/
      ctx[7](
      /*vbytes*/
      ctx[20]) + "";
      let t3;
      let t4;
      const block = {
        c: function create() {
          div1 = element("div");
          span0 = element("span");
          div0 = element("div");
          t0 = space();
          span4 = element("span");
          span1 = element("span");
          span1.textContent = "<";
          span2 = element("span");
          span2.textContent = " ";
          span3 = element("span");
          t3 = text(t3_value);
          t4 = space();
          attr_dev(div0, "class", "square svelte-99n3xq");
          set_style(div0, "width",
          /*size*/
          ctx[19] + "px");
          set_style(div0, "height",
          /*size*/
          ctx[19] + "px");
          set_style(div0, "background",
          /*squareColor*/
          ctx[4]);
          add_location(div0, file$l, 173, 41, 4463);
          attr_dev(span0, "class", "square-container svelte-99n3xq");
          add_location(span0, file$l, 173, 10, 4432);
          attr_dev(span1, "class", "part left");
          add_location(span1, file$l, 174, 30, 4593);
          attr_dev(span2, "class", "part center");
          add_location(span2, file$l, 174, 65, 4628);
          attr_dev(span3, "class", "part right svelte-99n3xq");
          add_location(span3, file$l, 174, 104, 4667);
          attr_dev(span4, "class", "value svelte-99n3xq");
          add_location(span4, file$l, 174, 10, 4573);
          attr_dev(div1, "class", "size-row svelte-99n3xq");
          add_location(div1, file$l, 172, 8, 4399);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, span0);
          append_dev(span0, div0);
          append_dev(div1, t0);
          append_dev(div1, span4);
          append_dev(span4, span1);
          append_dev(span4, span2);
          append_dev(span4, span3);
          append_dev(span3, t3);
          append_dev(div1, t4);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*sizes*/
          2) {
            set_style(div0, "width",
            /*size*/
            ctx[19] + "px");
          }

          if (dirty &
          /*sizes*/
          2) {
            set_style(div0, "height",
            /*size*/
            ctx[19] + "px");
          }

          if (dirty &
          /*squareColor*/
          16) {
            set_style(div0, "background",
            /*squareColor*/
            ctx[4]);
          }

          if (dirty &
          /*sizes*/
          2 && t3_value !== (t3_value =
          /*formatBytes*/
          ctx[7](
          /*vbytes*/
          ctx[20]) + "")) set_data_dev(t3, t3_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$7.name,
        type: "each",
        source: "(172:6) {#each sizes as { size, vbytes }",
        ctx
      });
      return block;
    } // (189:2) {:else}


    function create_else_block_1$3(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Fee rate in sats/vbyte";
          attr_dev(h3, "class", "subheading");
          add_location(h3, file$l, 189, 4, 5288);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$3.name,
        type: "else",
        source: "(189:2) {:else}",
        ctx
      });
      return block;
    } // (187:2) {#if $colorMode === 'age'}


    function create_if_block_1$6(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "Age in seconds";
          attr_dev(h3, "class", "subheading");
          add_location(h3, file$l, 187, 4, 5231);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$6.name,
        type: "if",
        source: "(187:2) {#if $colorMode === 'age'}",
        ctx
      });
      return block;
    } // (197:4) {:else}


    function create_else_block$8(ctx) {
      let span0;
      let t1;
      let img;
      let img_src_value;
      let t2;
      let span1;
      const block = {
        c: function create() {
          span0 = element("span");
          span0.textContent = "1";
          t1 = space();
          img = element("img");
          t2 = space();
          span1 = element("span");
          span1.textContent = "128+";
          attr_dev(span0, "class", "value left svelte-99n3xq");
          add_location(span0, file$l, 197, 6, 5592);
          if (!src_url_equal(img.src, img_src_value =
          /*feeColorScale*/
          ctx[3])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "class", "color-scale-img svelte-99n3xq");
          attr_dev(img, "width", "200");
          attr_dev(img, "height", "15");
          add_location(img, file$l, 198, 6, 5632);
          attr_dev(span1, "class", "value right svelte-99n3xq");
          add_location(span1, file$l, 199, 6, 5719);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, img, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, span1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*feeColorScale*/
          8 && !src_url_equal(img.src, img_src_value =
          /*feeColorScale*/
          ctx[3])) {
            attr_dev(img, "src", img_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(span1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$8.name,
        type: "else",
        source: "(197:4) {:else}",
        ctx
      });
      return block;
    } // (193:4) {#if $colorMode === 'age'}


    function create_if_block$d(ctx) {
      let span0;
      let t1;
      let img;
      let img_src_value;
      let t2;
      let span1;
      const block = {
        c: function create() {
          span0 = element("span");
          span0.textContent = "0";
          t1 = space();
          img = element("img");
          t2 = space();
          span1 = element("span");
          span1.textContent = "60+";
          attr_dev(span0, "class", "value left svelte-99n3xq");
          add_location(span0, file$l, 193, 6, 5413);
          if (!src_url_equal(img.src, img_src_value =
          /*colorScale*/
          ctx[2])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "class", "color-scale-img svelte-99n3xq");
          attr_dev(img, "width", "200");
          attr_dev(img, "height", "15");
          add_location(img, file$l, 194, 6, 5453);
          attr_dev(span1, "class", "value right svelte-99n3xq");
          add_location(span1, file$l, 195, 6, 5537);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, img, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, span1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*colorScale*/
          4 && !src_url_equal(img.src, img_src_value =
          /*colorScale*/
          ctx[2])) {
            attr_dev(img, "src", img_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(span1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$d.name,
        type: "if",
        source: "(193:4) {#if $colorMode === 'age'}",
        ctx
      });
      return block;
    }

    function create_fragment$l(ctx) {
      let div2;
      let t0;
      let div0;
      let t1;
      let t2;
      let div1;
      let mounted;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (
        /*$settings*/
        ctx[5].vbytes) return create_if_block_3$4;
        return create_else_block_3$2;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);

      function select_block_type_1(ctx, dirty) {
        if (
        /*$settings*/
        ctx[5].vbytes) return create_if_block_2$5;
        return create_else_block_2$2;
      }

      let current_block_type_1 = select_block_type_1(ctx);
      let if_block1 = current_block_type_1(ctx);

      function select_block_type_2(ctx, dirty) {
        if (
        /*$colorMode*/
        ctx[0] === 'age') return create_if_block_1$6;
        return create_else_block_1$3;
      }

      let current_block_type_2 = select_block_type_2(ctx);
      let if_block2 = current_block_type_2(ctx);

      function select_block_type_3(ctx, dirty) {
        if (
        /*$colorMode*/
        ctx[0] === 'age') return create_if_block$d;
        return create_else_block$8;
      }

      let current_block_type_3 = select_block_type_3(ctx);
      let if_block3 = current_block_type_3(ctx);
      const block = {
        c: function create() {
          div2 = element("div");
          if_block0.c();
          t0 = space();
          div0 = element("div");
          if_block1.c();
          t1 = space();
          if_block2.c();
          t2 = space();
          div1 = element("div");
          if_block3.c();
          attr_dev(div0, "class", "size-legend svelte-99n3xq");
          add_location(div0, file$l, 169, 2, 4296);
          attr_dev(div1, "class", "color-legend svelte-99n3xq");
          add_location(div1, file$l, 191, 2, 5349);
          attr_dev(div2, "class", "legend tab-content svelte-99n3xq");
          add_location(div2, file$l, 163, 0, 4127);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          if_block0.m(div2, null);
          append_dev(div2, t0);
          append_dev(div2, div0);
          if_block1.m(div0, null);
          append_dev(div2, t1);
          if_block2.m(div2, null);
          append_dev(div2, t2);
          append_dev(div2, div1);
          if_block3.m(div1, null);

          if (!mounted) {
            dispose = listen_dev(window_1$1, "resize",
            /*resize*/
            ctx[6], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (current_block_type !== (current_block_type = select_block_type(ctx))) {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div2, t0);
            }
          }

          if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1.d(1);
            if_block1 = current_block_type_1(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(div0, null);
            }
          }

          if (current_block_type_2 !== (current_block_type_2 = select_block_type_2(ctx))) {
            if_block2.d(1);
            if_block2 = current_block_type_2(ctx);

            if (if_block2) {
              if_block2.c();
              if_block2.m(div2, t2);
            }
          }

          if (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {
            if_block3.p(ctx, dirty);
          } else {
            if_block3.d(1);
            if_block3 = current_block_type_3(ctx);

            if (if_block3) {
              if_block3.c();
              if_block3.m(div1, null);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          if_block0.d();
          if_block1.d();
          if_block2.d();
          if_block3.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$l.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const colorScaleWidth = 200;

    function formatValue(value) {
      const btc = value / 100000000;
      const str = btc < 1 ? btc.toPrecision(1) : `${Math.floor(btc)}`;
      const units = str.split('.')[0].length;
      const padded = str.padEnd(3 + units, ' ').padStart(6, ' ');
      return padded;
    }

    function instance$l($$self, $$props, $$invalidate) {
      let $settings;
      let $colorMode;
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(5, $settings = $$value));
      validate_store(colorMode, 'colorMode');
      component_subscribe($$self, colorMode, $$value => $$invalidate(0, $colorMode = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('MempoolLegend', slots, []);
      const orangeHex = hlToHex(orange);
      const tealHex = hlToHex(teal);
      const blueHex = hlToHex(blue);
      const greenHex = hlToHex(green);
      const purpleHex = hlToHex(purple);
      const sizes = [{
        value: 1000000,
        vbytes: 1 * 256,
        size: null
      }, {
        value: 10000000,
        vbytes: 4 * 256,
        size: null
      }, {
        value: 100000000,
        vbytes: 9 * 256,
        size: null
      }, {
        value: 1000000000,
        vbytes: 16 * 256,
        size: null
      }, {
        value: 10000000000,
        vbytes: 25 * 256,
        size: null
      }];
      let unitWidth;
      let unitPadding;
      let gridSize;
      let colorScale;
      let feeColorScale;
      let squareColor = orangeHex;

      function resize() {
        $$invalidate(8, unitWidth = Math.floor(Math.max(4, (window.innerWidth - 20) / 250)));
        $$invalidate(9, unitPadding = Math.floor(Math.max(1, (window.innerWidth - 20) / 1000)));
        $$invalidate(10, gridSize = unitWidth + unitPadding * 2);
      }

      resize();
      onMount(() => {
        resize();
        $$invalidate(2, colorScale = generateColorScale(orangeHex, blueHex));
        $$invalidate(3, feeColorScale = generateColorScale(tealHex, purpleHex));
      });

      function calcSizes(gridSize, unitWidth, unitPadding) {
        sizes.forEach(size => {
          size.size = calcSize(size);
        });
        $$invalidate(1, sizes);
      }

      function calcSize(_ref2) {
        let {
          vbytes,
          value
        } = _ref2;

        if ($settings.vbytes) {
          return 2 * (byteTxSize(vbytes - 1, Infinity) * gridSize / 2 - unitPadding);
        } else {
          return 2 * (logTxSize(value - 1) * gridSize / 2 - unitPadding);
        }
      }

      function formatBytes(bytes) {
        const str = numberFormat.format(bytes) + ' vbytes';
        const padded = str.padStart(13, ' ');
        return padded;
      }

      function generateColorScale(colorA, colorB) {
        const canvas = document.createElement('canvas');
        const width = colorScaleWidth;
        canvas.width = width;
        canvas.height = 1;
        const interpolator = interpolateHcl(colorA, colorB);
        const colorData = new Uint8ClampedArray(width * 4);

        for (let i = 0; i < width; i++) {
          let rgb = color(interpolator(i / width)).rgb();
          colorData[i * 4] = rgb.r;
          colorData[i * 4 + 1] = rgb.g;
          colorData[i * 4 + 2] = rgb.b;
          colorData[i * 4 + 3] = 255;
        }

        const imageData = new ImageData(colorData, width);
        canvas.getContext("2d").putImageData(imageData, 0, 0);
        const scalePng = canvas.toDataURL();
        canvas.remove();
        return scalePng;
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MempoolLegend> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        onMount,
        settings,
        colorMode,
        numberFormat,
        logTxSize,
        byteTxSize,
        interpolateHcl,
        color,
        hcl: hcl$1,
        hlToHex,
        orange,
        teal,
        blue,
        green,
        purple,
        orangeHex,
        tealHex,
        blueHex,
        greenHex,
        purpleHex,
        sizes,
        unitWidth,
        unitPadding,
        gridSize,
        colorScale,
        feeColorScale,
        colorScaleWidth,
        squareColor,
        resize,
        calcSizes,
        calcSize,
        formatBytes,
        formatValue,
        generateColorScale,
        $settings,
        $colorMode
      });

      $$self.$inject_state = $$props => {
        if ('unitWidth' in $$props) $$invalidate(8, unitWidth = $$props.unitWidth);
        if ('unitPadding' in $$props) $$invalidate(9, unitPadding = $$props.unitPadding);
        if ('gridSize' in $$props) $$invalidate(10, gridSize = $$props.gridSize);
        if ('colorScale' in $$props) $$invalidate(2, colorScale = $$props.colorScale);
        if ('feeColorScale' in $$props) $$invalidate(3, feeColorScale = $$props.feeColorScale);
        if ('squareColor' in $$props) $$invalidate(4, squareColor = $$props.squareColor);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$colorMode*/
        1) {
          {
            if ($colorMode === 'age') $$invalidate(4, squareColor = orangeHex);else $$invalidate(4, squareColor = purpleHex);
          }
        }

        if ($$self.$$.dirty &
        /*gridSize, unitWidth, unitPadding*/
        1792) {
          {
            calcSizes();
          }
        }
      };

      return [$colorMode, sizes, colorScale, feeColorScale, squareColor, $settings, resize, formatBytes, unitWidth, unitPadding, gridSize];
    }

    class MempoolLegend extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$l, create_fragment$l, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MempoolLegend",
          options,
          id: create_fragment$l.name
        });
      }

    }

    /* src/components/SocialLink.svelte generated by Svelte v3.44.3 */
    const file$k = "src/components/SocialLink.svelte";

    function create_fragment$k(ctx) {
      let a;
      let span0;
      let icon_1;
      let t;
      let span1;
      let current;
      icon_1 = new Icon({
        props: {
          icon:
          /*icon*/
          ctx[2],
          color:
          /*color*/
          ctx[1]
        },
        $$inline: true
      });
      const default_slot_template =
      /*#slots*/
      ctx[4].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[3], null);
      const block = {
        c: function create() {
          a = element("a");
          span0 = element("span");
          create_component(icon_1.$$.fragment);
          t = space();
          span1 = element("span");
          if (default_slot) default_slot.c();
          attr_dev(span0, "class", "social-icon svelte-1gvsk1c");
          add_location(span0, file$k, 39, 2, 824);
          attr_dev(span1, "class", "handle svelte-1gvsk1c");
          add_location(span1, file$k, 42, 2, 890);
          attr_dev(a, "class", "social-link svelte-1gvsk1c");
          attr_dev(a, "target", "_blank");
          attr_dev(a, "href",
          /*href*/
          ctx[0]);
          attr_dev(a, "rel", "noopener");
          set_style(a, "background",
          /*color*/
          ctx[1]);
          add_location(a, file$k, 38, 0, 732);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, span0);
          mount_component(icon_1, span0, null);
          append_dev(a, t);
          append_dev(a, span1);

          if (default_slot) {
            default_slot.m(span1, null);
          }

          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          const icon_1_changes = {};
          if (dirty &
          /*icon*/
          4) icon_1_changes.icon =
          /*icon*/
          ctx[2];
          if (dirty &
          /*color*/
          2) icon_1_changes.color =
          /*color*/
          ctx[1];
          icon_1.$set(icon_1_changes);

          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope*/
            8)) {
              update_slot_base(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[3], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]) : get_slot_changes(default_slot_template,
              /*$$scope*/
              ctx[3], dirty, null), null);
            }
          }

          if (!current || dirty &
          /*href*/
          1) {
            attr_dev(a, "href",
            /*href*/
            ctx[0]);
          }

          if (!current || dirty &
          /*color*/
          2) {
            set_style(a, "background",
            /*color*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon_1.$$.fragment, local);
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon_1.$$.fragment, local);
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(icon_1);
          if (default_slot) default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$k.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SocialLink', slots, ['default']);
      let {
        href
      } = $$props;
      let {
        color
      } = $$props;
      let {
        icon
      } = $$props;
      const writable_props = ['href', 'color', 'icon'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SocialLink> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('href' in $$props) $$invalidate(0, href = $$props.href);
        if ('color' in $$props) $$invalidate(1, color = $$props.color);
        if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
        if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        Icon,
        href,
        color,
        icon
      });

      $$self.$inject_state = $$props => {
        if ('href' in $$props) $$invalidate(0, href = $$props.href);
        if ('color' in $$props) $$invalidate(1, color = $$props.color);
        if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [href, color, icon, $$scope, slots];
    }

    class SocialLink extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$k, create_fragment$k, safe_not_equal, {
          href: 0,
          color: 1,
          icon: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SocialLink",
          options,
          id: create_fragment$k.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*href*/
        ctx[0] === undefined && !('href' in props)) {
          console.warn("<SocialLink> was created without expected prop 'href'");
        }

        if (
        /*color*/
        ctx[1] === undefined && !('color' in props)) {
          console.warn("<SocialLink> was created without expected prop 'color'");
        }

        if (
        /*icon*/
        ctx[2] === undefined && !('icon' in props)) {
          console.warn("<SocialLink> was created without expected prop 'icon'");
        }
      }

      get href() {
        throw new Error("<SocialLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set href(value) {
        throw new Error("<SocialLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get color() {
        throw new Error("<SocialLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set color(value) {
        throw new Error("<SocialLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get icon() {
        throw new Error("<SocialLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set icon(value) {
        throw new Error("<SocialLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    var twitterIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">  <path d="M31.937 6.093c-1.177 0.516-2.437 0.871-3.765 1.032 1.355-0.813 2.391-2.099 2.885-3.631-1.271 0.74-2.677 1.276-4.172 1.579-1.192-1.276-2.896-2.079-4.787-2.079-3.625 0-6.563 2.937-6.563 6.557 0 0.521 0.063 1.021 0.172 1.495-5.453-0.255-10.287-2.875-13.52-6.833-0.568 0.964-0.891 2.084-0.891 3.303 0 2.281 1.161 4.281 2.916 5.457-1.073-0.031-2.083-0.328-2.968-0.817v0.079c0 3.181 2.26 5.833 5.26 6.437-0.547 0.145-1.131 0.229-1.724 0.229-0.421 0-0.823-0.041-1.224-0.115 0.844 2.604 3.26 4.5 6.14 4.557-2.239 1.755-5.077 2.801-8.135 2.801-0.521 0-1.041-0.025-1.563-0.088 2.917 1.86 6.36 2.948 10.079 2.948 12.067 0 18.661-9.995 18.661-18.651 0-0.276 0-0.557-0.021-0.839 1.287-0.917 2.401-2.079 3.281-3.396z"/></svg>';

    /* src/components/Mononaut.svelte generated by Svelte v3.44.3 */
    const file$j = "src/components/Mononaut.svelte";

    function create_fragment$j(ctx) {
      let div3;
      let div2;
      let div1;
      let div0;
      let svg;
      let defs;
      let linearGradient0;
      let stop0;
      let stop1;
      let linearGradient1;
      let g6;
      let path0;
      let path1;
      let g4;
      let g3;
      let path2;
      let path3;
      let g0;
      let path4;
      let path5;
      let path6;
      let path7;
      let path8;
      let path9;
      let path10;
      let g1;
      let path11;
      let path12;
      let g2;
      let path13;
      let path14;
      let g5;
      let path15;
      let path16;
      let path17;
      let path18;
      let ellipse;
      let path19;
      let path20;
      const block = {
        c: function create() {
          div3 = element("div");
          div2 = element("div");
          div1 = element("div");
          div0 = element("div");
          svg = svg_element("svg");
          defs = svg_element("defs");
          linearGradient0 = svg_element("linearGradient");
          stop0 = svg_element("stop");
          stop1 = svg_element("stop");
          linearGradient1 = svg_element("linearGradient");
          g6 = svg_element("g");
          path0 = svg_element("path");
          path1 = svg_element("path");
          g4 = svg_element("g");
          g3 = svg_element("g");
          path2 = svg_element("path");
          path3 = svg_element("path");
          g0 = svg_element("g");
          path4 = svg_element("path");
          path5 = svg_element("path");
          path6 = svg_element("path");
          path7 = svg_element("path");
          path8 = svg_element("path");
          path9 = svg_element("path");
          path10 = svg_element("path");
          g1 = svg_element("g");
          path11 = svg_element("path");
          path12 = svg_element("path");
          g2 = svg_element("g");
          path13 = svg_element("path");
          path14 = svg_element("path");
          g5 = svg_element("g");
          path15 = svg_element("path");
          path16 = svg_element("path");
          path17 = svg_element("path");
          path18 = svg_element("path");
          ellipse = svg_element("ellipse");
          path19 = svg_element("path");
          path20 = svg_element("path");
          set_style(stop0, "stop-color", "#ffffff");
          set_style(stop0, "stop-opacity", "0.65887851");
          attr_dev(stop0, "offset", "0");
          attr_dev(stop0, "id", "stop1870");
          add_location(stop0, file$j, 119, 14, 1947);
          set_style(stop1, "stop-color", "#a7a7a7");
          set_style(stop1, "stop-opacity", "0");
          attr_dev(stop1, "offset", "1");
          attr_dev(stop1, "id", "stop1872");
          add_location(stop1, file$j, 123, 14, 2097);
          attr_dev(linearGradient0, "id", "linearGradient1874");
          add_location(linearGradient0, file$j, 117, 12, 1877);
          xlink_attr(linearGradient1, "xlink:href", "#linearGradient1874");
          attr_dev(linearGradient1, "id", "linearGradient5760");
          attr_dev(linearGradient1, "gradientUnits", "userSpaceOnUse");
          attr_dev(linearGradient1, "gradientTransform", "matrix(0.88559909,0,0,0.88559909,2.1865141,-1.4202934)");
          attr_dev(linearGradient1, "x1", "74.399529");
          attr_dev(linearGradient1, "y1", "16.307785");
          attr_dev(linearGradient1, "x2", "15.273721");
          attr_dev(linearGradient1, "y2", "83.253212");
          add_location(linearGradient1, file$j, 128, 12, 2267);
          attr_dev(defs, "id", "defs2");
          add_location(defs, file$j, 115, 10, 1834);
          set_style(path0, "display", "inline");
          set_style(path0, "opacity", "1");
          set_style(path0, "fill", "#576c78");
          set_style(path0, "fill-opacity", "1");
          set_style(path0, "stroke", "none");
          set_style(path0, "stroke-width", "0.71934628");
          set_style(path0, "stroke-linecap", "butt");
          set_style(path0, "stroke-linejoin", "miter");
          set_style(path0, "stroke-miterlimit", "4");
          set_style(path0, "stroke-dasharray", "none");
          set_style(path0, "stroke-opacity", "1");
          attr_dev(path0, "d", "m 61.651061,20.553894 1.289922,1.959392 C 59.55236,29.73164 61.960527,32.936832 62.291817,37.57986 69.580914,51.34937 46.284973,74.005931 38.794339,77.275048 18.383317,86.182975 8.0562438,56.701838 11.97544,33.820946 13.409936,25.446125 24.242237,4.0376168 61.651061,20.553894 Z");
          attr_dev(path0, "id", "visor-back");
          add_location(path0, file$j, 141, 12, 2777);
          set_style(path1, "fill", "#784421");
          set_style(path1, "fill-opacity", "1");
          set_style(path1, "stroke", "none");
          set_style(path1, "stroke-width", "0.26458332px");
          set_style(path1, "stroke-linecap", "butt");
          set_style(path1, "stroke-linejoin", "miter");
          set_style(path1, "stroke-opacity", "1");
          attr_dev(path1, "d", "m 40.023612,69.217407 c -1.74228,14.114255 19.884147,12.868589 29.800552,15.568451 l 13.964832,-13.8312 C 77.167852,62.564819 61.700977,53.269993 49.110776,59.796156 Z");
          attr_dev(path1, "id", "monkey-body");
          add_location(path1, file$j, 145, 12, 3340);
          attr_dev(path2, "id", "ear-right");
          attr_dev(path2, "d", "m 35.094888,56.21721 c -6.89655,2.534431 -14.53992,-2.389386 -17.231469,-4.852391 1.23186,-3.401999 4.604949,-5.92599 8.722879,-7.236581 1.66704,-0.53056 3.45615,-0.862263 5.27469,-0.97286 9.17189,1.090452 10.68783,11.787228 3.2339,13.0061832 z");
          set_style(path2, "display", "inline");
          set_style(path2, "opacity", "1");
          set_style(path2, "fill", "#deaa87");
          set_style(path2, "stroke", "none");
          set_style(path2, "stroke-width", "0.21957469px");
          set_style(path2, "stroke-linecap", "butt");
          set_style(path2, "stroke-linejoin", "miter");
          set_style(path2, "stroke-opacity", "1");
          add_location(path2, file$j, 154, 16, 3956);
          attr_dev(path3, "id", "head");
          attr_dev(path3, "d", "m 30.308872,23.862935 c -7.896397,9.705521 -12.701615,16.830049 -7.269507,28.957925 4.3062,9.614141 -0.284703,11.721588 5.683872,18.251035 5.45108,5.55247 10.178022,5.892849 13.988071,13.594771 11.299136,14.269193 22.409786,3.337588 26.080359,-5.85863 C 81.867477,56.071791 88.32321,34.989715 70.681545,21.166667 55.190177,12.328814 46.139739,12.585053 30.308872,23.862935 Z");
          set_style(path3, "display", "inline");
          set_style(path3, "fill", "#784421");
          set_style(path3, "fill-opacity", "1");
          set_style(path3, "stroke", "none");
          set_style(path3, "stroke-width", "0.26458332px");
          set_style(path3, "stroke-linecap", "butt");
          set_style(path3, "stroke-linejoin", "miter");
          set_style(path3, "stroke-opacity", "1");
          add_location(path3, file$j, 158, 16, 4445);
          attr_dev(path4, "id", "ear-left-outer");
          attr_dev(path4, "d", "m 77.833423,50.323879 c 6.47703,-6.03607 5.34152,-16.93279 4.15774,-21.16667 -6.07997,-0.73952 -12.59596,4.00709 -16.44197,10.58333 -3.8176,10.45458 6.85846,17.904101 12.28423,10.58334 z");
          set_style(path4, "display", "inline");
          set_style(path4, "opacity", "1");
          set_style(path4, "fill", "#deaa87");
          set_style(path4, "stroke", "none");
          set_style(path4, "stroke-width", "0.26458332px");
          set_style(path4, "stroke-linecap", "butt");
          set_style(path4, "stroke-linejoin", "miter");
          set_style(path4, "stroke-opacity", "1");
          add_location(path4, file$j, 163, 18, 5100);
          attr_dev(path5, "id", "ear-left-inner");
          attr_dev(path5, "d", "m 76.76206,47.72753 c 4.556293,-4.246097 3.757513,-11.911438 2.924778,-14.889778 -4.276979,-0.520219 -8.860678,2.818803 -11.56617,7.444885 -2.685506,7.354316 4.824612,12.594712 8.641392,7.444893 z");
          set_style(path5, "display", "inline");
          set_style(path5, "opacity", "1");
          set_style(path5, "fill", "#e9c6af");
          set_style(path5, "stroke", "none");
          set_style(path5, "stroke-width", "0.18612219px");
          set_style(path5, "stroke-linecap", "butt");
          set_style(path5, "stroke-linejoin", "miter");
          set_style(path5, "stroke-opacity", "1");
          add_location(path5, file$j, 167, 19, 5545);
          attr_dev(g0, "id", "ear-left");
          attr_dev(g0, "class", "svelte-1ax8a52");
          add_location(g0, file$j, 162, 16, 5064);
          attr_dev(path6, "id", "face");
          attr_dev(path6, "d", "m 38.742559,49.51488 c 1.45629,-4.066862 6.298841,-7.992738 12.284225,-6.992558 15.425741,4.293009 4.803701,19.409911 -2.976563,18.473584 18.639296,3.573862 22.324617,26.346482 6.174076,27.17782 -12.717835,0.34267 -8.581608,-9.318628 -16.409445,-12.0269 -5.597227,-1.936527 -2.05593,-13.668839 -2.663067,-12.26885 -6.589222,8.759543 -12.047332,-0.849447 -11.528273,-9.921875 1.774561,-2.871137 4.819803,-3.699497 8.882439,-1.039433 4.789983,2.254962 5.346565,-0.781825 6.236608,-3.401788 z");
          set_style(path6, "display", "inline");
          set_style(path6, "fill", "#deaa87");
          set_style(path6, "fill-opacity", "1");
          set_style(path6, "stroke", "none");
          set_style(path6, "stroke-width", "0.26458332px");
          set_style(path6, "stroke-linecap", "butt");
          set_style(path6, "stroke-linejoin", "miter");
          set_style(path6, "stroke-opacity", "1");
          add_location(path6, file$j, 172, 16, 6021);
          attr_dev(path7, "id", "muzzle");
          attr_dev(path7, "d", "M 60.072997,75.352317 C 55.003352,70.027191 55.75107,68.927121 53.34848,66.485233 51.841457,64.88184 47.05277,62.630654 42.069361,63.849024 c -1.699146,0.415416 -4.449014,1.385616 -6.199235,3.299959 -1.682918,1.84073 -1.025774,7.464219 2.777696,9.202331 3.896358,1.78056 4.087632,2.791893 5.88943,6.981181 3.630032,8.440037 20.554285,1.586752 15.535745,-7.980178 z");
          set_style(path7, "display", "inline");
          set_style(path7, "fill", "#502d16");
          set_style(path7, "stroke", "none");
          set_style(path7, "stroke-width", "0.26458332px");
          set_style(path7, "stroke-linecap", "butt");
          set_style(path7, "stroke-linejoin", "miter");
          set_style(path7, "stroke-opacity", "1");
          add_location(path7, file$j, 176, 16, 6755);
          attr_dev(path8, "id", "face-inner");
          attr_dev(path8, "d", "m 38.957003,52.607487 c 1.042028,-2.641197 2.728748,-4.7652 10.223515,-5.17104 7.241178,0.814991 8.551291,5.869414 4.817338,8.574224 -3.147594,3.346452 -6.33337,3.393592 -8.935703,2.930689 -3.51048,-0.180022 -6.925621,-0.202977 -8.446902,2.89418 -5.220943,5.911145 -10.282881,0.05394 -10.31162,-5.662332 1.650862,-1.605418 3.81304,-2.437929 7.455186,-1.033305 4.247946,1.104042 4.568382,-0.833998 5.198186,-2.532416 z");
          set_style(path8, "display", "inline");
          set_style(path8, "fill", "#e9c6af");
          set_style(path8, "stroke", "none");
          set_style(path8, "stroke-width", "0.19504021px");
          set_style(path8, "stroke-linecap", "butt");
          set_style(path8, "stroke-linejoin", "miter");
          set_style(path8, "stroke-opacity", "1");
          add_location(path8, file$j, 180, 16, 7351);
          attr_dev(path9, "id", "mouth");
          attr_dev(path9, "d", "m 42.472928,76.398309 c -0.995545,-0.575317 -0.253436,-2.698662 1.044456,-2.998078 4.228867,-0.975576 12.597117,-0.526341 13.187645,0.826512 1.454954,3.573662 -4.175521,8.756925 -10.256469,8.652853 -2.374181,0.259391 -1.069921,-4.879679 -3.975632,-6.481287 z");
          set_style(path9, "display", "inline");
          set_style(path9, "fill", "#28170b");
          set_style(path9, "stroke", "none");
          set_style(path9, "stroke-width", "0.26458332px");
          set_style(path9, "stroke-linecap", "butt");
          set_style(path9, "stroke-linejoin", "miter");
          set_style(path9, "stroke-opacity", "1");
          add_location(path9, file$j, 184, 16, 8004);
          attr_dev(path10, "id", "tongue");
          attr_dev(path10, "d", "m 46.929215,76.246574 c 0.615399,-1.75537 8.22103,-2.28337 7.216279,4.07586 -0.212053,1.37525 3.358405,1.46548 4.409948,3.34086 1.055887,4.79323 -3.65884,4.36937 -6.94901,2.77293 -4.202979,-2.19163 -5.874033,-5.47644 -4.677217,-10.18965 z");
          set_style(path10, "display", "inline");
          set_style(path10, "opacity", "1");
          set_style(path10, "fill", "#da789c");
          set_style(path10, "fill-opacity", "1");
          set_style(path10, "stroke", "none");
          set_style(path10, "stroke-width", "0.26458332px");
          set_style(path10, "stroke-linecap", "butt");
          set_style(path10, "stroke-linejoin", "miter");
          set_style(path10, "stroke-opacity", "1");
          add_location(path10, file$j, 188, 16, 8493);
          attr_dev(path11, "id", "pupil-left");
          attr_dev(path11, "d", "m 40.867285,57.273873 c 1.612375,-2.042551 0.701258,-3.847919 2.827551,-5.020606 2.852266,-1.245289 3.874257,0.02912 6.461358,-0.487557 -1.800708,1.927123 -1.087836,3.182768 -3.147949,4.379153 -2.48621,1.342919 -2.404803,0.48141 -6.14096,1.12901 z");
          set_style(path11, "display", "inline");
          set_style(path11, "fill", "#28170b");
          set_style(path11, "fill-opacity", "1");
          set_style(path11, "stroke", "none");
          set_style(path11, "stroke-width", "0.26458332px");
          set_style(path11, "stroke-linecap", "butt");
          set_style(path11, "stroke-linejoin", "miter");
          set_style(path11, "stroke-opacity", "1");
          add_location(path11, file$j, 193, 18, 9043);
          attr_dev(path12, "id", "gleam-left");
          attr_dev(path12, "d", "m 44.577763,52.357009 0.175397,1.00226 1.720546,-0.91874 z");
          set_style(path12, "display", "inline");
          set_style(path12, "opacity", "1");
          set_style(path12, "fill", "#f4e3d7");
          set_style(path12, "fill-opacity", "1");
          set_style(path12, "stroke", "none");
          set_style(path12, "stroke-width", "0.26458332px");
          set_style(path12, "stroke-linecap", "butt");
          set_style(path12, "stroke-linejoin", "miter");
          set_style(path12, "stroke-opacity", "1");
          add_location(path12, file$j, 197, 18, 9549);
          attr_dev(g1, "id", "eye-left");
          attr_dev(g1, "class", "monkey-eye svelte-1ax8a52");
          add_location(g1, file$j, 192, 16, 8988);
          attr_dev(path13, "id", "pupil-right");
          attr_dev(path13, "d", "m 36.526068,59.323301 c -2.29866,-0.610735 -2.053402,-2.430637 -4.251391,-2.123454 -2.768843,0.651852 -2.383872,2.077275 -4.559515,3.116838 2.373186,0.423104 2.10538,1.799062 4.267942,1.545474 2.554554,-0.379861 1.455015,-0.965477 4.542964,-2.538858 z");
          set_style(path13, "display", "inline");
          set_style(path13, "fill", "#28170b");
          set_style(path13, "stroke", "none");
          set_style(path13, "stroke-width", "0.24182333px");
          set_style(path13, "stroke-linecap", "butt");
          set_style(path13, "stroke-linejoin", "miter");
          set_style(path13, "stroke-opacity", "1");
          add_location(path13, file$j, 203, 18, 9951);
          attr_dev(path14, "id", "gleam-right");
          attr_dev(path14, "d", "m 31.608594,58.036779 0.803199,0.56105 0.750048,-0.48428 z");
          set_style(path14, "display", "inline");
          set_style(path14, "opacity", "1");
          set_style(path14, "fill", "#f4e3d7");
          set_style(path14, "stroke", "none");
          set_style(path14, "stroke-width", "0.26458332px");
          set_style(path14, "stroke-linecap", "butt");
          set_style(path14, "stroke-linejoin", "miter");
          set_style(path14, "stroke-opacity", "1");
          add_location(path14, file$j, 207, 18, 10447);
          attr_dev(g2, "id", "eye-right");
          attr_dev(g2, "class", "monkey-eye svelte-1ax8a52");
          add_location(g2, file$j, 202, 16, 9895);
          set_style(g3, "display", "inline");
          attr_dev(g3, "id", "monkey-inner");
          attr_dev(g3, "transform", "matrix(0.73793571,0.19032465,-0.19032465,0.73793571,8.5451128,-1.5971534)");
          add_location(g3, file$j, 150, 14, 3758);
          attr_dev(g4, "id", "monkey");
          attr_dev(g4, "class", "svelte-1ax8a52");
          add_location(g4, file$j, 149, 12, 3728);
          set_style(path15, "display", "inline");
          set_style(path15, "opacity", "1");
          set_style(path15, "fill", "#22676d");
          set_style(path15, "fill-opacity", "1");
          set_style(path15, "stroke", "none");
          set_style(path15, "stroke-width", "0.23431474px");
          set_style(path15, "stroke-linecap", "butt");
          set_style(path15, "stroke-linejoin", "miter");
          set_style(path15, "stroke-opacity", "1");
          attr_dev(path15, "d", "M 88.570396,58.724343 C 94.62432,54.067131 100.74234,57.883387 98.984914,64.996727 95.801343,75.095656 65.800904,103.41999 49.515946,100.50077 42.891637,97.739253 46.341916,92.001209 46.32058,88.666096 Z");
          attr_dev(path15, "id", "collar-one");
          add_location(path15, file$j, 215, 14, 10841);
          set_style(path16, "display", "inline");
          set_style(path16, "opacity", "1");
          set_style(path16, "fill", "#bae5e9");
          set_style(path16, "fill-opacity", "1");
          set_style(path16, "stroke", "none");
          set_style(path16, "stroke-width", "0.23431474px");
          set_style(path16, "stroke-linecap", "butt");
          set_style(path16, "stroke-linejoin", "miter");
          set_style(path16, "stroke-opacity", "1");
          attr_dev(path16, "d", "M 83.372436,52.659423 C 89.426364,48.002211 95.544387,51.818467 93.786951,58.931806 90.603382,69.030735 60.602943,97.355073 44.317985,94.435853 37.693676,91.674335 41.143955,85.936289 41.122619,82.601171 Z");
          attr_dev(path16, "id", "collar-two");
          add_location(path16, file$j, 219, 14, 11297);
          set_style(path17, "display", "inline");
          set_style(path17, "opacity", "1");
          set_style(path17, "fill", "#bae5e9");
          set_style(path17, "fill-opacity", "1");
          set_style(path17, "stroke", "none");
          set_style(path17, "stroke-width", "0.23431474px");
          set_style(path17, "stroke-linecap", "butt");
          set_style(path17, "stroke-linejoin", "miter");
          set_style(path17, "stroke-opacity", "1");
          attr_dev(path17, "d", "M 28.23215,79.916507 C 40.765843,80.993896 69.099088,55.590613 62.481792,37.486127 59.618529,29.652427 61.621394,25.326412 63.0048283,22.398281 63.451782,21.570257 62.431545,21.170567 61.660924,20.582972 58.721936,18.342009 33.314523,9.1801348 21.414153,19.148253 21.040806,19.46098 16.493514,24.225612 16.466931,23.906261 16.284334,21.712654 15.7061,18.778538 16.842454,17.601749 28.272105,5.7653958 43.244764,5.2528968 51.182613,5.4345318 74.64048,5.9712998 76.979428,18.408564 78.673549,18.329111 92.064018,29.246088 95.017703,40.802051 86.539829,53.0057904 73.279621,74.932862 61.561047,80.045597 49.802622,87.117228 40.441364,90.882866 24.536108,90.048641 21.648484,74.844071 c 2.995365,2.722164 2.788093,4.347644 6.583666,5.072436 z");
          attr_dev(path17, "id", "helmet-case");
          add_location(path17, file$j, 223, 14, 11755);
          set_style(path18, "display", "inline");
          set_style(path18, "opacity", "1");
          set_style(path18, "fill", "#22676d");
          set_style(path18, "fill-opacity", "1");
          set_style(path18, "stroke", "none");
          set_style(path18, "stroke-width", "0.23431474px");
          set_style(path18, "stroke-linecap", "butt");
          set_style(path18, "stroke-linejoin", "miter");
          set_style(path18, "stroke-opacity", "1");
          attr_dev(path18, "d", "m 38.50793,85.407931 c 1.842704,-0.411794 2.387542,-0.346584 3.341095,-0.04751 4.084771,1.281151 4.96339,0.781298 6.513681,0.03974 7.412447,-4.138988 13.715592,-9.704221 19.57263,-15.84302 l 0.241658,-11.116412 c -0.0621,-0.767793 -0.0058,-1.485505 0.329786,-2.085218 l 9.16256,-15.933883 c 1.483253,-4.949488 3.702339,-12.396219 3.313375,-17.72015 -0.162002,-2.217387 -1.329754,-1.991515 -2.30917,-4.372385 13.390473,10.916977 16.344158,22.47294 7.866281,34.728794 -13.26021,21.874955 -24.978782,26.987686 -36.737206,34.059324 -9.361257,3.765637 -18.488123,1.257736 -21.626797,-1.059526 4.264979,0.370603 6.29984,0.400653 10.332107,-0.649754 z");
          attr_dev(path18, "id", "helmet-base");
          add_location(path18, file$j, 227, 14, 12747);
          set_style(ellipse, "display", "inline");
          set_style(ellipse, "opacity", "1");
          set_style(ellipse, "fill", "#133a3e");
          set_style(ellipse, "fill-opacity", "1");
          set_style(ellipse, "stroke", "none");
          set_style(ellipse, "stroke-width", "0.24935082");
          set_style(ellipse, "stroke-linecap", "round");
          set_style(ellipse, "stroke-linejoin", "round");
          set_style(ellipse, "stroke-miterlimit", "4");
          set_style(ellipse, "stroke-dasharray", "none");
          set_style(ellipse, "stroke-opacity", "1");
          attr_dev(ellipse, "id", "helmet-joint");
          attr_dev(ellipse, "cx", "53.400845");
          attr_dev(ellipse, "cy", "67.588089");
          attr_dev(ellipse, "rx", "6.4156117");
          attr_dev(ellipse, "ry", "9.9880085");
          attr_dev(ellipse, "transform", "matrix(0.88495557,-0.46567547,0.48925229,0.8721423,0,0)");
          add_location(ellipse, file$j, 231, 14, 13645);
          set_style(path19, "display", "inline");
          set_style(path19, "opacity", "0.98000004");
          set_style(path19, "fill", "url(#linearGradient5760)");
          set_style(path19, "fill-opacity", "1");
          set_style(path19, "stroke", "#000000");
          set_style(path19, "stroke-width", "0.71934628");
          set_style(path19, "stroke-linecap", "butt");
          set_style(path19, "stroke-linejoin", "miter");
          set_style(path19, "stroke-miterlimit", "4");
          set_style(path19, "stroke-dasharray", "none");
          set_style(path19, "stroke-opacity", "1");
          attr_dev(path19, "d", "m 61.651061,20.553894 1.289918,1.959392 C 59.552359,29.73164 61.960527,32.936833 62.291817,37.57986 69.580918,51.349372 46.284972,74.005931 38.794337,77.275049 18.383317,86.182977 8.0562438,56.70184 11.97544,33.820947 13.409936,25.446126 24.242237,4.0376178 61.651061,20.553894 Z");
          attr_dev(path19, "id", "visor");
          add_location(path19, file$j, 239, 14, 14135);
          set_style(path20, "display", "inline");
          set_style(path20, "opacity", "0.753");
          set_style(path20, "fill", "#ffffff");
          set_style(path20, "fill-opacity", "1");
          set_style(path20, "stroke", "none");
          set_style(path20, "stroke-width", "0.23431474");
          set_style(path20, "stroke-linecap", "butt");
          set_style(path20, "stroke-linejoin", "miter");
          set_style(path20, "stroke-miterlimit", "4");
          set_style(path20, "stroke-dasharray", "none");
          set_style(path20, "stroke-opacity", "1");
          attr_dev(path20, "d", "m 35.84597,19.072302 c 7.774683,-2.280832 13.824223,-0.609922 19.290532,2.95867 l 1.301816,4.023793 c -8.1156,-3.761618 -15.343244,-5.578561 -23.314324,-3.432059 z");
          attr_dev(path20, "id", "helmet-gleam");
          add_location(path20, file$j, 243, 15, 14732);
          attr_dev(g5, "id", "helmet");
          add_location(g5, file$j, 214, 12, 10811);
          set_style(g6, "display", "inline");
          set_style(g6, "opacity", "1");
          attr_dev(g6, "transform", "translate(-10.793731,-5.4097061)");
          add_location(g6, file$j, 138, 10, 2657);
          attr_dev(svg, "class", "avatar svelte-1ax8a52");
          attr_dev(svg, "width", "334.47833");
          attr_dev(svg, "height", "360.19266");
          attr_dev(svg, "viewBox", "0 0 88.497389 95.30098");
          attr_dev(svg, "version", "1.1");
          attr_dev(svg, "id", "svg8");
          add_location(svg, file$j, 109, 8, 1654);
          attr_dev(div0, "class", "inner svelte-1ax8a52");
          add_location(div0, file$j, 108, 6, 1626);
          attr_dev(div1, "class", "backdrop svelte-1ax8a52");
          add_location(div1, file$j, 107, 4, 1597);
          attr_dev(div2, "class", "aspect svelte-1ax8a52");
          add_location(div2, file$j, 106, 2, 1572);
          attr_dev(div3, "class", "mononaut svelte-1ax8a52");
          add_location(div3, file$j, 105, 0, 1547);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div2);
          append_dev(div2, div1);
          append_dev(div1, div0);
          append_dev(div0, svg);
          append_dev(svg, defs);
          append_dev(defs, linearGradient0);
          append_dev(linearGradient0, stop0);
          append_dev(linearGradient0, stop1);
          append_dev(defs, linearGradient1);
          append_dev(svg, g6);
          append_dev(g6, path0);
          append_dev(g6, path1);
          append_dev(g6, g4);
          append_dev(g4, g3);
          append_dev(g3, path2);
          append_dev(g3, path3);
          append_dev(g3, g0);
          append_dev(g0, path4);
          append_dev(g0, path5);
          append_dev(g3, path6);
          append_dev(g3, path7);
          append_dev(g3, path8);
          append_dev(g3, path9);
          append_dev(g3, path10);
          append_dev(g3, g1);
          append_dev(g1, path11);
          append_dev(g1, path12);
          append_dev(g3, g2);
          append_dev(g2, path13);
          append_dev(g2, path14);
          append_dev(g6, g5);
          append_dev(g5, path15);
          append_dev(g5, path16);
          append_dev(g5, path17);
          append_dev(g5, path18);
          append_dev(g5, ellipse);
          append_dev(g5, path19);
          append_dev(g5, path20);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$j.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$j($$self, $$props) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Mononaut', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mononaut> was created with unknown prop '${key}'`);
      });
      return [];
    }

    class Mononaut extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$j, create_fragment$j, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Mononaut",
          options,
          id: create_fragment$j.name
        });
      }

    }

    var name = "bitfeed-client";
    var version$1 = "2.3.4";
    var scripts = {
    	build: "rollup -c",
    	dev: "rollup -c -w",
    	start: "sirv public --single"
    };
    var dependencies = {
    	"@babel/core": "^7.16.5",
    	"@babel/preset-env": "^7.16.5",
    	"@rollup/plugin-babel": "^5.3.0",
    	"@rollup/plugin-commonjs": "^21.0.1",
    	"@rollup/plugin-html": "^0.2.4",
    	"@rollup/plugin-node-resolve": "^13.1.1",
    	"@rollup/plugin-replace": "^3.0.0",
    	"base58-js": "^1.0.0",
    	"bech32-buffer": "^0.2.0",
    	buffer: "^6.0.3",
    	"d3-color": "^3.0.1",
    	"d3-interpolate": "^3.0.1",
    	dotenv: "^10.0.0",
    	"hash.js": "^1.1.7",
    	"locale-currency": "0.0.2",
    	qrcode: "^1.5.0",
    	rollup: "^2.62.0",
    	"rollup-plugin-copy": "^3.4.0",
    	"rollup-plugin-css-only": "^3.1.0",
    	"rollup-plugin-glslify": "^1.2.1",
    	"rollup-plugin-inline-svg": "^2.0.0",
    	"rollup-plugin-livereload": "^2.0.5",
    	"rollup-plugin-svelte": "^7.1.0",
    	"rollup-plugin-terser": "^7.0.2",
    	sass: "^1.49.0",
    	"sirv-cli": "^1.0.14",
    	svelte: "^3.44.3",
    	"svelte-preprocess": "^4.10.1",
    	"svelte-select": "^4.4.7"
    };
    var devDependencies = {
    	"@rollup/plugin-json": "^4.1.0"
    };
    var config = {
    	name: name,
    	version: version$1,
    	scripts: scripts,
    	dependencies: dependencies,
    	devDependencies: devDependencies
    };

    /* src/components/ContactTab.svelte generated by Svelte v3.44.3 */
    const file$i = "src/components/ContactTab.svelte"; // (45:4) <SocialLink icon={twitterIcon} href="https://twitter.com/mononautical" color="var(--twitter-blue)">

    function create_default_slot_1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("@mononautical");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1.name,
        type: "slot",
        source: "(45:4) <SocialLink icon={twitterIcon} href=\\\"https://twitter.com/mononautical\\\" color=\\\"var(--twitter-blue)\\\">",
        ctx
      });
      return block;
    } // (48:4) <SocialLink icon={atIcon} href="mailto:bitfeed@monospace.live" color="var(--monospace-purple)">


    function create_default_slot$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("monospace.live");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(48:4) <SocialLink icon={atIcon} href=\\\"mailto:bitfeed@monospace.live\\\" color=\\\"var(--monospace-purple)\\\">",
        ctx
      });
      return block;
    }

    function create_fragment$i(ctx) {
      let div2;
      let div1;
      let a;
      let mononaut;
      let t0;
      let div0;
      let p0;
      let t1;
      let b0;
      let t3;
      let t4;
      let p1;
      let t6;
      let p2;
      let t7;
      let sociallink0;
      let t8;
      let p3;
      let t9;
      let sociallink1;
      let t10;
      let p4;
      let b1;
      let current;
      mononaut = new Mononaut({
        $$inline: true
      });
      sociallink0 = new SocialLink({
        props: {
          icon: twitterIcon,
          href: "https://twitter.com/mononautical",
          color: "var(--twitter-blue)",
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sociallink1 = new SocialLink({
        props: {
          icon: atIcon,
          href: "mailto:bitfeed@monospace.live",
          color: "var(--monospace-purple)",
          $$slots: {
            default: [create_default_slot$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div2 = element("div");
          div1 = element("div");
          a = element("a");
          create_component(mononaut.$$.fragment);
          t0 = space();
          div0 = element("div");
          p0 = element("p");
          t1 = text("Bitfeed is an experiment by ");
          b0 = element("b");
          b0.textContent = "mononaut";
          t3 = text(".");
          t4 = space();
          p1 = element("p");
          p1.textContent = "Questions? Comments? Suggestions?";
          t6 = space();
          p2 = element("p");
          t7 = text("Message me on twitter at\n    ");
          create_component(sociallink0.$$.fragment);
          t8 = space();
          p3 = element("p");
          t9 = text("Or email any recipient at\n    ");
          create_component(sociallink1.$$.fragment);
          t10 = space();
          p4 = element("p");
          b1 = element("b");
          b1.textContent = `v${config.version}`;
          attr_dev(a, "class", "monkey-avatar svelte-1vh35w7");
          attr_dev(a, "target", "_blank");
          attr_dev(a, "href", "https://monospace.live");
          attr_dev(a, "rel", "noopener");
          add_location(a, file$i, 35, 4, 813);
          attr_dev(b0, "class", "mononaut svelte-1vh35w7");
          add_location(b0, file$i, 39, 37, 989);
          add_location(p0, file$i, 39, 6, 958);
          add_location(p1, file$i, 40, 6, 1033);
          attr_dev(div0, "class", "intro svelte-1vh35w7");
          add_location(div0, file$i, 38, 4, 932);
          attr_dev(div1, "class", "avatar-and-intro svelte-1vh35w7");
          add_location(div1, file$i, 34, 2, 778);
          set_style(p2, "clear", "both");
          add_location(p2, file$i, 43, 2, 1096);
          add_location(p3, file$i, 46, 2, 1283);
          attr_dev(b1, "class", "mononaut svelte-1vh35w7");
          add_location(b1, file$i, 49, 5, 1451);
          add_location(p4, file$i, 49, 2, 1448);
          attr_dev(div2, "class", "contact tab-content svelte-1vh35w7");
          add_location(div2, file$i, 33, 0, 742);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div1);
          append_dev(div1, a);
          mount_component(mononaut, a, null);
          append_dev(div1, t0);
          append_dev(div1, div0);
          append_dev(div0, p0);
          append_dev(p0, t1);
          append_dev(p0, b0);
          append_dev(p0, t3);
          append_dev(div0, t4);
          append_dev(div0, p1);
          append_dev(div2, t6);
          append_dev(div2, p2);
          append_dev(p2, t7);
          mount_component(sociallink0, p2, null);
          append_dev(div2, t8);
          append_dev(div2, p3);
          append_dev(p3, t9);
          mount_component(sociallink1, p3, null);
          append_dev(div2, t10);
          append_dev(div2, p4);
          append_dev(p4, b1);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          const sociallink0_changes = {};

          if (dirty &
          /*$$scope*/
          1) {
            sociallink0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sociallink0.$set(sociallink0_changes);
          const sociallink1_changes = {};

          if (dirty &
          /*$$scope*/
          1) {
            sociallink1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sociallink1.$set(sociallink1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(mononaut.$$.fragment, local);
          transition_in(sociallink0.$$.fragment, local);
          transition_in(sociallink1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(mononaut.$$.fragment, local);
          transition_out(sociallink0.$$.fragment, local);
          transition_out(sociallink1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(mononaut);
          destroy_component(sociallink0);
          destroy_component(sociallink1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$i.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('ContactTab', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContactTab> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        SocialLink,
        twitterIcon,
        atIcon,
        Mononaut,
        config
      });

      return [];
    }

    class ContactTab extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$i, create_fragment$i, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ContactTab",
          options,
          id: create_fragment$i.name
        });
      }

    }

    var PlusIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <polygon fill="var(--ci-primary-color, currentColor)" points="440 240 272 240 272 72 240 72 240 240 72 240 72 272 240 272 240 440 272 440 272 272 440 272 440 240" class="ci-primary"/></svg>';

    var CrossIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <polygon fill="var(--ci-primary-color, currentColor)" points="427.314 107.313 404.686 84.687 256 233.373 107.314 84.687 84.686 107.313 233.373 256 84.686 404.687 107.314 427.313 256 278.627 404.686 427.313 427.314 404.687 278.627 256 427.314 107.313" class="ci-primary"/></svg>';

    /* src/components/SearchTab.svelte generated by Svelte v3.44.3 */
    const {
      console: console_1$1
    } = globals;
    const file$h = "src/components/SearchTab.svelte";

    function get_each_context$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[28] = list[i];
      child_ctx[30] = i;
      return child_ctx;
    } // (247:4) {:else}


    function create_else_block$7(ctx) {
      let input;
      const block = {
        c: function create() {
          input = element("input");
          attr_dev(input, "class", "search-input disabled svelte-ckhzsy");
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "Watchlist is full");
          add_location(input, file$h, 247, 6, 7060);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(input);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$7.name,
        type: "else",
        source: "(247:4) {:else}",
        ctx
      });
      return block;
    } // (242:4) {#if !$highlightingFull }


    function create_if_block$c(ctx) {
      let form;
      let input;
      let t;
      let button;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          form = element("form");
          input = element("input");
          t = space();
          button = element("button");
          attr_dev(input, "class", "search-input svelte-ckhzsy");
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "Enter an address or txid...");
          add_location(input, file$h, 243, 8, 6827);
          attr_dev(button, "type", "submit");
          attr_dev(button, "class", "search-submit svelte-ckhzsy");
          add_location(button, file$h, 244, 8, 6981);
          attr_dev(form, "class", "search-form svelte-ckhzsy");
          attr_dev(form, "action", "");
          add_location(form, file$h, 242, 6, 6757);
        },
        m: function mount(target, anchor) {
          insert_dev(target, form, anchor);
          append_dev(form, input);
          set_input_value(input,
          /*query*/
          ctx[0]);
          append_dev(form, t);
          append_dev(form, button);

          if (!mounted) {
            dispose = [listen_dev(input, "input",
            /*input_input_handler*/
            ctx[15]), listen_dev(input, "focusin",
            /*focusIn*/
            ctx[10], false, false, false), listen_dev(input, "focusOut",
            /*focusOut*/
            ctx[11], false, false, false), listen_dev(form, "submit",
            /*searchSubmit*/
            ctx[9], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*query*/
          1 && input.value !==
          /*query*/
          ctx[0]) {
            set_input_value(input,
            /*query*/
            ctx[0]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(form);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$c.name,
        type: "if",
        source: "(242:4) {#if !$highlightingFull }",
        ctx
      });
      return block;
    } // (255:4) {#each watchlist as watched, index (watched.colorIndex)}


    function create_each_block$6(key_1, ctx) {
      let div2;
      let div0;
      let icon0;
      let div0_title_value;
      let t0;
      let span;
      let t1_value =
      /*watched*/
      ctx[28].value + "";
      let t1;
      let t2;
      let div1;
      let icon1;
      let t3;
      let div2_transition;
      let rect;
      let stop_animation = noop;
      let current;
      let mounted;
      let dispose;
      icon0 = new Icon({
        props: {
          icon:
          /*queryIcons*/
          ctx[5][
          /*watched*/
          ctx[28].query]
        },
        $$inline: true
      });
      icon1 = new Icon({
        props: {
          icon: CrossIcon
        },
        $$inline: true
      });

      function click_handler() {
        return (
          /*click_handler*/
          ctx[16](
          /*index*/
          ctx[30])
        );
      }

      const block = {
        key: key_1,
        first: null,
        c: function create() {
          div2 = element("div");
          div0 = element("div");
          create_component(icon0.$$.fragment);
          t0 = space();
          span = element("span");
          t1 = text(t1_value);
          t2 = space();
          div1 = element("div");
          create_component(icon1.$$.fragment);
          t3 = space();
          attr_dev(div0, "class", "input-icon query-type svelte-ckhzsy");
          set_style(div0, "color",
          /*watched*/
          ctx[28].colorHex);
          attr_dev(div0, "title", div0_title_value =
          /*queryType*/
          ctx[6][
          /*watched*/
          ctx[28].query]);
          add_location(div0, file$h, 260, 8, 7567);
          attr_dev(span, "class", "query svelte-ckhzsy");
          set_style(span, "color",
          /*watched*/
          ctx[28].colorHex);
          add_location(span, file$h, 263, 8, 7746);
          attr_dev(div1, "class", "input-icon remove-query icon-button svelte-ckhzsy");
          attr_dev(div1, "title", "Remove from watchlist");
          add_location(div1, file$h, 264, 8, 7834);
          attr_dev(div2, "class", "watched svelte-ckhzsy");
          add_location(div2, file$h, 255, 6, 7445);
          this.first = div2;
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          mount_component(icon0, div0, null);
          append_dev(div2, t0);
          append_dev(div2, span);
          append_dev(span, t1);
          append_dev(div2, t2);
          append_dev(div2, div1);
          mount_component(icon1, div1, null);
          append_dev(div2, t3);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div1, "click", click_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const icon0_changes = {};
          if (dirty &
          /*watchlist*/
          4) icon0_changes.icon =
          /*queryIcons*/
          ctx[5][
          /*watched*/
          ctx[28].query];
          icon0.$set(icon0_changes);

          if (!current || dirty &
          /*watchlist*/
          4) {
            set_style(div0, "color",
            /*watched*/
            ctx[28].colorHex);
          }

          if (!current || dirty &
          /*watchlist*/
          4 && div0_title_value !== (div0_title_value =
          /*queryType*/
          ctx[6][
          /*watched*/
          ctx[28].query])) {
            attr_dev(div0, "title", div0_title_value);
          }

          if ((!current || dirty &
          /*watchlist*/
          4) && t1_value !== (t1_value =
          /*watched*/
          ctx[28].value + "")) set_data_dev(t1, t1_value);

          if (!current || dirty &
          /*watchlist*/
          4) {
            set_style(span, "color",
            /*watched*/
            ctx[28].colorHex);
          }
        },
        r: function measure() {
          rect = div2.getBoundingClientRect();
        },
        f: function fix() {
          fix_position(div2);
          stop_animation();
          add_transform(div2, rect);
        },
        a: function animate() {
          stop_animation();
          stop_animation = create_animation(div2, rect, flip, {
            duration: 200
          });
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon0.$$.fragment, local);
          transition_in(icon1.$$.fragment, local);
          add_render_callback(() => {
            if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {
              duration: 200
            }, true);
            div2_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(icon0.$$.fragment, local);
          transition_out(icon1.$$.fragment, local);
          if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {
            duration: 200
          }, false);
          div2_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(icon0);
          destroy_component(icon1);
          if (detaching && div2_transition) div2_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$6.name,
        type: "each",
        source: "(255:4) {#each watchlist as watched, index (watched.colorIndex)}",
        ctx
      });
      return block;
    }

    function create_fragment$h(ctx) {
      let div3;
      let div1;
      let t0;
      let div0;
      let icon;
      let t1;
      let div2;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let current;
      let mounted;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (!
        /*$highlightingFull*/
        ctx[4]) return create_if_block$c;
        return create_else_block$7;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      icon = new Icon({
        props: {
          icon: PlusIcon
        },
        $$inline: true
      });
      let each_value =
      /*watchlist*/
      ctx[2];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*watched*/
      ctx[28].colorIndex;

      validate_each_keys(ctx, each_value, get_each_context$6, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$6(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
      }

      const block = {
        c: function create() {
          div3 = element("div");
          div1 = element("div");
          if_block.c();
          t0 = space();
          div0 = element("div");
          create_component(icon.$$.fragment);
          t1 = space();
          div2 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div0, "class", "input-icon add-query icon-button svelte-ckhzsy");
          attr_dev(div0, "title", "Add to watchlist");
          toggle_class(div0, "disabled",
          /*matchedQuery*/
          ctx[1] == null ||
          /*$highlightingFull*/
          ctx[4]);
          add_location(div0, file$h, 249, 4, 7156);
          attr_dev(div1, "class", "input-wrapper svelte-ckhzsy");
          set_style(div1, "--input-color",
          /*queryColorHex*/
          ctx[3]);
          toggle_class(div1, "full",
          /*$highlightingFull*/
          ctx[4]);
          add_location(div1, file$h, 240, 2, 6622);
          attr_dev(div2, "class", "watchlist");
          add_location(div2, file$h, 253, 2, 7354);
          attr_dev(div3, "class", "search tab-content svelte-ckhzsy");
          add_location(div3, file$h, 239, 0, 6587);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div1);
          if_block.m(div1, null);
          append_dev(div1, t0);
          append_dev(div1, div0);
          mount_component(icon, div0, null);
          append_dev(div3, t1);
          append_dev(div3, div2);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div2, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*add*/
            ctx[7], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div1, t0);
            }
          }

          if (dirty &
          /*matchedQuery, $highlightingFull*/
          18) {
            toggle_class(div0, "disabled",
            /*matchedQuery*/
            ctx[1] == null ||
            /*$highlightingFull*/
            ctx[4]);
          }

          if (!current || dirty &
          /*queryColorHex*/
          8) {
            set_style(div1, "--input-color",
            /*queryColorHex*/
            ctx[3]);
          }

          if (dirty &
          /*$highlightingFull*/
          16) {
            toggle_class(div1, "full",
            /*$highlightingFull*/
            ctx[4]);
          }

          if (dirty &
          /*remove, watchlist, CrossIcon, queryType, queryIcons*/
          356) {
            each_value =
            /*watchlist*/
            ctx[2];
            validate_each_argument(each_value);
            group_outros();

            for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();

            validate_each_keys(ctx, each_value, get_each_context$6, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div2, fix_and_outro_and_destroy_block, create_each_block$6, null, get_each_context$6);

            for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
          if_block.d();
          destroy_component(icon);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$h.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
      let $freezeResize;
      let $highlightingFull;
      let $highlight;
      let $newHighlightQuery;
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(20, $freezeResize = $$value));
      validate_store(highlightingFull, 'highlightingFull');
      component_subscribe($$self, highlightingFull, $$value => $$invalidate(4, $highlightingFull = $$value));
      validate_store(highlight, 'highlight');
      component_subscribe($$self, highlight, $$value => $$invalidate(21, $highlight = $$value));
      validate_store(newHighlightQuery, 'newHighlightQuery');
      component_subscribe($$self, newHighlightQuery, $$value => $$invalidate(14, $newHighlightQuery = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SearchTab', slots, []);
      const highlightColors = [highlightA, highlightB, highlightC, highlightD, highlightE];
      const highlightHexColors = highlightColors.map(c => hlToHex(c));
      const usedColors = [false, false, false, false, false];
      const queryIcons = {
        txid: TxIcon,
        address: AddressIcon
      };
      const queryType = {
        txid: 'transaction',
        address: 'address'
      };
      let {
        tab
      } = $$props;
      let query;
      let matchedQuery;
      let queryAddress;
      let queryColorIndex;
      let queryColor;
      let queryColorHex;
      let watchlist = [];
      init();
      setNextColor();

      function init() {
        const val = localStorage.getItem('highlight');

        if (val != null) {
          try {
            $$invalidate(2, watchlist = JSON.parse(val));
            watchlist.forEach(q => {
              if (q.colorIndex) {
                usedColors[q.colorIndex] = true;
                q.color = highlightColors[q.colorIndex];
                q.colorHex = highlightHexColors[q.colorIndex];
              }
            });
            watchlist.forEach(q => {
              if (!q.colorIndex) {
                const nextIndex = usedColors.findIndex(used => !used);
                usedColors[nextIndex] = true;
                q.colorIndex = nextIndex;
                q.color = highlightColors[nextIndex];
                q.colorHex = highlightHexColors[nextIndex];
              }
            });
          } catch (e) {
            console.log('failed to parse cached highlight queries');
          }
        }
      }

      function setNextColor() {
        const nextIndex = usedColors.findIndex(used => !used);

        if (nextIndex >= 0) {
          $$invalidate(13, queryColorIndex = nextIndex);
          queryColor = highlightColors[nextIndex];
          $$invalidate(3, queryColorHex = highlightHexColors[nextIndex]);
          usedColors[nextIndex] = true;
        }
      }

      function clearUsedColor(colorIndex) {
        usedColors[colorIndex] = false;
      }

      async function add() {
        if (matchedQuery && matchedQuery.query !== 'blockhash' && matchedQuery.query !== 'blockheight' && !$highlightingFull) {
          watchlist.push({ ...matchedQuery
          });
          $$invalidate(2, watchlist);
          $$invalidate(0, query = null);
          setNextColor();

          if (tab) {
            await tick();
            tab.updateContentHeight(true);
          }
        }
      }

      async function remove(index) {
        const wasFull = $highlightingFull;
        const removed = watchlist.splice(index, 1);

        if (removed.length) {
          clearUsedColor(removed[0].colorIndex);
          $$invalidate(2, watchlist);

          if (tab) {
            await tick();
            tab.updateContentHeight(true);
          }

          if (wasFull) setNextColor();
        }
      }

      function searchSubmit(e) {
        e.preventDefault();
        if (document.activeElement) document.activeElement.blur();
        add();
        return false;
      }

      let freezeTimeout;

      function focusIn(e) {
        if (freezeTimeout) clearTimeout(freezeTimeout);
        set_store_value(freezeResize, $freezeResize = true, $freezeResize);
      }

      async function focusOut(e) {
        freezeTimeout = setTimeout(() => {
          set_store_value(freezeResize, $freezeResize = false, $freezeResize);
        }, 500);
      }

      const writable_props = ['tab'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<SearchTab> was created with unknown prop '${key}'`);
      });

      function input_input_handler() {
        query = this.value;
        (($$invalidate(0, query), $$invalidate(14, $newHighlightQuery)), $$invalidate(1, matchedQuery)), $$invalidate(13, queryColorIndex);
      }

      const click_handler = index => remove(index);

      $$self.$$set = $$props => {
        if ('tab' in $$props) $$invalidate(12, tab = $$props.tab);
      };

      $$self.$capture_state = () => ({
        tick,
        fade,
        flip,
        Icon,
        SearchIcon,
        PlusIcon,
        CrossIcon,
        AddressIcon,
        TxIcon,
        matchQuery,
        highlight,
        newHighlightQuery,
        highlightingFull,
        freezeResize,
        hlToHex,
        highlightA,
        highlightB,
        highlightC,
        highlightD,
        highlightE,
        highlightColors,
        highlightHexColors,
        usedColors,
        queryIcons,
        queryType,
        tab,
        query,
        matchedQuery,
        queryAddress,
        queryColorIndex,
        queryColor,
        queryColorHex,
        watchlist,
        init,
        setNextColor,
        clearUsedColor,
        add,
        remove,
        searchSubmit,
        freezeTimeout,
        focusIn,
        focusOut,
        $freezeResize,
        $highlightingFull,
        $highlight,
        $newHighlightQuery
      });

      $$self.$inject_state = $$props => {
        if ('tab' in $$props) $$invalidate(12, tab = $$props.tab);
        if ('query' in $$props) $$invalidate(0, query = $$props.query);
        if ('matchedQuery' in $$props) $$invalidate(1, matchedQuery = $$props.matchedQuery);
        if ('queryAddress' in $$props) queryAddress = $$props.queryAddress;
        if ('queryColorIndex' in $$props) $$invalidate(13, queryColorIndex = $$props.queryColorIndex);
        if ('queryColor' in $$props) queryColor = $$props.queryColor;
        if ('queryColorHex' in $$props) $$invalidate(3, queryColorHex = $$props.queryColorHex);
        if ('watchlist' in $$props) $$invalidate(2, watchlist = $$props.watchlist);
        if ('freezeTimeout' in $$props) freezeTimeout = $$props.freezeTimeout;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$newHighlightQuery, matchedQuery, queryColorIndex*/
        24578) {
          {
            if ($newHighlightQuery) {
              $$invalidate(1, matchedQuery = matchQuery($newHighlightQuery));
              if (matchedQuery && (matchedQuery.query === 'blockhash' || matchedQuery.query === 'blockheight')) $$invalidate(1, matchedQuery = null);

              if (matchedQuery) {
                $$invalidate(1, matchedQuery.colorIndex = queryColorIndex, matchedQuery);
                $$invalidate(1, matchedQuery.color = highlightColors[queryColorIndex], matchedQuery);
                $$invalidate(1, matchedQuery.colorHex = highlightHexColors[queryColorIndex], matchedQuery);
                add();
                $$invalidate(0, query = null);
              }

              set_store_value(newHighlightQuery, $newHighlightQuery = null, $newHighlightQuery);
            }
          }
        }

        if ($$self.$$.dirty &
        /*query, matchedQuery, queryColorIndex*/
        8195) {
          {
            if (query) {
              $$invalidate(1, matchedQuery = matchQuery(query.trim()));
              if (matchedQuery && (matchedQuery.query === 'blockhash' || matchedQuery.query === 'blockheight')) $$invalidate(1, matchedQuery = null);

              if (matchedQuery) {
                $$invalidate(1, matchedQuery.colorIndex = queryColorIndex, matchedQuery);
                $$invalidate(1, matchedQuery.color = highlightColors[queryColorIndex], matchedQuery);
                $$invalidate(1, matchedQuery.colorHex = highlightHexColors[queryColorIndex], matchedQuery);
              }
            } else $$invalidate(1, matchedQuery = null);
          }
        }

        if ($$self.$$.dirty &
        /*matchedQuery, watchlist*/
        6) {
          {
            set_store_value(highlight, $highlight = matchedQuery ? [...watchlist, matchedQuery] : watchlist, $highlight);
          }
        }

        if ($$self.$$.dirty &
        /*watchlist*/
        4) {
          {
            localStorage.setItem('highlight', JSON.stringify(watchlist));
          }
        }

        if ($$self.$$.dirty &
        /*watchlist*/
        4) {
          {
            set_store_value(highlightingFull, $highlightingFull = watchlist.length >= 5, $highlightingFull);
          }
        }
      };

      return [query, matchedQuery, watchlist, queryColorHex, $highlightingFull, queryIcons, queryType, add, remove, searchSubmit, focusIn, focusOut, tab, queryColorIndex, $newHighlightQuery, input_input_handler, click_handler];
    }

    class SearchTab extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$h, create_fragment$h, safe_not_equal, {
          tab: 12
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SearchTab",
          options,
          id: create_fragment$h.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*tab*/
        ctx[12] === undefined && !('tab' in props)) {
          console_1$1.warn("<SearchTab> was created without expected prop 'tab'");
        }
      }

      get tab() {
        throw new Error("<SearchTab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set tab(value) {
        throw new Error("<SearchTab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/Sidebar.svelte generated by Svelte v3.44.3 */
    const file$g = "src/components/Sidebar.svelte"; // (67:2) {#if blockHidden }

    function create_if_block_3$3(ctx) {
      let sidebartab;
      let current;
      sidebartab = new SidebarTab({
        props: {
          tooltip: "Show Latest Block",
          $$slots: {
            content: [create_content_slot_5],
            tab: [create_tab_slot_8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab.$on("click",
      /*click_handler*/
      ctx[10]);
      const block = {
        c: function create() {
          create_component(sidebartab.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebartab, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const sidebartab_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab.$set(sidebartab_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebartab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebartab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebartab, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$3.name,
        type: "if",
        source: "(67:2) {#if blockHidden }",
        ctx
      });
      return block;
    } // (69:6) 


    function create_tab_slot_8(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: gridIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 68, 6, 2103);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_8.name,
        type: "slot",
        source: "(69:6) ",
        ctx
      });
      return block;
    } // (72:6) 


    function create_content_slot_5(ctx) {
      let div;
      let mempoollegend;
      let current;
      mempoollegend = new MempoolLegend({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(mempoollegend.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 71, 6, 2196);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(mempoollegend, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(mempoollegend.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(mempoollegend.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(mempoollegend);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot_5.name,
        type: "slot",
        source: "(72:6) ",
        ctx
      });
      return block;
    } // (77:2) {#if config.dev && config.debug}


    function create_if_block_2$4(ctx) {
      let sidebartab;
      let current;
      sidebartab = new SidebarTab({
        props: {
          open:
          /*$sidebarToggle*/
          ctx[2] === 'dev',
          tooltip: "Debug",
          $$slots: {
            content: [create_content_slot_4],
            tab: [create_tab_slot_7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab.$on("click",
      /*click_handler_1*/
      ctx[11]);
      const block = {
        c: function create() {
          create_component(sidebartab.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebartab, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const sidebartab_changes = {};
          if (dirty &
          /*$sidebarToggle*/
          4) sidebartab_changes.open =
          /*$sidebarToggle*/
          ctx[2] === 'dev';

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab.$set(sidebartab_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebartab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebartab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebartab, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$4.name,
        type: "if",
        source: "(77:2) {#if config.dev && config.debug}",
        ctx
      });
      return block;
    } // (79:6) 


    function create_tab_slot_7(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: codeIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 78, 6, 2423);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_7.name,
        type: "slot",
        source: "(79:6) ",
        ctx
      });
      return block;
    } // (82:6) 


    function create_content_slot_4(ctx) {
      let div;
      let devtools;
      let current;
      devtools = new DevTools({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(devtools.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 81, 6, 2516);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(devtools, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(devtools.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(devtools.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(devtools);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot_4.name,
        type: "slot",
        source: "(82:6) ",
        ctx
      });
      return block;
    } // (87:2) {#if config.donationsEnabled }


    function create_if_block_1$5(ctx) {
      let sidebartab;
      let current;
      sidebartab = new SidebarTab({
        props: {
          tooltip: "Donate",
          $$slots: {
            tab: [create_tab_slot_6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab.$on("click",
      /*click_handler_2*/
      ctx[12]);
      const block = {
        c: function create() {
          create_component(sidebartab.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebartab, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const sidebartab_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab.$set(sidebartab_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebartab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebartab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebartab, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$5.name,
        type: "if",
        source: "(87:2) {#if config.donationsEnabled }",
        ctx
      });
      return block;
    } // (89:6) 


    function create_tab_slot_6(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: giftIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 88, 6, 2711);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_6.name,
        type: "slot",
        source: "(89:6) ",
        ctx
      });
      return block;
    } // (94:2) {#if $haveSupporters }


    function create_if_block$b(ctx) {
      let sidebartab;
      let current;
      sidebartab = new SidebarTab({
        props: {
          tooltip: "Supporters",
          $$slots: {
            tab: [create_tab_slot_5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab.$on("click",
      /*click_handler_3*/
      ctx[13]);
      const block = {
        c: function create() {
          create_component(sidebartab.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(sidebartab, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const sidebartab_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab.$set(sidebartab_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidebartab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidebartab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidebartab, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$b.name,
        type: "if",
        source: "(94:2) {#if $haveSupporters }",
        ctx
      });
      return block;
    } // (96:6) 


    function create_tab_slot_5(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: peopleIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 95, 6, 2936);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_5.name,
        type: "slot",
        source: "(96:6) ",
        ctx
      });
      return block;
    } // (102:4) 


    function create_tab_slot_4(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: questionIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 101, 4, 3124);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_4.name,
        type: "slot",
        source: "(102:4) ",
        ctx
      });
      return block;
    } // (107:4) 


    function create_tab_slot_3(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: atIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 106, 4, 3339);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_3.name,
        type: "slot",
        source: "(107:4) ",
        ctx
      });
      return block;
    } // (110:4) 


    function create_content_slot_3(ctx) {
      let div;
      let contacttab;
      let current;
      contacttab = new ContactTab({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(contacttab.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 109, 4, 3424);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(contacttab, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(contacttab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(contacttab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(contacttab);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot_3.name,
        type: "slot",
        source: "(110:4) ",
        ctx
      });
      return block;
    } // (115:4) 


    function create_tab_slot_2(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: infoIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          add_location(span, file$g, 114, 4, 3599);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_2.name,
        type: "slot",
        source: "(115:4) ",
        ctx
      });
      return block;
    } // (118:4) 


    function create_content_slot_2(ctx) {
      let div;
      let mempoollegend;
      let current;
      mempoollegend = new MempoolLegend({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(mempoollegend.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 117, 4, 3686);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(mempoollegend, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(mempoollegend.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(mempoollegend.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(mempoollegend);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot_2.name,
        type: "slot",
        source: "(118:4) ",
        ctx
      });
      return block;
    } // (123:4) 


    function create_tab_slot_1(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: BookmarkIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          attr_dev(span, "title", "Search & Highlight");
          add_location(span, file$g, 122, 4, 3910);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot_1.name,
        type: "slot",
        source: "(123:4) ",
        ctx
      });
      return block;
    } // (126:4) 


    function create_content_slot_1(ctx) {
      let div;
      let searchtab;
      let current;
      searchtab = new SearchTab({
        props: {
          tab:
          /*searchTabComponent*/
          ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(searchtab.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 125, 4, 4028);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(searchtab, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const searchtab_changes = {};
          if (dirty &
          /*searchTabComponent*/
          1) searchtab_changes.tab =
          /*searchTabComponent*/
          ctx[0];
          searchtab.$set(searchtab_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(searchtab.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(searchtab.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(searchtab);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot_1.name,
        type: "slot",
        source: "(126:4) ",
        ctx
      });
      return block;
    } // (131:4) 


    function create_tab_slot(ctx) {
      let span;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: cogIcon,
          color: "var(--bold-a)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          attr_dev(span, "slot", "tab");
          attr_dev(span, "title", "Settings");
          add_location(span, file$g, 130, 4, 4236);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_tab_slot.name,
        type: "slot",
        source: "(131:4) ",
        ctx
      });
      return block;
    } // (134:4) 


    function create_content_slot(ctx) {
      let div;
      let settings_1;
      let current;
      settings_1 = new Settings({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(settings_1.$$.fragment);
          attr_dev(div, "slot", "content");
          add_location(div, file$g, 133, 4, 4339);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(settings_1, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(settings_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(settings_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(settings_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_content_slot.name,
        type: "slot",
        source: "(134:4) ",
        ctx
      });
      return block;
    }

    function create_fragment$g(ctx) {
      let div;
      let t0;
      let t1;
      let t2;
      let t3;
      let sidebartab0;
      let t4;
      let sidebartab1;
      let t5;
      let sidebartab2;
      let t6;
      let sidebartab3;
      let t7;
      let sidebartab4;
      let current;
      let if_block0 =
      /*blockHidden*/
      ctx[1] && create_if_block_3$3(ctx);
      let if_block1 = config$1.dev && config$1.debug && create_if_block_2$4(ctx);
      let if_block2 = config$1.donationsEnabled && create_if_block_1$5(ctx);
      let if_block3 =
      /*$haveSupporters*/
      ctx[4] && create_if_block$b(ctx);
      sidebartab0 = new SidebarTab({
        props: {
          tooltip: "About",
          $$slots: {
            tab: [create_tab_slot_4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab0.$on("click",
      /*click_handler_4*/
      ctx[14]);
      sidebartab1 = new SidebarTab({
        props: {
          open:
          /*$sidebarToggle*/
          ctx[2] === 'contact',
          tooltip: "Contact",
          $$slots: {
            content: [create_content_slot_3],
            tab: [create_tab_slot_3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab1.$on("click",
      /*click_handler_5*/
      ctx[15]);
      sidebartab2 = new SidebarTab({
        props: {
          open:
          /*$sidebarToggle*/
          ctx[2] === 'legend',
          tooltip: "Key",
          $$slots: {
            content: [create_content_slot_2],
            tab: [create_tab_slot_2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab2.$on("click",
      /*click_handler_6*/
      ctx[16]);
      let sidebartab3_props = {
        open:
        /*$sidebarToggle*/
        ctx[2] === 'search',
        tooltip: "Search & Highlight",
        $$slots: {
          content: [create_content_slot_1],
          tab: [create_tab_slot_1]
        },
        $$scope: {
          ctx
        }
      };
      sidebartab3 = new SidebarTab({
        props: sidebartab3_props,
        $$inline: true
      });
      /*sidebartab3_binding*/

      ctx[17](sidebartab3);
      sidebartab3.$on("click",
      /*click_handler_7*/
      ctx[18]);
      sidebartab4 = new SidebarTab({
        props: {
          open:
          /*$sidebarToggle*/
          ctx[2] === 'settings',
          tooltip: "Settings",
          $$slots: {
            content: [create_content_slot],
            tab: [create_tab_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      sidebartab4.$on("click",
      /*click_handler_8*/
      ctx[19]);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          if (if_block2) if_block2.c();
          t2 = space();
          if (if_block3) if_block3.c();
          t3 = space();
          create_component(sidebartab0.$$.fragment);
          t4 = space();
          create_component(sidebartab1.$$.fragment);
          t5 = space();
          create_component(sidebartab2.$$.fragment);
          t6 = space();
          create_component(sidebartab3.$$.fragment);
          t7 = space();
          create_component(sidebartab4.$$.fragment);
          attr_dev(div, "class", "sidebar svelte-ukpnhu");
          toggle_class(div, "frozen",
          /*$freezeResize*/
          ctx[3]);
          add_location(div, file$g, 64, 0, 1875);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t0);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t1);
          if (if_block2) if_block2.m(div, null);
          append_dev(div, t2);
          if (if_block3) if_block3.m(div, null);
          append_dev(div, t3);
          mount_component(sidebartab0, div, null);
          append_dev(div, t4);
          mount_component(sidebartab1, div, null);
          append_dev(div, t5);
          mount_component(sidebartab2, div, null);
          append_dev(div, t6);
          mount_component(sidebartab3, div, null);
          append_dev(div, t7);
          mount_component(sidebartab4, div, null);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (
          /*blockHidden*/
          ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*blockHidden*/
              2) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_3$3(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (config$1.dev && config$1.debug) if_block1.p(ctx, dirty);
          if (config$1.donationsEnabled) if_block2.p(ctx, dirty);

          if (
          /*$haveSupporters*/
          ctx[4]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*$haveSupporters*/
              16) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$b(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, t3);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          const sidebartab0_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab0.$set(sidebartab0_changes);
          const sidebartab1_changes = {};
          if (dirty &
          /*$sidebarToggle*/
          4) sidebartab1_changes.open =
          /*$sidebarToggle*/
          ctx[2] === 'contact';

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab1.$set(sidebartab1_changes);
          const sidebartab2_changes = {};
          if (dirty &
          /*$sidebarToggle*/
          4) sidebartab2_changes.open =
          /*$sidebarToggle*/
          ctx[2] === 'legend';

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab2.$set(sidebartab2_changes);
          const sidebartab3_changes = {};
          if (dirty &
          /*$sidebarToggle*/
          4) sidebartab3_changes.open =
          /*$sidebarToggle*/
          ctx[2] === 'search';

          if (dirty &
          /*$$scope, searchTabComponent*/
          2097153) {
            sidebartab3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab3.$set(sidebartab3_changes);
          const sidebartab4_changes = {};
          if (dirty &
          /*$sidebarToggle*/
          4) sidebartab4_changes.open =
          /*$sidebarToggle*/
          ctx[2] === 'settings';

          if (dirty &
          /*$$scope*/
          2097152) {
            sidebartab4_changes.$$scope = {
              dirty,
              ctx
            };
          }

          sidebartab4.$set(sidebartab4_changes);

          if (dirty &
          /*$freezeResize*/
          8) {
            toggle_class(div, "frozen",
            /*$freezeResize*/
            ctx[3]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(sidebartab0.$$.fragment, local);
          transition_in(sidebartab1.$$.fragment, local);
          transition_in(sidebartab2.$$.fragment, local);
          transition_in(sidebartab3.$$.fragment, local);
          transition_in(sidebartab4.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(sidebartab0.$$.fragment, local);
          transition_out(sidebartab1.$$.fragment, local);
          transition_out(sidebartab2.$$.fragment, local);
          transition_out(sidebartab3.$$.fragment, local);
          transition_out(sidebartab4.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          destroy_component(sidebartab0);
          destroy_component(sidebartab1);
          destroy_component(sidebartab2);
          /*sidebartab3_binding*/

          ctx[17](null);
          destroy_component(sidebartab3);
          destroy_component(sidebartab4);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$g.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
      let $blockVisible;
      let $overlay;
      let $sidebarToggle;
      let $currentBlock;
      let $freezeResize;
      let $haveSupporters;
      validate_store(blockVisible, 'blockVisible');
      component_subscribe($$self, blockVisible, $$value => $$invalidate(8, $blockVisible = $$value));
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(20, $overlay = $$value));
      validate_store(sidebarToggle, 'sidebarToggle');
      component_subscribe($$self, sidebarToggle, $$value => $$invalidate(2, $sidebarToggle = $$value));
      validate_store(currentBlock, 'currentBlock');
      component_subscribe($$self, currentBlock, $$value => $$invalidate(9, $currentBlock = $$value));
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(3, $freezeResize = $$value));
      validate_store(haveSupporters, 'haveSupporters');
      component_subscribe($$self, haveSupporters, $$value => $$invalidate(4, $haveSupporters = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Sidebar', slots, []);
      let searchTabComponent;
      let blockHidden = false;

      function settings(tab) {
        if ($sidebarToggle) analytics.trackEvent('sidebar', $sidebarToggle, 'close');

        if ($sidebarToggle === tab) {
          sidebarToggle.set(null);
        } else {
          analytics.trackEvent('sidebar', tab, 'open');
          sidebarToggle.set(tab);
        }
      }

      function openOverlay(key) {
        set_store_value(overlay, $overlay = key, $overlay);
      }

      function showBlock() {
        analytics.trackEvent('viz', 'block', 'show');
        set_store_value(blockVisible, $blockVisible = true, $blockVisible);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
      });

      const click_handler = () => showBlock();

      const click_handler_1 = () => {
        settings('dev');
      };

      const click_handler_2 = () => openOverlay('donation');

      const click_handler_3 = () => openOverlay('supporters');

      const click_handler_4 = () => openOverlay('about');

      const click_handler_5 = () => {
        settings('contact');
      };

      const click_handler_6 = () => {
        settings('legend');
      };

      function sidebartab3_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          searchTabComponent = $$value;
          $$invalidate(0, searchTabComponent);
        });
      }

      const click_handler_7 = () => {
        settings('search');
      };

      const click_handler_8 = () => {
        settings('settings');
      };

      $$self.$capture_state = () => ({
        config: config$1,
        analytics,
        SidebarTab,
        Icon,
        Settings,
        cogIcon,
        DevTools,
        codeIcon,
        questionIcon,
        infoIcon,
        atIcon,
        gridIcon,
        peopleIcon,
        giftIcon,
        bookmarkIcon: BookmarkIcon,
        MempoolLegend,
        ContactTab,
        SearchTab,
        sidebarToggle,
        overlay,
        currentBlock,
        blockVisible,
        haveSupporters,
        freezeResize,
        searchTabComponent,
        blockHidden,
        settings,
        openOverlay,
        showBlock,
        $blockVisible,
        $overlay,
        $sidebarToggle,
        $currentBlock,
        $freezeResize,
        $haveSupporters
      });

      $$self.$inject_state = $$props => {
        if ('searchTabComponent' in $$props) $$invalidate(0, searchTabComponent = $$props.searchTabComponent);
        if ('blockHidden' in $$props) $$invalidate(1, blockHidden = $$props.blockHidden);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$currentBlock, $blockVisible*/
        768) {
          $$invalidate(1, blockHidden = $currentBlock && !$blockVisible);
        }
      };

      return [searchTabComponent, blockHidden, $sidebarToggle, $freezeResize, $haveSupporters, settings, openOverlay, showBlock, $blockVisible, $currentBlock, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, click_handler_6, sidebartab3_binding, click_handler_7, click_handler_8];
    }

    class Sidebar extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$g, create_fragment$g, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Sidebar",
          options,
          id: create_fragment$g.name
        });
      }

    }

    /* src/components/Overlay.svelte generated by Svelte v3.44.3 */
    const file$f = "src/components/Overlay.svelte"; // (95:0) {#if open}

    function create_if_block$a(ctx) {
      let div3;
      let div0;
      let div0_transition;
      let t0;
      let div2;
      let div1;
      let div1_id_value;
      let t1;
      let button;
      let icon;
      let div2_transition;
      let current;
      let mounted;
      let dispose;
      const default_slot_template =
      /*#slots*/
      ctx[6].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[5], null);
      icon = new Icon({
        props: {
          icon: closeIcon,
          color: "var(--palette-x)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div3 = element("div");
          div0 = element("div");
          t0 = space();
          div2 = element("div");
          div1 = element("div");
          if (default_slot) default_slot.c();
          t1 = space();
          button = element("button");
          create_component(icon.$$.fragment);
          attr_dev(div0, "class", "overlay-background svelte-ua090o");
          add_location(div0, file$f, 96, 2, 2001);
          attr_dev(div1, "class", "overlay-inner svelte-ua090o");
          attr_dev(div1, "id", div1_id_value = "" + (
          /*name*/
          ctx[0] + "Overlay"));
          add_location(div1, file$f, 98, 4, 2192);
          attr_dev(button, "class", "close-button svelte-ua090o");
          add_location(button, file$f, 101, 4, 2269);
          attr_dev(div2, "class", "overlay-outer svelte-ua090o");
          toggle_class(div2, "full-size",
          /*fullSize*/
          ctx[1]);
          add_location(div2, file$f, 97, 2, 2091);
          attr_dev(div3, "class", "overlay-wrapper svelte-ua090o");
          add_location(div3, file$f, 95, 0, 1968);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div3, t0);
          append_dev(div3, div2);
          append_dev(div2, div1);

          if (default_slot) {
            default_slot.m(div1, null);
          }

          append_dev(div2, t1);
          append_dev(div2, button);
          mount_component(icon, button, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(div0, "click",
            /*close*/
            ctx[3], false, false, false), listen_dev(button, "click",
            /*close*/
            ctx[3], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope*/
            32)) {
              update_slot_base(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[5], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[5]) : get_slot_changes(default_slot_template,
              /*$$scope*/
              ctx[5], dirty, null), null);
            }
          }

          if (!current || dirty &
          /*name*/
          1 && div1_id_value !== (div1_id_value = "" + (
          /*name*/
          ctx[0] + "Overlay"))) {
            attr_dev(div1, "id", div1_id_value);
          }

          if (dirty &
          /*fullSize*/
          2) {
            toggle_class(div2, "full-size",
            /*fullSize*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {
              duration: 500
            }, true);
            div0_transition.run(1);
          });
          transition_in(default_slot, local);
          transition_in(icon.$$.fragment, local);
          add_render_callback(() => {
            if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
              duration: 500,
              y: 50
            }, true);
            div2_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {
            duration: 500
          }, false);
          div0_transition.run(0);
          transition_out(default_slot, local);
          transition_out(icon.$$.fragment, local);
          if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
            duration: 500,
            y: 50
          }, false);
          div2_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
          if (detaching && div0_transition) div0_transition.end();
          if (default_slot) default_slot.d(detaching);
          destroy_component(icon);
          if (detaching && div2_transition) div2_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$a.name,
        type: "if",
        source: "(95:0) {#if open}",
        ctx
      });
      return block;
    }

    function create_fragment$f(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*open*/
      ctx[2] && create_if_block$a(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (
          /*open*/
          ctx[2]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*open*/
              4) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$a(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
      let $overlay;
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(4, $overlay = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Overlay', slots, ['default']);
      const dispatch = createEventDispatcher();
      let {
        name = 'none'
      } = $$props;
      let {
        fullSize = false
      } = $$props;
      let open;

      function close() {
        set_store_value(overlay, $overlay = null, $overlay);
        dispatch('close');
      }

      const writable_props = ['name', 'fullSize'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Overlay> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('name' in $$props) $$invalidate(0, name = $$props.name);
        if ('fullSize' in $$props) $$invalidate(1, fullSize = $$props.fullSize);
        if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        analytics,
        Icon,
        closeIcon,
        overlay,
        createEventDispatcher,
        fade,
        fly,
        dispatch,
        name,
        fullSize,
        open,
        close,
        $overlay
      });

      $$self.$inject_state = $$props => {
        if ('name' in $$props) $$invalidate(0, name = $$props.name);
        if ('fullSize' in $$props) $$invalidate(1, fullSize = $$props.fullSize);
        if ('open' in $$props) $$invalidate(2, open = $$props.open);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*open, $overlay, name*/
        21) {
          {
            const oldOpen = open;
            $$invalidate(2, open = $overlay === name);

            if (oldOpen !== undefined && open != oldOpen) {
              analytics.trackEvent('overlay', name, open ? 'open' : 'close');
            }
          }
        }
      };

      return [name, fullSize, open, close, $overlay, $$scope, slots];
    }

    class Overlay extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$f, create_fragment$f, safe_not_equal, {
          name: 0,
          fullSize: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Overlay",
          options,
          id: create_fragment$f.name
        });
      }

      get name() {
        throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set name(value) {
        throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get fullSize() {
        throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set fullSize(value) {
        throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/TransactionOverlay.svelte generated by Svelte v3.44.3 */
    const file$e = "src/components/TransactionOverlay.svelte";

    function get_each_context$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[39] = list[i];
      return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[42] = list[i];
      child_ctx[44] = i;
      return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[42] = list[i];
      child_ctx[44] = i;
      return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[46] = list[i];
      child_ctx[44] = i;
      return child_ctx;
    } // (567:2) {#if $detailTx}


    function create_if_block$9(ctx) {
      let section;
      let div0;
      let icon;
      let t0;
      let t1;
      let h2;
      let span0;
      let t2;
      let span1;
      let t3_value =
      /*$detailTx*/
      ctx[4].id + "";
      let t3;
      let t4;
      let t5;
      let t6;
      let div4;
      let div1;
      let p0;
      let t7_value =
      /*$detailTx*/
      ctx[4].inputs.length + "";
      let t7;
      let t8;
      let t9_value = (
      /*$detailTx*/
      ctx[4].inputs.length > 1 ? 's' : '') + "";
      let t9;
      let t10;
      let t11;
      let div2;
      let t12;
      let div3;
      let p1;
      let t13_value =
      /*$detailTx*/
      ctx[4].outputs.length + "";
      let t13;
      let t14;
      let t15_value = (
      /*$detailTx*/
      ctx[4].outputs.length > 1 ? 's' : '') + "";
      let t15;
      let t16;
      let t17;
      let current;
      let mounted;
      let dispose;
      icon = new Icon({
        props: {
          icon: BookmarkIcon
        },
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*$detailTx*/
        ctx[4].block &&
        /*$latestBlockHeight*/
        ctx[5] != null) return create_if_block_13;
        return create_else_block_5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);

      function select_block_type_1(ctx, dirty) {
        if (
        /*$detailTx*/
        ctx[4].isCoinbase) return create_if_block_12$2;
        return create_else_block_4;
      }

      let current_block_type_1 = select_block_type_1(ctx);
      let if_block1 = current_block_type_1(ctx);
      let if_block2 =
      /*$detailTx*/
      ctx[4].block && create_if_block_11$2(ctx);

      function select_block_type_2(ctx, dirty) {
        if (
        /*$detailTx*/
        ctx[4].isCoinbase) return create_if_block_9$2;
        return create_else_block_2$1;
      }

      let current_block_type_2 = select_block_type_2(ctx);
      let if_block3 = current_block_type_2(ctx);
      let each_value_3 =
      /*inputs*/
      ctx[1];
      validate_each_argument(each_value_3);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_3.length; i += 1) {
        each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
      }

      let if_block4 =
      /*sankeyLines*/
      ctx[11] &&
      /*$pageWidth*/
      ctx[6] > 410 && create_if_block_5$2(ctx);
      let if_block5 =
      /*$detailTx*/
      ctx[4].fee && create_if_block_4$2(ctx);
      let each_value =
      /*outputs*/
      ctx[2];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          section = element("section");
          div0 = element("div");
          create_component(icon.$$.fragment);
          t0 = space();
          if_block0.c();
          t1 = space();
          h2 = element("h2");
          span0 = element("span");
          if_block1.c();
          t2 = space();
          span1 = element("span");
          t3 = text(t3_value);
          t4 = space();
          if (if_block2) if_block2.c();
          t5 = space();
          if_block3.c();
          t6 = space();
          div4 = element("div");
          div1 = element("div");
          p0 = element("p");
          t7 = text(t7_value);
          t8 = text(" input");
          t9 = text(t9_value);
          t10 = space();

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t11 = space();
          div2 = element("div");
          if (if_block4) if_block4.c();
          t12 = space();
          div3 = element("div");
          p1 = element("p");
          t13 = text(t13_value);
          t14 = text(" output");
          t15 = text(t15_value);
          t16 = space();
          if (if_block5) if_block5.c();
          t17 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div0, "class", "icon-button svelte-s7pekr");
          attr_dev(div0, "title", "Add transaction to watchlist");
          toggle_class(div0, "disabled",
          /*$highlightingFull*/
          ctx[14]);
          add_location(div0, file$e, 568, 6, 15087);
          attr_dev(span0, "class", "title svelte-s7pekr");
          add_location(span0, file$e, 580, 10, 15615);
          attr_dev(span1, "class", "tx-id svelte-s7pekr");
          add_location(span1, file$e, 580, 96, 15701);
          attr_dev(h2, "class", "svelte-s7pekr");
          add_location(h2, file$e, 580, 6, 15611);
          attr_dev(p0, "class", "header svelte-s7pekr");
          add_location(p0, file$e, 655, 10, 18904);
          attr_dev(div1, "class", "column inputs svelte-s7pekr");
          add_location(div1, file$e, 654, 8, 18866);
          attr_dev(div2, "class", "column diagram svelte-s7pekr");
          add_location(div2, file$e, 670, 8, 20041);
          attr_dev(p1, "class", "header svelte-s7pekr");
          add_location(p1, file$e, 698, 10, 21662);
          attr_dev(div3, "class", "column outputs svelte-s7pekr");
          add_location(div3, file$e, 697, 8, 21623);
          attr_dev(div4, "class", "pane flow-diagram svelte-s7pekr");
          set_style(div4, "grid-template-columns", "minmax(0px, 1fr) " +
          /*svgWidth*/
          ctx[0] + "px minmax(0px, 1fr)");
          add_location(div4, file$e, 653, 6, 18747);
          attr_dev(section, "class", "tx-detail svelte-s7pekr");
          add_location(section, file$e, 567, 4, 15053);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div0);
          mount_component(icon, div0, null);
          append_dev(section, t0);
          if_block0.m(section, null);
          append_dev(section, t1);
          append_dev(section, h2);
          append_dev(h2, span0);
          if_block1.m(span0, null);
          append_dev(h2, t2);
          append_dev(h2, span1);
          append_dev(span1, t3);
          append_dev(section, t4);
          if (if_block2) if_block2.m(section, null);
          append_dev(section, t5);
          if_block3.m(section, null);
          append_dev(section, t6);
          append_dev(section, div4);
          append_dev(div4, div1);
          append_dev(div1, p0);
          append_dev(p0, t7);
          append_dev(p0, t8);
          append_dev(p0, t9);
          append_dev(div1, t10);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(div1, null);
          }

          append_dev(div4, t11);
          append_dev(div4, div2);
          if (if_block4) if_block4.m(div2, null);
          append_dev(div4, t12);
          append_dev(div4, div3);
          append_dev(div3, p1);
          append_dev(p1, t13);
          append_dev(p1, t14);
          append_dev(p1, t15);
          append_dev(p1, t16);
          if (if_block5) if_block5.m(p1, null);
          append_dev(div3, t17);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div3, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*click_handler*/
            ctx[25], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$highlightingFull*/
          16384) {
            toggle_class(div0, "disabled",
            /*$highlightingFull*/
            ctx[14]);
          }

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(section, t1);
            }
          }

          if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
            if_block1.d(1);
            if_block1 = current_block_type_1(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(span0, null);
            }
          }

          if ((!current || dirty[0] &
          /*$detailTx*/
          16) && t3_value !== (t3_value =
          /*$detailTx*/
          ctx[4].id + "")) set_data_dev(t3, t3_value);

          if (
          /*$detailTx*/
          ctx[4].block) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
            } else {
              if_block2 = create_if_block_11$2(ctx);
              if_block2.c();
              if_block2.m(section, t5);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block3) {
            if_block3.p(ctx, dirty);
          } else {
            if_block3.d(1);
            if_block3 = current_block_type_2(ctx);

            if (if_block3) {
              if_block3.c();
              if_block3.m(section, t6);
            }
          }

          if ((!current || dirty[0] &
          /*$detailTx*/
          16) && t7_value !== (t7_value =
          /*$detailTx*/
          ctx[4].inputs.length + "")) set_data_dev(t7, t7_value);
          if ((!current || dirty[0] &
          /*$detailTx*/
          16) && t9_value !== (t9_value = (
          /*$detailTx*/
          ctx[4].inputs.length > 1 ? 's' : '') + "")) set_data_dev(t9, t9_value);

          if (dirty[0] &
          /*inputs, highlight, clickItem, goToInput*/
          787458) {
            each_value_3 =
            /*inputs*/
            ctx[1];
            validate_each_argument(each_value_3);
            let i;

            for (i = 0; i < each_value_3.length; i += 1) {
              const child_ctx = get_each_context_3(ctx, each_value_3, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
              } else {
                each_blocks_1[i] = create_each_block_3(child_ctx);
                each_blocks_1[i].c();
                each_blocks_1[i].m(div1, null);
              }
            }

            for (; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d(1);
            }

            each_blocks_1.length = each_value_3.length;
          }

          if (
          /*sankeyLines*/
          ctx[11] &&
          /*$pageWidth*/
          ctx[6] > 410) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block_5$2(ctx);
              if_block4.c();
              if_block4.m(div2, null);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }

          if ((!current || dirty[0] &
          /*$detailTx*/
          16) && t13_value !== (t13_value =
          /*$detailTx*/
          ctx[4].outputs.length + "")) set_data_dev(t13, t13_value);
          if ((!current || dirty[0] &
          /*$detailTx*/
          16) && t15_value !== (t15_value = (
          /*$detailTx*/
          ctx[4].outputs.length > 1 ? 's' : '') + "")) set_data_dev(t15, t15_value);

          if (
          /*$detailTx*/
          ctx[4].fee) {
            if (if_block5) ; else {
              if_block5 = create_if_block_4$2(ctx);
              if_block5.c();
              if_block5.m(p1, null);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if (dirty[0] &
          /*outputs, highlight, clickItem, loadingSpends, spends, goToSpend*/
          1324036) {
            each_value =
            /*outputs*/
            ctx[2];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$5(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$5(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div3, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (!current || dirty[0] &
          /*svgWidth*/
          1) {
            set_style(div4, "grid-template-columns", "minmax(0px, 1fr) " +
            /*svgWidth*/
            ctx[0] + "px minmax(0px, 1fr)");
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          destroy_component(icon);
          if_block0.d();
          if_block1.d();
          if (if_block2) if_block2.d();
          if_block3.d();
          destroy_each(each_blocks_1, detaching);
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$9.name,
        type: "if",
        source: "(567:2) {#if $detailTx}",
        ctx
      });
      return block;
    } // (576:6) {:else}


    function create_else_block_5(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "unconfirmed";
          attr_dev(span, "class", "confirmation-badge unconfirmed svelte-s7pekr");
          add_location(span, file$e, 576, 8, 15509);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_5.name,
        type: "else",
        source: "(576:6) {:else}",
        ctx
      });
      return block;
    } // (572:6) {#if $detailTx.block && $latestBlockHeight != null}


    function create_if_block_13(ctx) {
      let span;
      let t0_value = numberFormat.format(
      /*confirmations*/
      ctx[8]) + "";
      let t0;
      let t1;
      let t2_value = (
      /*confirmations*/
      ctx[8] == 1 ? '' : 's') + "";
      let t2;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = text(" confirmation");
          t2 = text(t2_value);
          attr_dev(span, "class", "confirmation-badge svelte-s7pekr");
          add_location(span, file$e, 572, 8, 15346);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          append_dev(span, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*confirmations*/
          256 && t0_value !== (t0_value = numberFormat.format(
          /*confirmations*/
          ctx[8]) + "")) set_data_dev(t0, t0_value);
          if (dirty[0] &
          /*confirmations*/
          256 && t2_value !== (t2_value = (
          /*confirmations*/
          ctx[8] == 1 ? '' : 's') + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(572:6) {#if $detailTx.block && $latestBlockHeight != null}",
        ctx
      });
      return block;
    } // (581:65) {:else}


    function create_else_block_4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Transaction");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_4.name,
        type: "else",
        source: "(581:65) {:else}",
        ctx
      });
      return block;
    } // (581:30) {#if $detailTx.isCoinbase }


    function create_if_block_12$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Coinbase");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12$2.name,
        type: "if",
        source: "(581:30) {#if $detailTx.isCoinbase }",
        ctx
      });
      return block;
    } // (582:6) {#if $detailTx.block}


    function create_if_block_11$2(ctx) {
      let a;
      let div0;
      let span0;
      let t1;
      let span1;
      let t2_value = dateFormat.format(
      /*$detailTx*/
      ctx[4].block.time) + "";
      let t2;
      let t3;
      let span2;
      let t4;
      let div1;
      let span3;
      let t6;
      let span4;
      let t7_value = numberFormat.format(
      /*$detailTx*/
      ctx[4].block.height) + "";
      let t7;
      let a_href_value;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          a = element("a");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "confirmed";
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space();
          span2 = element("span");
          t4 = space();
          div1 = element("div");
          span3 = element("span");
          span3.textContent = "block height";
          t6 = space();
          span4 = element("span");
          t7 = text(t7_value);
          attr_dev(span0, "class", "label svelte-s7pekr");
          add_location(span0, file$e, 584, 12, 15960);
          attr_dev(span1, "class", "value svelte-s7pekr");
          set_style(span1, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span1, file$e, 585, 12, 16009);
          attr_dev(div0, "class", "field svelte-s7pekr");
          add_location(div0, file$e, 583, 10, 15928);
          attr_dev(span2, "class", "operator svelte-s7pekr");
          add_location(span2, file$e, 587, 10, 16134);
          attr_dev(span3, "class", "label svelte-s7pekr");
          add_location(span3, file$e, 589, 12, 16207);
          attr_dev(span4, "class", "value svelte-s7pekr");
          set_style(span4, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span4, file$e, 590, 12, 16259);
          attr_dev(div1, "class", "field svelte-s7pekr");
          add_location(div1, file$e, 588, 10, 16175);
          attr_dev(a, "class", "pane fields clickable svelte-s7pekr");
          attr_dev(a, "href", a_href_value = "/block/" + (
          /*$detailTx*/
          ctx[4].block.hash ||
          /*$detailTx*/
          ctx[4].block.id));
          attr_dev(a, "draggable", "false");
          add_location(a, file$e, 582, 8, 15786);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, div0);
          append_dev(div0, span0);
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          append_dev(a, t3);
          append_dev(a, span2);
          append_dev(a, t4);
          append_dev(a, div1);
          append_dev(div1, span3);
          append_dev(div1, t6);
          append_dev(div1, span4);
          append_dev(span4, t7);

          if (!mounted) {
            dispose = listen_dev(a, "click",
            /*goToBlock*/
            ctx[21], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$detailTx*/
          16 && t2_value !== (t2_value = dateFormat.format(
          /*$detailTx*/
          ctx[4].block.time) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span1, "color",
            /*feeColor*/
            ctx[9]);
          }

          if (dirty[0] &
          /*$detailTx*/
          16 && t7_value !== (t7_value = numberFormat.format(
          /*$detailTx*/
          ctx[4].block.height) + "")) set_data_dev(t7, t7_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span4, "color",
            /*feeColor*/
            ctx[9]);
          }

          if (dirty[0] &
          /*$detailTx*/
          16 && a_href_value !== (a_href_value = "/block/" + (
          /*$detailTx*/
          ctx[4].block.hash ||
          /*$detailTx*/
          ctx[4].block.id))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11$2.name,
        type: "if",
        source: "(582:6) {#if $detailTx.block}",
        ctx
      });
      return block;
    } // (619:6) {:else}


    function create_else_block_2$1(ctx) {
      let t0;
      let div1;
      let div0;
      let span0;
      let t2;
      let span1;
      let t3_value = formatBTC(
      /*$detailTx*/
      ctx[4].value) + "";
      let t3;

      function select_block_type_3(ctx, dirty) {
        if (
        /*$detailTx*/
        ctx[4].fee != null &&
        /*$detailTx*/
        ctx[4].feerate != null) return create_if_block_10$2;
        return create_else_block_3$1;
      }

      let current_block_type = select_block_type_3(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          if_block.c();
          t0 = space();
          div1 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "total value";
          t2 = space();
          span1 = element("span");
          t3 = text(t3_value);
          attr_dev(span0, "class", "label svelte-s7pekr");
          add_location(span0, file$e, 647, 12, 18560);
          attr_dev(span1, "class", "value svelte-s7pekr");
          set_style(span1, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span1, file$e, 648, 12, 18611);
          attr_dev(div0, "class", "field svelte-s7pekr");
          add_location(div0, file$e, 646, 10, 18528);
          attr_dev(div1, "class", "pane total-value svelte-s7pekr");
          add_location(div1, file$e, 645, 8, 18487);
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(div0, t2);
          append_dev(div0, span1);
          append_dev(span1, t3);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(t0.parentNode, t0);
            }
          }

          if (dirty[0] &
          /*$detailTx*/
          16 && t3_value !== (t3_value = formatBTC(
          /*$detailTx*/
          ctx[4].value) + "")) set_data_dev(t3, t3_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span1, "color",
            /*feeColor*/
            ctx[9]);
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$1.name,
        type: "else",
        source: "(619:6) {:else}",
        ctx
      });
      return block;
    } // (595:6) {#if $detailTx.isCoinbase}


    function create_if_block_9$2(ctx) {
      let div3;
      let div0;
      let span0;
      let t1;
      let span1;
      let t2_value = formatBTC(
      /*$detailTx*/
      ctx[4].coinbase.subsidy) + "";
      let t2;
      let t3;
      let span2;
      let t5;
      let div1;
      let span3;
      let t7;
      let span4;
      let t8_value = formatBTC(
      /*$detailTx*/
      ctx[4].coinbase.fees) + "";
      let t8;
      let t9;
      let span5;
      let t11;
      let div2;
      let span6;
      let t13;
      let span7;
      let t14_value = formatBTC(
      /*$detailTx*/
      ctx[4].value) + "";
      let t14;
      let t15;
      let div5;
      let div4;
      let span8;
      let t17;
      let span9;
      let t18_value =
      /*$detailTx*/
      ctx[4].coinbase.sigAscii + "";
      let t18;
      const block = {
        c: function create() {
          div3 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "block subsidy";
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space();
          span2 = element("span");
          span2.textContent = "+";
          t5 = space();
          div1 = element("div");
          span3 = element("span");
          span3.textContent = "fees";
          t7 = space();
          span4 = element("span");
          t8 = text(t8_value);
          t9 = space();
          span5 = element("span");
          span5.textContent = "=";
          t11 = space();
          div2 = element("div");
          span6 = element("span");
          span6.textContent = "total reward";
          t13 = space();
          span7 = element("span");
          t14 = text(t14_value);
          t15 = space();
          div5 = element("div");
          div4 = element("div");
          span8 = element("span");
          span8.textContent = "coinbase";
          t17 = space();
          span9 = element("span");
          t18 = text(t18_value);
          attr_dev(span0, "class", "label svelte-s7pekr");
          add_location(span0, file$e, 597, 12, 16512);
          attr_dev(span1, "class", "value svelte-s7pekr");
          add_location(span1, file$e, 598, 12, 16565);
          attr_dev(div0, "class", "field svelte-s7pekr");
          add_location(div0, file$e, 596, 10, 16480);
          attr_dev(span2, "class", "operator svelte-s7pekr");
          add_location(span2, file$e, 600, 10, 16661);
          attr_dev(span3, "class", "label svelte-s7pekr");
          add_location(span3, file$e, 602, 12, 16735);
          attr_dev(span4, "class", "value svelte-s7pekr");
          add_location(span4, file$e, 603, 12, 16779);
          attr_dev(div1, "class", "field svelte-s7pekr");
          add_location(div1, file$e, 601, 10, 16703);
          attr_dev(span5, "class", "operator svelte-s7pekr");
          add_location(span5, file$e, 605, 10, 16872);
          attr_dev(span6, "class", "label svelte-s7pekr");
          add_location(span6, file$e, 607, 12, 16946);
          attr_dev(span7, "class", "value svelte-s7pekr");
          add_location(span7, file$e, 608, 12, 16998);
          attr_dev(div2, "class", "field svelte-s7pekr");
          add_location(div2, file$e, 606, 10, 16914);
          attr_dev(div3, "class", "pane fields svelte-s7pekr");
          add_location(div3, file$e, 595, 8, 16444);
          attr_dev(span8, "class", "label svelte-s7pekr");
          add_location(span8, file$e, 614, 12, 17165);
          attr_dev(span9, "class", "value coinbase-sig svelte-s7pekr");
          add_location(span9, file$e, 615, 12, 17213);
          attr_dev(div4, "class", "field svelte-s7pekr");
          add_location(div4, file$e, 613, 10, 17133);
          attr_dev(div5, "class", "pane fields svelte-s7pekr");
          add_location(div5, file$e, 612, 8, 17097);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div0, span0);
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          append_dev(div3, t3);
          append_dev(div3, span2);
          append_dev(div3, t5);
          append_dev(div3, div1);
          append_dev(div1, span3);
          append_dev(div1, t7);
          append_dev(div1, span4);
          append_dev(span4, t8);
          append_dev(div3, t9);
          append_dev(div3, span5);
          append_dev(div3, t11);
          append_dev(div3, div2);
          append_dev(div2, span6);
          append_dev(div2, t13);
          append_dev(div2, span7);
          append_dev(span7, t14);
          insert_dev(target, t15, anchor);
          insert_dev(target, div5, anchor);
          append_dev(div5, div4);
          append_dev(div4, span8);
          append_dev(div4, t17);
          append_dev(div4, span9);
          append_dev(span9, t18);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$detailTx*/
          16 && t2_value !== (t2_value = formatBTC(
          /*$detailTx*/
          ctx[4].coinbase.subsidy) + "")) set_data_dev(t2, t2_value);
          if (dirty[0] &
          /*$detailTx*/
          16 && t8_value !== (t8_value = formatBTC(
          /*$detailTx*/
          ctx[4].coinbase.fees) + "")) set_data_dev(t8, t8_value);
          if (dirty[0] &
          /*$detailTx*/
          16 && t14_value !== (t14_value = formatBTC(
          /*$detailTx*/
          ctx[4].value) + "")) set_data_dev(t14, t14_value);
          if (dirty[0] &
          /*$detailTx*/
          16 && t18_value !== (t18_value =
          /*$detailTx*/
          ctx[4].coinbase.sigAscii + "")) set_data_dev(t18, t18_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
          if (detaching) detach_dev(t15);
          if (detaching) detach_dev(div5);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9$2.name,
        type: "if",
        source: "(595:6) {#if $detailTx.isCoinbase}",
        ctx
      });
      return block;
    } // (637:8) {:else}


    function create_else_block_3$1(ctx) {
      let div1;
      let div0;
      let span0;
      let t1;
      let span1;
      let t2_value = numberFormat.format(
      /*$detailTx*/
      ctx[4].vbytes) + "";
      let t2;
      let t3;
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "size";
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = text(" vbytes");
          attr_dev(span0, "class", "label svelte-s7pekr");
          add_location(span0, file$e, 639, 12, 18285);
          attr_dev(span1, "class", "value svelte-s7pekr");
          set_style(span1, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span1, file$e, 640, 12, 18329);
          attr_dev(div0, "class", "field svelte-s7pekr");
          add_location(div0, file$e, 638, 10, 18253);
          attr_dev(div1, "class", "pane fields svelte-s7pekr");
          add_location(div1, file$e, 637, 8, 18217);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          append_dev(span1, t3);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$detailTx*/
          16 && t2_value !== (t2_value = numberFormat.format(
          /*$detailTx*/
          ctx[4].vbytes) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span1, "color",
            /*feeColor*/
            ctx[9]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_3$1.name,
        type: "else",
        source: "(637:8) {:else}",
        ctx
      });
      return block;
    } // (620:8) {#if $detailTx.fee != null && $detailTx.feerate != null}


    function create_if_block_10$2(ctx) {
      let div3;
      let div0;
      let span0;
      let t1;
      let span1;
      let t2_value = numberFormat.format(
      /*$detailTx*/
      ctx[4].fee) + "";
      let t2;
      let t3;
      let t4;
      let span2;
      let t6;
      let div1;
      let span3;
      let t8;
      let span4;
      let t9_value = numberFormat.format(
      /*$detailTx*/
      ctx[4].vbytes) + "";
      let t9;
      let t10;
      let t11;
      let span5;
      let t13;
      let div2;
      let span6;
      let t15;
      let span7;
      let t16_value = numberFormat.format(
      /*$detailTx*/
      ctx[4].feerate.toFixed(2)) + "";
      let t16;
      let t17;
      const block = {
        c: function create() {
          div3 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "fee";
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = text(" sats");
          t4 = space();
          span2 = element("span");
          span2.textContent = "/";
          t6 = space();
          div1 = element("div");
          span3 = element("span");
          span3.textContent = "size";
          t8 = space();
          span4 = element("span");
          t9 = text(t9_value);
          t10 = text(" vbytes");
          t11 = space();
          span5 = element("span");
          span5.textContent = "=";
          t13 = space();
          div2 = element("div");
          span6 = element("span");
          span6.textContent = "fee rate";
          t15 = space();
          span7 = element("span");
          t16 = text(t16_value);
          t17 = text(" sats/vbyte");
          attr_dev(span0, "class", "label svelte-s7pekr");
          add_location(span0, file$e, 622, 14, 17478);
          attr_dev(span1, "class", "value svelte-s7pekr");
          set_style(span1, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span1, file$e, 623, 14, 17523);
          attr_dev(div0, "class", "field svelte-s7pekr");
          add_location(div0, file$e, 621, 12, 17444);
          attr_dev(span2, "class", "operator svelte-s7pekr");
          add_location(span2, file$e, 625, 12, 17652);
          attr_dev(span3, "class", "label svelte-s7pekr");
          add_location(span3, file$e, 627, 14, 17730);
          attr_dev(span4, "class", "value svelte-s7pekr");
          set_style(span4, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span4, file$e, 628, 14, 17776);
          attr_dev(div1, "class", "field svelte-s7pekr");
          add_location(div1, file$e, 626, 12, 17696);
          attr_dev(span5, "class", "operator svelte-s7pekr");
          add_location(span5, file$e, 630, 12, 17910);
          attr_dev(span6, "class", "label svelte-s7pekr");
          add_location(span6, file$e, 632, 14, 17988);
          attr_dev(span7, "class", "value svelte-s7pekr");
          set_style(span7, "color",
          /*feeColor*/
          ctx[9]);
          add_location(span7, file$e, 633, 14, 18038);
          attr_dev(div2, "class", "field svelte-s7pekr");
          add_location(div2, file$e, 631, 12, 17954);
          attr_dev(div3, "class", "pane fields svelte-s7pekr");
          add_location(div3, file$e, 620, 10, 17406);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div0, span0);
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          append_dev(span1, t3);
          append_dev(div3, t4);
          append_dev(div3, span2);
          append_dev(div3, t6);
          append_dev(div3, div1);
          append_dev(div1, span3);
          append_dev(div1, t8);
          append_dev(div1, span4);
          append_dev(span4, t9);
          append_dev(span4, t10);
          append_dev(div3, t11);
          append_dev(div3, span5);
          append_dev(div3, t13);
          append_dev(div3, div2);
          append_dev(div2, span6);
          append_dev(div2, t15);
          append_dev(div2, span7);
          append_dev(span7, t16);
          append_dev(span7, t17);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$detailTx*/
          16 && t2_value !== (t2_value = numberFormat.format(
          /*$detailTx*/
          ctx[4].fee) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span1, "color",
            /*feeColor*/
            ctx[9]);
          }

          if (dirty[0] &
          /*$detailTx*/
          16 && t9_value !== (t9_value = numberFormat.format(
          /*$detailTx*/
          ctx[4].vbytes) + "")) set_data_dev(t9, t9_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span4, "color",
            /*feeColor*/
            ctx[9]);
          }

          if (dirty[0] &
          /*$detailTx*/
          16 && t16_value !== (t16_value = numberFormat.format(
          /*$detailTx*/
          ctx[4].feerate.toFixed(2)) + "")) set_data_dev(t16, t16_value);

          if (dirty[0] &
          /*feeColor*/
          512) {
            set_style(span7, "color",
            /*feeColor*/
            ctx[9]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10$2.name,
        type: "if",
        source: "(620:8) {#if $detailTx.fee != null && $detailTx.feerate != null}",
        ctx
      });
      return block;
    } // (659:14) {#if input.prev_txid }


    function create_if_block_8$2(ctx) {
      let a;
      let svg;
      let path;
      let a_href_value;
      let a_transition;
      let current;
      let mounted;
      let dispose;

      function click_handler_1() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (
          /*click_handler_1*/
          ctx[26](
          /*input*/
          ctx[46], ...args)
        );
      }

      const block = {
        c: function create() {
          a = element("a");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-s7pekr");
          add_location(path, file$e, 661, 20, 19516);
          attr_dev(svg, "class", "raw-svg left");
          attr_dev(svg, "height", "1.2em");
          attr_dev(svg, "width", "1.2em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$e, 660, 18, 19418);
          attr_dev(a, "href", a_href_value = "/tx/" +
          /*input*/
          ctx[46].prev_txid + ":" +
          /*input*/
          ctx[46].prev_vout);
          attr_dev(a, "class", "put-link svelte-s7pekr");
          add_location(a, file$e, 659, 16, 19252);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, svg);
          append_dev(svg, path);
          current = true;

          if (!mounted) {
            dispose = listen_dev(a, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (!current || dirty[0] &
          /*inputs*/
          2 && a_href_value !== (a_href_value = "/tx/" +
          /*input*/
          ctx[46].prev_txid + ":" +
          /*input*/
          ctx[46].prev_vout)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          if (local) {
            add_render_callback(() => {
              if (!a_transition) a_transition = create_bidirectional_transition(a, fade, {
                duration: 200
              }, true);
              a_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          if (local) {
            if (!a_transition) a_transition = create_bidirectional_transition(a, fade, {
              duration: 200
            }, false);
            a_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          if (detaching && a_transition) a_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$2.name,
        type: "if",
        source: "(659:14) {#if input.prev_txid }",
        ctx
      });
      return block;
    } // (657:10) {#each inputs as input, index}


    function create_each_block_3(ctx) {
      let div;
      let t0;
      let p0;
      let span0;
      let t1_value =
      /*input*/
      ctx[46].address.slice(0, -6) + "";
      let t1;
      let span1;
      let t2_value =
      /*input*/
      ctx[46].address.slice(-6) + "";
      let t2;
      let p0_title_value;
      let t3;
      let p1;
      let t4_value = (
      /*input*/
      ctx[46].value == null ? '???' : formatBTC(
      /*input*/
      ctx[46].value)) + "";
      let t4;
      let t5;
      let mounted;
      let dispose;
      let if_block =
      /*input*/
      ctx[46].prev_txid && create_if_block_8$2(ctx);

      function click_handler_2() {
        return (
          /*click_handler_2*/
          ctx[27](
          /*input*/
          ctx[46])
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          if (if_block) if_block.c();
          t0 = space();
          p0 = element("p");
          span0 = element("span");
          t1 = text(t1_value);
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space();
          p1 = element("p");
          t4 = text(t4_value);
          t5 = space();
          attr_dev(span0, "class", "truncatable svelte-s7pekr");
          add_location(span0, file$e, 665, 70, 19770);
          attr_dev(span1, "class", "suffix svelte-s7pekr");
          add_location(span1, file$e, 665, 130, 19830);
          attr_dev(p0, "class", "address svelte-s7pekr");
          attr_dev(p0, "title", p0_title_value =
          /*input*/
          ctx[46].title ||
          /*input*/
          ctx[46].address);
          add_location(p0, file$e, 665, 14, 19714);
          attr_dev(p1, "class", "amount svelte-s7pekr");
          add_location(p1, file$e, 666, 14, 19902);
          attr_dev(div, "class", "entry svelte-s7pekr");
          toggle_class(div, "clickable",
          /*input*/
          ctx[46].rest);
          toggle_class(div, "highlight",
          /*highlight*/
          ctx[10].in != null &&
          /*highlight*/
          ctx[10].in ===
          /*index*/
          ctx[44]);
          add_location(div, file$e, 657, 12, 19051);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block) if_block.m(div, null);
          append_dev(div, t0);
          append_dev(div, p0);
          append_dev(p0, span0);
          append_dev(span0, t1);
          append_dev(p0, span1);
          append_dev(span1, t2);
          append_dev(div, t3);
          append_dev(div, p1);
          append_dev(p1, t4);
          append_dev(div, t5);

          if (!mounted) {
            dispose = listen_dev(div, "click", click_handler_2, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (
          /*input*/
          ctx[46].prev_txid) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*inputs*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_8$2(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty[0] &
          /*inputs*/
          2 && t1_value !== (t1_value =
          /*input*/
          ctx[46].address.slice(0, -6) + "")) set_data_dev(t1, t1_value);
          if (dirty[0] &
          /*inputs*/
          2 && t2_value !== (t2_value =
          /*input*/
          ctx[46].address.slice(-6) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*inputs*/
          2 && p0_title_value !== (p0_title_value =
          /*input*/
          ctx[46].title ||
          /*input*/
          ctx[46].address)) {
            attr_dev(p0, "title", p0_title_value);
          }

          if (dirty[0] &
          /*inputs*/
          2 && t4_value !== (t4_value = (
          /*input*/
          ctx[46].value == null ? '???' : formatBTC(
          /*input*/
          ctx[46].value)) + "")) set_data_dev(t4, t4_value);

          if (dirty[0] &
          /*inputs*/
          2) {
            toggle_class(div, "clickable",
            /*input*/
            ctx[46].rest);
          }

          if (dirty[0] &
          /*highlight*/
          1024) {
            toggle_class(div, "highlight",
            /*highlight*/
            ctx[10].in != null &&
            /*highlight*/
            ctx[10].in ===
            /*index*/
            ctx[44]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_3.name,
        type: "each",
        source: "(657:10) {#each inputs as input, index}",
        ctx
      });
      return block;
    } // (672:10) {#if sankeyLines && $pageWidth > 410}


    function create_if_block_5$2(ctx) {
      let svg;
      let defs;
      let svg_height_value;
      let svg_width_value;
      let each_value_2 =
      /*sankeyLines*/
      ctx[11];
      validate_each_argument(each_value_2);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }

      let each_value_1 =
      /*sankeyLines*/
      ctx[11];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          svg = svg_element("svg");
          defs = svg_element("defs");

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(defs, file$e, 673, 14, 20212);
          attr_dev(svg, "class", "sankey svelte-s7pekr");
          attr_dev(svg, "height", svg_height_value = "" + (
          /*sankeyHeight*/
          ctx[3] + "px"));
          attr_dev(svg, "width", svg_width_value = "" + (
          /*svgWidth*/
          ctx[0] + "px"));
          add_location(svg, file$e, 672, 12, 20130);
        },
        m: function mount(target, anchor) {
          insert_dev(target, svg, anchor);
          append_dev(svg, defs);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(defs, null);
          }

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(svg, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*midColor, sankeyLines*/
          133120) {
            each_value_2 =
            /*sankeyLines*/
            ctx[11];
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2(ctx, each_value_2, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
              } else {
                each_blocks_1[i] = create_each_block_2(child_ctx);
                each_blocks_1[i].c();
                each_blocks_1[i].m(defs, null);
              }
            }

            for (; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d(1);
            }

            each_blocks_1.length = each_value_2.length;
          }

          if (dirty[0] &
          /*sankeyLines, triangleWidth, svgWidth*/
          2177) {
            each_value_1 =
            /*sankeyLines*/
            ctx[11];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(svg, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }

          if (dirty[0] &
          /*sankeyHeight*/
          8 && svg_height_value !== (svg_height_value = "" + (
          /*sankeyHeight*/
          ctx[3] + "px"))) {
            attr_dev(svg, "height", svg_height_value);
          }

          if (dirty[0] &
          /*svgWidth*/
          1 && svg_width_value !== (svg_width_value = "" + (
          /*svgWidth*/
          ctx[0] + "px"))) {
            attr_dev(svg, "width", svg_width_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(svg);
          destroy_each(each_blocks_1, detaching);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$2.name,
        type: "if",
        source: "(672:10) {#if sankeyLines && $pageWidth > 410}",
        ctx
      });
      return block;
    } // (680:20) {:else}


    function create_else_block_1$2(ctx) {
      let stop0;
      let stop1;
      let stop1_stop_color_value;
      const block = {
        c: function create() {
          stop0 = svg_element("stop");
          stop1 = svg_element("stop");
          attr_dev(stop0, "offset", "0%");
          attr_dev(stop0, "stop-color",
          /*midColor*/
          ctx[17]);
          add_location(stop0, file$e, 680, 22, 20634);
          attr_dev(stop1, "offset", "100%");
          attr_dev(stop1, "stop-color", stop1_stop_color_value = hlToHex(mixColor(purple, teal, 0, Math.max(1,
          /*line*/
          ctx[42].total - 1),
          /*line*/
          ctx[42].index)));
          add_location(stop1, file$e, 681, 22, 20698);
        },
        m: function mount(target, anchor) {
          insert_dev(target, stop0, anchor);
          insert_dev(target, stop1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*sankeyLines*/
          2048 && stop1_stop_color_value !== (stop1_stop_color_value = hlToHex(mixColor(purple, teal, 0, Math.max(1,
          /*line*/
          ctx[42].total - 1),
          /*line*/
          ctx[42].index)))) {
            attr_dev(stop1, "stop-color", stop1_stop_color_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(stop0);
          if (detaching) detach_dev(stop1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$2.name,
        type: "else",
        source: "(680:20) {:else}",
        ctx
      });
      return block;
    } // (677:20) {#if line.in}


    function create_if_block_7$2(ctx) {
      let stop0;
      let stop0_stop_color_value;
      let stop1;
      const block = {
        c: function create() {
          stop0 = svg_element("stop");
          stop1 = svg_element("stop");
          attr_dev(stop0, "offset", "0%");
          attr_dev(stop0, "stop-color", stop0_stop_color_value = hlToHex(mixColor(teal, purple, 0, Math.max(1,
          /*line*/
          ctx[42].total - 1),
          /*line*/
          ctx[42].index)));
          add_location(stop0, file$e, 677, 22, 20410);
          attr_dev(stop1, "offset", "100%");
          attr_dev(stop1, "stop-color",
          /*midColor*/
          ctx[17]);
          add_location(stop1, file$e, 678, 22, 20540);
        },
        m: function mount(target, anchor) {
          insert_dev(target, stop0, anchor);
          insert_dev(target, stop1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*sankeyLines*/
          2048 && stop0_stop_color_value !== (stop0_stop_color_value = hlToHex(mixColor(teal, purple, 0, Math.max(1,
          /*line*/
          ctx[42].total - 1),
          /*line*/
          ctx[42].index)))) {
            attr_dev(stop0, "stop-color", stop0_stop_color_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(stop0);
          if (detaching) detach_dev(stop1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$2.name,
        type: "if",
        source: "(677:20) {#if line.in}",
        ctx
      });
      return block;
    } // (675:16) {#each sankeyLines as line, index}


    function create_each_block_2(ctx) {
      let linearGradient;

      function select_block_type_4(ctx, dirty) {
        if (
        /*line*/
        ctx[42].in) return create_if_block_7$2;
        return create_else_block_1$2;
      }

      let current_block_type = select_block_type_4(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          linearGradient = svg_element("linearGradient");
          if_block.c();
          attr_dev(linearGradient, "id", "lg" +
          /*index*/
          ctx[44]);
          attr_dev(linearGradient, "x1", "0%");
          attr_dev(linearGradient, "y1", "0%");
          attr_dev(linearGradient, "x2", "100%");
          attr_dev(linearGradient, "y2", "0%");
          add_location(linearGradient, file$e, 675, 18, 20288);
        },
        m: function mount(target, anchor) {
          insert_dev(target, linearGradient, anchor);
          if_block.m(linearGradient, null);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(linearGradient, null);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(linearGradient);
          if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(675:16) {#each sankeyLines as line, index}",
        ctx
      });
      return block;
    } // (691:16) {:else}


    function create_else_block$6(ctx) {
      let polyline;
      let polyline_points_value;
      const block = {
        c: function create() {
          polyline = svg_element("polyline");
          attr_dev(polyline, "points", polyline_points_value = "" + (
          /*svgWidth*/
          ctx[0] + "," +
          /*line*/
          ctx[42].index * 60 + " " + (
          /*svgWidth*/
          ctx[0] -
          /*triangleWidth*/
          ctx[7]) + "," + (
          /*line*/
          ctx[42].index * 60 + 30) + " " +
          /*svgWidth*/
          ctx[0] + "," + (
          /*line*/
          ctx[42].index * 60 + 60)));
          attr_dev(polyline, "stroke", "var(--grey)");
          set_style(polyline, "stroke-width", "1px");
          attr_dev(polyline, "class", "svelte-s7pekr");
          add_location(polyline, file$e, 691, 18, 21334);
        },
        m: function mount(target, anchor) {
          insert_dev(target, polyline, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*svgWidth, sankeyLines, triangleWidth*/
          2177 && polyline_points_value !== (polyline_points_value = "" + (
          /*svgWidth*/
          ctx[0] + "," +
          /*line*/
          ctx[42].index * 60 + " " + (
          /*svgWidth*/
          ctx[0] -
          /*triangleWidth*/
          ctx[7]) + "," + (
          /*line*/
          ctx[42].index * 60 + 30) + " " +
          /*svgWidth*/
          ctx[0] + "," + (
          /*line*/
          ctx[42].index * 60 + 60)))) {
            attr_dev(polyline, "points", polyline_points_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(polyline);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$6.name,
        type: "else",
        source: "(691:16) {:else}",
        ctx
      });
      return block;
    } // (689:16) {#if line.in}


    function create_if_block_6$2(ctx) {
      let polyline;
      let polyline_points_value;
      const block = {
        c: function create() {
          polyline = svg_element("polyline");
          attr_dev(polyline, "points", polyline_points_value = "0," +
          /*line*/
          ctx[42].index * 60 + " " +
          /*triangleWidth*/
          ctx[7] + "," + (
          /*line*/
          ctx[42].index * 60 + 30) + " 0," + (
          /*line*/
          ctx[42].index * 60 + 60));
          attr_dev(polyline, "stroke", "var(--grey)");
          set_style(polyline, "stroke-width", "1px");
          attr_dev(polyline, "class", "svelte-s7pekr");
          add_location(polyline, file$e, 689, 18, 21134);
        },
        m: function mount(target, anchor) {
          insert_dev(target, polyline, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*sankeyLines, triangleWidth*/
          2176 && polyline_points_value !== (polyline_points_value = "0," +
          /*line*/
          ctx[42].index * 60 + " " +
          /*triangleWidth*/
          ctx[7] + "," + (
          /*line*/
          ctx[42].index * 60 + 30) + " 0," + (
          /*line*/
          ctx[42].index * 60 + 60))) {
            attr_dev(polyline, "points", polyline_points_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(polyline);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$2.name,
        type: "if",
        source: "(689:16) {#if line.in}",
        ctx
      });
      return block;
    } // (687:14) {#each sankeyLines as line, index }


    function create_each_block_1$2(ctx) {
      let polyline;
      let polyline_points_value;
      let if_block_anchor;

      function select_block_type_5(ctx, dirty) {
        if (
        /*line*/
        ctx[42].in) return create_if_block_6$2;
        return create_else_block$6;
      }

      let current_block_type = select_block_type_5(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          polyline = svg_element("polyline");
          if_block.c();
          if_block_anchor = empty();
          attr_dev(polyline, "points", polyline_points_value =
          /*line*/
          ctx[42].points);
          attr_dev(polyline, "stroke", "url(#lg" +
          /*index*/
          ctx[44] + ")");
          set_style(polyline, "stroke-width",
          /*line*/
          ctx[42].weight + 1 + "px");
          attr_dev(polyline, "class", "svelte-s7pekr");
          add_location(polyline, file$e, 687, 16, 20982);
        },
        m: function mount(target, anchor) {
          insert_dev(target, polyline, anchor);
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*sankeyLines*/
          2048 && polyline_points_value !== (polyline_points_value =
          /*line*/
          ctx[42].points)) {
            attr_dev(polyline, "points", polyline_points_value);
          }

          if (dirty[0] &
          /*sankeyLines*/
          2048) {
            set_style(polyline, "stroke-width",
            /*line*/
            ctx[42].weight + 1 + "px");
          }

          if (current_block_type === (current_block_type = select_block_type_5(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(polyline);
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$2.name,
        type: "each",
        source: "(687:14) {#each sankeyLines as line, index }",
        ctx
      });
      return block;
    } // (699:103) {#if $detailTx.fee}


    function create_if_block_4$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("+ fee");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$2.name,
        type: "if",
        source: "(699:103) {#if $detailTx.fee}",
        ctx
      });
      return block;
    } // (714:67) 


    function create_if_block_3$2(ctx) {
      let a;
      let svg;
      let path;
      let a_href_value;
      let a_intro;
      let mounted;
      let dispose;

      function click_handler_3() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return (
          /*click_handler_3*/
          ctx[28](
          /*output*/
          ctx[39], ...args)
        );
      }

      const block = {
        c: function create() {
          a = element("a");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-s7pekr");
          add_location(path, file$e, 716, 20, 23233);
          attr_dev(svg, "class", "raw-svg right svelte-s7pekr");
          attr_dev(svg, "height", "1.2em");
          attr_dev(svg, "width", "1.2em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$e, 715, 18, 23134);
          attr_dev(a, "href", a_href_value = "/tx/" +
          /*spends*/
          ctx[12][
          /*output*/
          ctx[39].index].vin + ":" +
          /*spends*/
          ctx[12][
          /*output*/
          ctx[39].index].txid);
          attr_dev(a, "title", "spent");
          attr_dev(a, "class", "put-link svelte-s7pekr");
          add_location(a, file$e, 714, 16, 22928);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, svg);
          append_dev(svg, path);

          if (!mounted) {
            dispose = listen_dev(a, "click", click_handler_3, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (dirty[0] &
          /*spends, outputs*/
          4100 && a_href_value !== (a_href_value = "/tx/" +
          /*spends*/
          ctx[12][
          /*output*/
          ctx[39].index].vin + ":" +
          /*spends*/
          ctx[12][
          /*output*/
          ctx[39].index].txid)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (local) {
            if (!a_intro) {
              add_render_callback(() => {
                a_intro = create_in_transition(a, fade, {
                  duration: 200
                });
                a_intro.start();
              });
            }
          }
        },
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$2.name,
        type: "if",
        source: "(714:67) ",
        ctx
      });
      return block;
    } // (708:75) 


    function create_if_block_2$3(ctx) {
      let span;
      let svg;
      let path;
      let span_intro;
      const block = {
        c: function create() {
          span = element("span");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-s7pekr");
          add_location(path, file$e, 710, 18, 22681);
          attr_dev(svg, "class", "raw-svg right svelte-s7pekr");
          attr_dev(svg, "height", "1.2em");
          attr_dev(svg, "width", "1.2em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$e, 709, 16, 22584);
          attr_dev(span, "class", "put-link disabled svelte-s7pekr");
          attr_dev(span, "title", "spent");
          add_location(span, file$e, 708, 14, 22487);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, svg);
          append_dev(svg, path);
        },
        p: noop,
        i: function intro(local) {
          if (local) {
            if (!span_intro) {
              add_render_callback(() => {
                span_intro = create_in_transition(span, fade, {
                  duration: 200
                });
                span_intro.start();
              });
            }
          }
        },
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$3.name,
        type: "if",
        source: "(708:75) ",
        ctx
      });
      return block;
    } // (702:14) {#if loadingSpends}


    function create_if_block_1$4(ctx) {
      let span;
      let svg;
      let path;
      let span_outro;
      let current;
      const block = {
        c: function create() {
          span = element("span");
          svg = svg_element("svg");
          path = svg_element("path");
          attr_dev(path, "d", "M 107.628,257.54 327.095,38.078 404,114.989 261.506,257.483 404,399.978 327.086,476.89 Z");
          attr_dev(path, "class", "outline svelte-s7pekr");
          add_location(path, file$e, 704, 20, 22230);
          attr_dev(svg, "class", "raw-svg right svelte-s7pekr");
          attr_dev(svg, "height", "1.2em");
          attr_dev(svg, "width", "1.2em");
          attr_dev(svg, "viewBox", "0 0 512 512");
          add_location(svg, file$e, 703, 18, 22131);
          attr_dev(span, "class", "put-link loading svelte-s7pekr");
          add_location(span, file$e, 702, 16, 22046);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, svg);
          append_dev(svg, path);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          if (span_outro) span_outro.end(1);
          current = true;
        },
        o: function outro(local) {
          if (local) {
            span_outro = create_out_transition(span, fade, {
              duration: 500
            });
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching && span_outro) span_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$4.name,
        type: "if",
        source: "(702:14) {#if loadingSpends}",
        ctx
      });
      return block;
    } // (700:10) {#each outputs as output}


    function create_each_block$5(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let t0;
      let p0;
      let span0;
      let t1_value =
      /*output*/
      ctx[39].address.slice(0, -6) + "";
      let t1;
      let span1;
      let t2_value =
      /*output*/
      ctx[39].address.slice(-6) + "";
      let t2;
      let p0_title_value;
      let t3;
      let p1;
      let t4_value = (
      /*output*/
      ctx[39].value == null ? '???' : formatBTC(
      /*output*/
      ctx[39].value)) + "";
      let t4;
      let t5;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block_1$4, create_if_block_2$3, create_if_block_3$2];
      const if_blocks = [];

      function select_block_type_6(ctx, dirty) {
        if (
        /*loadingSpends*/
        ctx[13]) return 0;
        if (!
        /*output*/
        ctx[39].opreturn &&
        /*spends*/
        ctx[12][
        /*output*/
        ctx[39].index] == true) return 1;
        if (!
        /*output*/
        ctx[39].opreturn &&
        /*spends*/
        ctx[12][
        /*output*/
        ctx[39].index]) return 2;
        return -1;
      }

      if (~(current_block_type_index = select_block_type_6(ctx))) {
        if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      }

      function click_handler_4() {
        return (
          /*click_handler_4*/
          ctx[29](
          /*output*/
          ctx[39])
        );
      }

      const block = {
        c: function create() {
          div = element("div");
          if (if_block) if_block.c();
          t0 = space();
          p0 = element("p");
          span0 = element("span");
          t1 = text(t1_value);
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space();
          p1 = element("p");
          t4 = text(t4_value);
          t5 = space();
          attr_dev(span0, "class", "truncatable svelte-s7pekr");
          add_location(span0, file$e, 720, 72, 23489);
          attr_dev(span1, "class", "suffix svelte-s7pekr");
          add_location(span1, file$e, 720, 133, 23550);
          attr_dev(p0, "class", "address svelte-s7pekr");
          attr_dev(p0, "title", p0_title_value =
          /*output*/
          ctx[39].title ||
          /*output*/
          ctx[39].address);
          add_location(p0, file$e, 720, 14, 23431);
          attr_dev(p1, "class", "amount svelte-s7pekr");
          add_location(p1, file$e, 721, 14, 23623);
          attr_dev(div, "class", "entry svelte-s7pekr");
          toggle_class(div, "clickable",
          /*output*/
          ctx[39].rest);
          toggle_class(div, "highlight",
          /*highlight*/
          ctx[10].out != null &&
          /*highlight*/
          ctx[10].out ===
          /*output*/
          ctx[39].index);
          add_location(div, file$e, 700, 12, 21837);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (~current_block_type_index) {
            if_blocks[current_block_type_index].m(div, null);
          }

          append_dev(div, t0);
          append_dev(div, p0);
          append_dev(p0, span0);
          append_dev(span0, t1);
          append_dev(p0, span1);
          append_dev(span1, t2);
          append_dev(div, t3);
          append_dev(div, p1);
          append_dev(p1, t4);
          append_dev(div, t5);

          if (!mounted) {
            dispose = listen_dev(div, "click", click_handler_4, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_6(ctx);

          if (current_block_type_index === previous_block_index) {
            if (~current_block_type_index) {
              if_blocks[current_block_type_index].p(ctx, dirty);
            }
          } else {
            if (if_block) {
              group_outros();
              transition_out(if_blocks[previous_block_index], 1, 1, () => {
                if_blocks[previous_block_index] = null;
              });
              check_outros();
            }

            if (~current_block_type_index) {
              if_block = if_blocks[current_block_type_index];

              if (!if_block) {
                if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
                if_block.c();
              } else {
                if_block.p(ctx, dirty);
              }

              transition_in(if_block, 1);
              if_block.m(div, t0);
            } else {
              if_block = null;
            }
          }

          if (dirty[0] &
          /*outputs*/
          4 && t1_value !== (t1_value =
          /*output*/
          ctx[39].address.slice(0, -6) + "")) set_data_dev(t1, t1_value);
          if (dirty[0] &
          /*outputs*/
          4 && t2_value !== (t2_value =
          /*output*/
          ctx[39].address.slice(-6) + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*outputs*/
          4 && p0_title_value !== (p0_title_value =
          /*output*/
          ctx[39].title ||
          /*output*/
          ctx[39].address)) {
            attr_dev(p0, "title", p0_title_value);
          }

          if (dirty[0] &
          /*outputs*/
          4 && t4_value !== (t4_value = (
          /*output*/
          ctx[39].value == null ? '???' : formatBTC(
          /*output*/
          ctx[39].value)) + "")) set_data_dev(t4, t4_value);

          if (dirty[0] &
          /*outputs*/
          4) {
            toggle_class(div, "clickable",
            /*output*/
            ctx[39].rest);
          }

          if (dirty[0] &
          /*highlight, outputs*/
          1028) {
            toggle_class(div, "highlight",
            /*highlight*/
            ctx[10].out != null &&
            /*highlight*/
            ctx[10].out ===
            /*output*/
            ctx[39].index);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          if (~current_block_type_index) {
            if_blocks[current_block_type_index].d();
          }

          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$5.name,
        type: "each",
        source: "(700:10) {#each outputs as output}",
        ctx
      });
      return block;
    } // (566:0) <Overlay name="tx" on:close={onClose}>


    function create_default_slot$3(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*$detailTx*/
      ctx[4] && create_if_block$9(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*$detailTx*/
          ctx[4]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*$detailTx*/
              16) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$9(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$3.name,
        type: "slot",
        source: "(566:0) <Overlay name=\\\"tx\\\" on:close={onClose}>",
        ctx
      });
      return block;
    }

    function create_fragment$e(ctx) {
      let overlay_1;
      let current;
      overlay_1 = new Overlay({
        props: {
          name: "tx",
          $$slots: {
            default: [create_default_slot$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      overlay_1.$on("close",
      /*onClose*/
      ctx[15]);
      const block = {
        c: function create() {
          create_component(overlay_1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(overlay_1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const overlay_1_changes = {};

          if (dirty[0] &
          /*svgWidth, outputs, highlight, loadingSpends, spends, $detailTx, sankeyHeight, sankeyLines, triangleWidth, $pageWidth, inputs, feeColor, confirmations, $latestBlockHeight, $highlightingFull*/
          32767 | dirty[1] &
          /*$$scope*/
          131072) {
            overlay_1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          overlay_1.$set(overlay_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(overlay_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(overlay_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(overlay_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const rowHeight = 60;

    function formatBTC(sats) {
      return `₿ ${(sats / 100000000).toFixed(8)}`;
    } // given a line weight and corner angle
    // return the horizontal distance of a miter from the corner


    function getMiterOffset(weight, dy, dx) {
      if (dy != 0) {
        const angle = Math.atan2(dy, dx);
        const u = weight / 2;
        const a = 0;
        const b = dy / dx;
        const c = -u;
        const d = -u * (Math.cos(angle) + b * Math.sin(angle));
        return (d - c) / (a - b);
      } else return 0;
    }

    function instance$e($$self, $$props, $$invalidate) {
      let $detailTx;
      let $overlay;
      let $explorerBlock;
      let $latestBlockHeight;
      let $currentBlock;
      let $highlightInOut;
      let $pageWidth;
      let $sidebarToggle;
      let $newHighlightQuery;
      let $highlightingFull;
      let $urlPath;
      validate_store(detailTx, 'detailTx');
      component_subscribe($$self, detailTx, $$value => $$invalidate(4, $detailTx = $$value));
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(30, $overlay = $$value));
      validate_store(explorerBlock, 'explorerBlock');
      component_subscribe($$self, explorerBlock, $$value => $$invalidate(31, $explorerBlock = $$value));
      validate_store(latestBlockHeight, 'latestBlockHeight');
      component_subscribe($$self, latestBlockHeight, $$value => $$invalidate(5, $latestBlockHeight = $$value));
      validate_store(currentBlock, 'currentBlock');
      component_subscribe($$self, currentBlock, $$value => $$invalidate(32, $currentBlock = $$value));
      validate_store(highlightInOut, 'highlightInOut');
      component_subscribe($$self, highlightInOut, $$value => $$invalidate(24, $highlightInOut = $$value));
      validate_store(pageWidth, 'pageWidth');
      component_subscribe($$self, pageWidth, $$value => $$invalidate(6, $pageWidth = $$value));
      validate_store(sidebarToggle, 'sidebarToggle');
      component_subscribe($$self, sidebarToggle, $$value => $$invalidate(33, $sidebarToggle = $$value));
      validate_store(newHighlightQuery, 'newHighlightQuery');
      component_subscribe($$self, newHighlightQuery, $$value => $$invalidate(34, $newHighlightQuery = $$value));
      validate_store(highlightingFull, 'highlightingFull');
      component_subscribe($$self, highlightingFull, $$value => $$invalidate(14, $highlightingFull = $$value));
      validate_store(urlPath, 'urlPath');
      component_subscribe($$self, urlPath, $$value => $$invalidate(35, $urlPath = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('TransactionOverlay', slots, []);

      function onClose() {
        set_store_value(detailTx, $detailTx = null, $detailTx);
        set_store_value(highlightInOut, $highlightInOut = null, $highlightInOut);
        set_store_value(urlPath, $urlPath = "/", $urlPath);
      }

      function addToWatchlist(query) {
        if (!$highlightingFull && query) {
          set_store_value(newHighlightQuery, $newHighlightQuery = query, $newHighlightQuery);
          set_store_value(sidebarToggle, $sidebarToggle = 'search', $sidebarToggle);
        }
      }

      let svgWidth = 380;
      let flowWeight = 60;
      let triangleWidth = 20;
      let confirmations = 0;
      const midColor = hlToHex(mixColor(teal, purple, 1, 3, 2));
      let feeColor;

      function expandAddresses(items, truncate) {
        let truncated = truncate ? items.slice(0, 100) : items;
        const expanded = truncated.map((item, index) => {
          let address = 'unknown';
          let title = null;

          if (item.script_pub_key) {
            address = SPKToAddress(item.script_pub_key) || "unknown";

            if (address === 'OP_RETURN') {
              title = item.script_pub_key.substring(4).match(/../g).reduce((parsed, hexChar) => {
                return parsed + String.fromCharCode(parseInt(hexChar, 16));
              }, "");
            } else if (address === 'P2PK') {
              if (item.script_pub_key.length === 70) title = 'compressed pubkey: ' + item.script_pub_key.substring(2, 68);else title = 'pubkey: ' + item.script_pub_key.substring(2, 132);
            }
          }

          return { ...item,
            address,
            title,
            index,
            opreturn: address === 'OP_RETURN'
          };
        });

        if (truncate && items.length > 100) {
          const remainingCount = items.length - 100;
          const remainingValue = items.slice(100).reduce((acc, item) => {
            return acc + (item.value || 0);
          }, 0);
          expanded.push({
            address: `+ ${remainingCount} more`,
            value: remainingValue,
            rest: true
          });
        }

        return expanded;
      }

      let truncate = true;
      let inputs = [];
      let outputs = [];
      let highlight = {};
      let sankeyLines;
      let sankeyHeight;
      let spends;
      let loadingSpends = false;

      async function loadSpends(txid) {
        let reload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!reload) $$invalidate(13, loadingSpends = true);
        $$invalidate(12, spends = await fetchSpends(txid));
        $$invalidate(13, loadingSpends = false);
      }

      function calcSankeyLines(inputs, outputs, fee, value, totalHeight, svgWidth, flowWeight) {
        const total = fee + value;
        const mergeOffset = (totalHeight - flowWeight) / 2;
        let cumThick = 0;
        let xOffset = 0;
        let maxXOffset = 0;
        const inLines = inputs.map((input, index) => {
          const weight = (input.value || 0) / total * flowWeight;
          const height = (index + 0.5) * rowHeight;
          const step = weight / 2;
          const line = [];
          const yOffset = 0.5;
          line.push({
            x: triangleWidth,
            y: height
          });
          line.push({
            x: triangleWidth + 0.25 * svgWidth,
            y: height
          });
          line.push({
            x: 0.425 * svgWidth,
            y: mergeOffset + cumThick + step + yOffset
          });
          line.push({
            x: 0.5 * svgWidth + 1,
            y: mergeOffset + cumThick + step + yOffset
          });
          const dy = line[1].y - line[2].y;
          const dx = line[2].x - line[1].x;
          const miterOffset = getMiterOffset(weight, dy, dx);
          xOffset += miterOffset;
          line[1].x += xOffset;
          line[2].x += xOffset;
          xOffset += miterOffset;
          maxXOffset = Math.max(xOffset, maxXOffset); // inLines.push({ line, weight })
          // inLines.push({ line: [{x: line[1].x + miterOffset, y: line[1].y - (weight / 2)}, {x: line[2].x + miterOffset, y: line[2].y - (weight / 2)}], weight: 1})

          cumThick += weight;
          return {
            line,
            weight,
            index,
            total: inputs.length,
            in: true
          };
        });
        inLines.forEach(line => {
          if (line.line.length) {
            line.line[1].x -= maxXOffset;
            line.line[2].x -= maxXOffset;
          }
        });
        cumThick = 0;
        xOffset = 0;
        maxXOffset = 0;
        const outLines = outputs.map((output, index) => {
          const weight = output.value / total * flowWeight;
          const height = (index + 0.5) * rowHeight;
          const step = weight / 2;
          const line = [];
          const yOffset = 0.5;
          line.push({
            x: 0.5 * svgWidth - 1,
            y: mergeOffset + cumThick + step + yOffset
          });
          line.push({
            x: 0.575 * svgWidth,
            y: mergeOffset + cumThick + step + yOffset
          });
          line.push({
            x: svgWidth - triangleWidth - 0.25 * svgWidth,
            y: height
          });
          line.push({
            x: svgWidth - triangleWidth,
            y: height
          });
          const dy = line[2].y - line[1].y;
          const dx = line[2].x - line[1].x;
          const miterOffset = getMiterOffset(weight, dy, dx);
          xOffset += miterOffset;
          line[1].x -= xOffset;
          line[2].x -= xOffset;
          xOffset += miterOffset;
          maxXOffset = Math.max(xOffset, maxXOffset); // outLines.push({ line, weight })
          // outLines.push({ line: [{x: line[1].x + miterOffset, y: line[1].y - (weight / 2)}, {x: line[2].x + miterOffset, y: line[2].y - (weight / 2)}], weight: 1})

          cumThick += weight;
          return {
            line,
            weight,
            index,
            total: outputs.length
          };
        });
        outLines.forEach(line => {
          line.line[1].x += maxXOffset;
          line.line[2].x += maxXOffset;
        });
        return [...inLines, ...outLines].map(line => {
          return {
            points: line.line.map(point => {
              return `${point.x},${point.y}`;
            }).join(' '),
            weight: line.weight,
            index: line.index,
            total: line.total,
            in: line.in
          };
        });
      }

      async function clickItem(item) {
        if (item.rest) {
          $$invalidate(23, truncate = false);
        }
      }

      async function goToInput(e, input) {
        e.preventDefault();
        loading.increment();
        await searchTx(input.prev_txid, null, input.prev_vout);
        loading.decrement();
      }

      async function goToSpend(e, spend) {
        e.preventDefault();
        loading.increment();
        await searchTx(spend.txid, spend.vin);
        loading.decrement();
      }

      async function goToBlock(e) {
        e.preventDefault(); // ignore click if it was triggered while selecting text, or if we don't have a block to go to

        if (!$detailTx || !$detailTx.block || !!window.getSelection().toString()) return;
        let hash = $detailTx.block.hash || $detailTx.block.id;
        let height = $detailTx.block.height;

        if (hash === $currentBlock.id) {
          onClose();
          set_store_value(overlay, $overlay = null, $overlay);
        } else if (height == $latestBlockHeight) {
          onClose();
          set_store_value(explorerBlock, $explorerBlock = null, $explorerBlock);
          set_store_value(overlay, $overlay = null, $overlay);
        } else if (hash) {
          loading.increment();
          await searchBlockHash($detailTx.block.hash || $detailTx.block.id);
          loading.decrement();
        }
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TransactionOverlay> was created with unknown prop '${key}'`);
      });

      const click_handler = () => addToWatchlist($detailTx.id);

      const click_handler_1 = (input, e) => goToInput(e, input);

      const click_handler_2 = input => clickItem(input);

      const click_handler_3 = (output, e) => goToSpend(e, spends[output.index]);

      const click_handler_4 = output => clickItem(output);

      $$self.$capture_state = () => ({
        Overlay,
        Icon,
        BookmarkIcon,
        longBtcFormat,
        numberFormat,
        feeRateFormat,
        dateFormat,
        exchangeRates,
        settings,
        sidebarToggle,
        newHighlightQuery,
        highlightingFull,
        detailTx,
        pageWidth,
        latestBlockHeight,
        highlightInOut,
        loading,
        urlPath,
        currentBlock,
        overlay,
        explorerBlock,
        formatCurrency,
        hlToHex,
        mixColor,
        teal,
        purple,
        SPKToAddress,
        api,
        searchTx,
        searchBlockHash,
        searchBlockHeight,
        fetchSpends,
        fade,
        onClose,
        formatBTC,
        addToWatchlist,
        rowHeight,
        svgWidth,
        flowWeight,
        triangleWidth,
        confirmations,
        midColor,
        feeColor,
        expandAddresses,
        truncate,
        inputs,
        outputs,
        highlight,
        sankeyLines,
        sankeyHeight,
        spends,
        loadingSpends,
        loadSpends,
        calcSankeyLines,
        getMiterOffset,
        clickItem,
        goToInput,
        goToSpend,
        goToBlock,
        $detailTx,
        $overlay,
        $explorerBlock,
        $latestBlockHeight,
        $currentBlock,
        $highlightInOut,
        $pageWidth,
        $sidebarToggle,
        $newHighlightQuery,
        $highlightingFull,
        $urlPath
      });

      $$self.$inject_state = $$props => {
        if ('svgWidth' in $$props) $$invalidate(0, svgWidth = $$props.svgWidth);
        if ('flowWeight' in $$props) $$invalidate(22, flowWeight = $$props.flowWeight);
        if ('triangleWidth' in $$props) $$invalidate(7, triangleWidth = $$props.triangleWidth);
        if ('confirmations' in $$props) $$invalidate(8, confirmations = $$props.confirmations);
        if ('feeColor' in $$props) $$invalidate(9, feeColor = $$props.feeColor);
        if ('truncate' in $$props) $$invalidate(23, truncate = $$props.truncate);
        if ('inputs' in $$props) $$invalidate(1, inputs = $$props.inputs);
        if ('outputs' in $$props) $$invalidate(2, outputs = $$props.outputs);
        if ('highlight' in $$props) $$invalidate(10, highlight = $$props.highlight);
        if ('sankeyLines' in $$props) $$invalidate(11, sankeyLines = $$props.sankeyLines);
        if ('sankeyHeight' in $$props) $$invalidate(3, sankeyHeight = $$props.sankeyHeight);
        if ('spends' in $$props) $$invalidate(12, spends = $$props.spends);
        if ('loadingSpends' in $$props) $$invalidate(13, loadingSpends = $$props.loadingSpends);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*$pageWidth, svgWidth*/
        65) {
          {
            if ($pageWidth) {
              if ($pageWidth < 800) {
                $$invalidate(0, svgWidth = Math.max($pageWidth - 420, 120));
                $$invalidate(22, flowWeight = 0.1875 * (svgWidth - 60));
              } else {
                $$invalidate(0, svgWidth = 380);
                $$invalidate(22, flowWeight = 60);
              }

              if ($pageWidth < 600) {
                $$invalidate(7, triangleWidth = 10);
              } else {
                $$invalidate(7, triangleWidth = 20);
              }
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx, $latestBlockHeight*/
        48) {
          {
            if ($detailTx && $detailTx.block && $detailTx.block.height != null && $latestBlockHeight != null) {
              $$invalidate(8, confirmations = 1 + $latestBlockHeight - $detailTx.block.height);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx*/
        16) {
          {
            if ($detailTx && $detailTx.feerate != null) {
              $$invalidate(9, feeColor = hlToHex(mixColor(teal, purple, 1, Math.log2(64), Math.log2($detailTx.feerate))));
            } else {
              $$invalidate(9, feeColor = null);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx*/
        16) {
          {
            if ($detailTx && $detailTx.id) $$invalidate(23, truncate = true);
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx, truncate*/
        8388624) {
          {
            if ($detailTx && $detailTx.inputs) {
              if ($detailTx.isCoinbase) {
                $$invalidate(1, inputs = [{
                  address: 'coinbase',
                  value: $detailTx.value
                }]);
              } else {
                $$invalidate(1, inputs = expandAddresses($detailTx.inputs, truncate));
              }
            } else $$invalidate(1, inputs = []);

            if ($detailTx && $detailTx.outputs) {
              if ($detailTx.isCoinbase || $detailTx.fee == null) {
                $$invalidate(2, outputs = expandAddresses($detailTx.outputs, truncate));
              } else {
                $$invalidate(2, outputs = [{
                  address: 'fee',
                  value: $detailTx.fee,
                  fee: true
                }, ...expandAddresses($detailTx.outputs, truncate)]);
              }
            } else $$invalidate(2, outputs = []);
          }
        }

        if ($$self.$$.dirty[0] &
        /*$highlightInOut, $detailTx*/
        16777232) {
          {
            if ($highlightInOut && $detailTx && $highlightInOut.txid === $detailTx.id) {
              $$invalidate(10, highlight = {});
              if ($highlightInOut.input != null) $$invalidate(10, highlight.in = parseInt($highlightInOut.input), highlight);
              if ($highlightInOut.output != null) $$invalidate(10, highlight.out = parseInt($highlightInOut.output), highlight);
            } else {
              $$invalidate(10, highlight = {});
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx, inputs, outputs, sankeyHeight, svgWidth, flowWeight*/
        4194335) {
          {
            if ($detailTx && inputs && outputs) {
              $$invalidate(3, sankeyHeight = Math.max(inputs.length, outputs.length) * rowHeight);
              $$invalidate(11, sankeyLines = calcSankeyLines(inputs, outputs, $detailTx.fee || null, $detailTx.value, sankeyHeight, svgWidth, flowWeight));
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$detailTx*/
        16) {
          {
            if ($detailTx && $detailTx.id) {
              $$invalidate(12, spends = null);
              loadSpends($detailTx.id);
            } else {
              $$invalidate(12, spends = null);
            }
          }
        }
      };

      return [svgWidth, inputs, outputs, sankeyHeight, $detailTx, $latestBlockHeight, $pageWidth, triangleWidth, confirmations, feeColor, highlight, sankeyLines, spends, loadingSpends, $highlightingFull, onClose, addToWatchlist, midColor, clickItem, goToInput, goToSpend, goToBlock, flowWeight, truncate, $highlightInOut, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4];
    }

    class TransactionOverlay extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$e, create_fragment$e, safe_not_equal, {}, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TransactionOverlay",
          options,
          id: create_fragment$e.name
        });
      }

    }

    /* src/components/AboutOverlay.svelte generated by Svelte v3.44.3 */
    const file$d = "src/components/AboutOverlay.svelte"; // (58:6) {:else}

    function create_else_block$5(ctx) {
      let img;
      let img_src_value;
      const block = {
        c: function create() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = "/img/block-light.png")) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "class", "block-example svelte-1dwnbnx");
          add_location(img, file$d, 58, 8, 1889);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$5.name,
        type: "else",
        source: "(58:6) {:else}",
        ctx
      });
      return block;
    } // (56:6) {#if $settings.darkMode }


    function create_if_block$8(ctx) {
      let img;
      let img_src_value;
      const block = {
        c: function create() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = "/img/block-dark.png")) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "class", "block-example svelte-1dwnbnx");
          add_location(img, file$d, 56, 8, 1806);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$8.name,
        type: "if",
        source: "(56:6) {#if $settings.darkMode }",
        ctx
      });
      return block;
    } // (31:0) <Overlay name="about" on:close={onClose}>


    function create_default_slot$2(ctx) {
      let section;
      let h2;
      let t1;
      let p0;
      let t2;
      let span;
      let t4;
      let t5;
      let p1;
      let t7;
      let p2;
      let t8;
      let i0;
      let t10;
      let t11;
      let p3;
      let t12;
      let i1;
      let t14;
      let t15;
      let div0;
      let mempoollegend;
      let t16;
      let p4;
      let t18;
      let p5;
      let t20;
      let div1;
      let t21;
      let p6;
      let current;
      mempoollegend = new MempoolLegend({
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*$settings*/
        ctx[0].darkMode) return create_if_block$8;
        return create_else_block$5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          section = element("section");
          h2 = element("h2");
          h2.textContent = "Welcome to Bitfeed!";
          t1 = space();
          p0 = element("p");
          t2 = text("On a typical day, the Bitcoin network confirms around 300,000 transactions by mining an average of ");
          span = element("span");
          span.textContent = "144 blocks";
          t4 = text(".\n      Bitfeed attempts to visualise this flow of information.");
          t5 = space();
          p1 = element("p");
          p1.textContent = "As new transactions are received by our nodes, they drop into the mempool to await confirmation.";
          t7 = space();
          p2 = element("p");
          t8 = text("In ");
          i0 = element("i");
          i0.textContent = "value mode";
          t10 = text(", squares representing transactions in the mempool are sized according to total output value,\n      on a logarithmic scale (each additional unit of width represents a 10x increase in value).");
          t11 = space();
          p3 = element("p");
          t12 = text("In ");
          i1 = element("i");
          i1.textContent = "vbyte mode";
          t14 = text(", the area of each square is proportional to the size of the transaction measured in virtual bytes.");
          t15 = space();
          div0 = element("div");
          create_component(mempoollegend.$$.fragment);
          t16 = space();
          p4 = element("p");
          p4.textContent = "Tap, click or mouse-over a square for transaction details.";
          t18 = space();
          p5 = element("p");
          p5.textContent = "Every 10 minutes, on average, Bitcoin miners confirm transactions from the mempool by packaging them into blocks.";
          t20 = space();
          div1 = element("div");
          if_block.c();
          t21 = space();
          p6 = element("p");
          p6.textContent = "Bitfeed illustrates this movement from the mempool into each newly discovered block,\n      arranging confirmed transactions to show the total number and distribution of values.";
          add_location(h2, file$d, 32, 4, 702);
          attr_dev(span, "class", "nobreak svelte-1dwnbnx");
          add_location(span, file$d, 34, 105, 844);
          attr_dev(p0, "class", "svelte-1dwnbnx");
          add_location(p0, file$d, 33, 4, 735);
          attr_dev(p1, "class", "svelte-1dwnbnx");
          add_location(p1, file$d, 37, 4, 960);
          add_location(i0, file$d, 41, 9, 1093);
          attr_dev(p2, "class", "svelte-1dwnbnx");
          add_location(p2, file$d, 40, 4, 1080);
          add_location(i1, file$d, 44, 10, 1320);
          attr_dev(p3, "class", "svelte-1dwnbnx");
          add_location(p3, file$d, 44, 4, 1314);
          attr_dev(div0, "class", "figure mempool-figure svelte-1dwnbnx");
          add_location(div0, file$d, 45, 4, 1445);
          attr_dev(p4, "class", "svelte-1dwnbnx");
          add_location(p4, file$d, 48, 4, 1520);
          attr_dev(p5, "class", "svelte-1dwnbnx");
          add_location(p5, file$d, 51, 4, 1602);
          attr_dev(div1, "class", "figure block svelte-1dwnbnx");
          add_location(div1, file$d, 54, 4, 1739);
          attr_dev(p6, "class", "svelte-1dwnbnx");
          add_location(p6, file$d, 61, 4, 1978);
          attr_dev(section, "class", "about svelte-1dwnbnx");
          add_location(section, file$d, 31, 2, 674);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, h2);
          append_dev(section, t1);
          append_dev(section, p0);
          append_dev(p0, t2);
          append_dev(p0, span);
          append_dev(p0, t4);
          append_dev(section, t5);
          append_dev(section, p1);
          append_dev(section, t7);
          append_dev(section, p2);
          append_dev(p2, t8);
          append_dev(p2, i0);
          append_dev(p2, t10);
          append_dev(section, t11);
          append_dev(section, p3);
          append_dev(p3, t12);
          append_dev(p3, i1);
          append_dev(p3, t14);
          append_dev(section, t15);
          append_dev(section, div0);
          mount_component(mempoollegend, div0, null);
          append_dev(section, t16);
          append_dev(section, p4);
          append_dev(section, t18);
          append_dev(section, p5);
          append_dev(section, t20);
          append_dev(section, div1);
          if_block.m(div1, null);
          append_dev(section, t21);
          append_dev(section, p6);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (current_block_type !== (current_block_type = select_block_type(ctx))) {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div1, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(mempoollegend.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(mempoollegend.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          destroy_component(mempoollegend);
          if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$2.name,
        type: "slot",
        source: "(31:0) <Overlay name=\\\"about\\\" on:close={onClose}>",
        ctx
      });
      return block;
    }

    function create_fragment$d(ctx) {
      let overlay;
      let current;
      overlay = new Overlay({
        props: {
          name: "about",
          $$slots: {
            default: [create_default_slot$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      overlay.$on("close", onClose);
      const block = {
        c: function create() {
          create_component(overlay.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          const overlay_changes = {};

          if (dirty &
          /*$$scope, $settings*/
          3) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(overlay, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function onClose() {
      localStorage.setItem('seen-welcome-msg', true);
    }

    function instance$d($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(0, $settings = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('AboutOverlay', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AboutOverlay> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        Overlay,
        MempoolLegend,
        settings,
        onClose,
        $settings
      });

      return [$settings];
    }

    class AboutOverlay extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$d, create_fragment$d, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "AboutOverlay",
          options,
          id: create_fragment$d.name
        });
      }

    }

    /* src/components/sponsor/TierCard.svelte generated by Svelte v3.44.3 */
    const file$c = "src/components/sponsor/TierCard.svelte"; // (24:4) {:else}

    function create_else_block$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text(" ");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$4.name,
        type: "else",
        source: "(24:4) {:else}",
        ctx
      });
      return block;
    } // (22:4) {#if min && !optional}


    function create_if_block$7(ctx) {
      let t0;
      let t1_value = formatAmount(
      /*min*/
      ctx[4]) + "";
      let t1;
      const block = {
        c: function create() {
          t0 = text("≥ ");
          t1 = text(t1_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, t1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*min*/
          16 && t1_value !== (t1_value = formatAmount(
          /*min*/
          ctx[4]) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(t1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$7.name,
        type: "if",
        source: "(22:4) {#if min && !optional}",
        ctx
      });
      return block;
    }

    function create_fragment$c(ctx) {
      let div;
      let h3;
      let t0;
      let t1;
      let p0;
      let t2;
      let t3;
      let p1;
      let mounted;
      let dispose;

      function select_block_type(ctx, dirty) {
        if (
        /*min*/
        ctx[4] && !
        /*optional*/
        ctx[2]) return create_if_block$7;
        return create_else_block$4;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          div = element("div");
          h3 = element("h3");
          t0 = text(
          /*title*/
          ctx[1]);
          t1 = space();
          p0 = element("p");
          t2 = text(
          /*description*/
          ctx[3]);
          t3 = space();
          p1 = element("p");
          if_block.c();
          attr_dev(h3, "class", "title svelte-1fovccd");
          add_location(h3, file$c, 16, 2, 345);
          attr_dev(p0, "class", "desc svelte-1fovccd");
          add_location(p0, file$c, 17, 2, 380);
          attr_dev(p1, "class", "min svelte-1fovccd");
          add_location(p1, file$c, 20, 2, 426);
          attr_dev(div, "class", "tier-card svelte-1fovccd");
          toggle_class(div, "active",
          /*active*/
          ctx[0]);
          add_location(div, file$c, 15, 0, 297);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h3);
          append_dev(h3, t0);
          append_dev(div, t1);
          append_dev(div, p0);
          append_dev(p0, t2);
          append_dev(div, t3);
          append_dev(div, p1);
          if_block.m(p1, null);

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*click_handler*/
            ctx[5], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*title*/
          2) set_data_dev(t0,
          /*title*/
          ctx[1]);
          if (dirty &
          /*description*/
          8) set_data_dev(t2,
          /*description*/
          ctx[3]);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(p1, null);
            }
          }

          if (dirty &
          /*active*/
          1) {
            toggle_class(div, "active",
            /*active*/
            ctx[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_block.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function formatAmount(btc) {
      if (btc >= 0.01) return `₿ ${btc}`;else return `${Math.round(btc * 100000000).toLocaleString()} sats`;
    }

    function instance$c($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('TierCard', slots, []);
      let {
        active
      } = $$props;
      let {
        title
      } = $$props;
      let {
        optional
      } = $$props;
      let {
        description
      } = $$props;
      let {
        min
      } = $$props; // in BTC

      const writable_props = ['active', 'title', 'optional', 'description', 'min'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TierCard> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble.call(this, $$self, event);
      }

      $$self.$$set = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
        if ('title' in $$props) $$invalidate(1, title = $$props.title);
        if ('optional' in $$props) $$invalidate(2, optional = $$props.optional);
        if ('description' in $$props) $$invalidate(3, description = $$props.description);
        if ('min' in $$props) $$invalidate(4, min = $$props.min);
      };

      $$self.$capture_state = () => ({
        Icon,
        active,
        title,
        optional,
        description,
        min,
        formatAmount
      });

      $$self.$inject_state = $$props => {
        if ('active' in $$props) $$invalidate(0, active = $$props.active);
        if ('title' in $$props) $$invalidate(1, title = $$props.title);
        if ('optional' in $$props) $$invalidate(2, optional = $$props.optional);
        if ('description' in $$props) $$invalidate(3, description = $$props.description);
        if ('min' in $$props) $$invalidate(4, min = $$props.min);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [active, title, optional, description, min, click_handler];
    }

    class TierCard extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$c, create_fragment$c, safe_not_equal, {
          active: 0,
          title: 1,
          optional: 2,
          description: 3,
          min: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TierCard",
          options,
          id: create_fragment$c.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*active*/
        ctx[0] === undefined && !('active' in props)) {
          console.warn("<TierCard> was created without expected prop 'active'");
        }

        if (
        /*title*/
        ctx[1] === undefined && !('title' in props)) {
          console.warn("<TierCard> was created without expected prop 'title'");
        }

        if (
        /*optional*/
        ctx[2] === undefined && !('optional' in props)) {
          console.warn("<TierCard> was created without expected prop 'optional'");
        }

        if (
        /*description*/
        ctx[3] === undefined && !('description' in props)) {
          console.warn("<TierCard> was created without expected prop 'description'");
        }

        if (
        /*min*/
        ctx[4] === undefined && !('min' in props)) {
          console.warn("<TierCard> was created without expected prop 'min'");
        }
      }

      get active() {
        throw new Error("<TierCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set active(value) {
        throw new Error("<TierCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get title() {
        throw new Error("<TierCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set title(value) {
        throw new Error("<TierCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get optional() {
        throw new Error("<TierCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set optional(value) {
        throw new Error("<TierCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get description() {
        throw new Error("<TierCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set description(value) {
        throw new Error("<TierCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get min() {
        throw new Error("<TierCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set min(value) {
        throw new Error("<TierCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/sponsor/SatoshiSlider.svelte generated by Svelte v3.44.3 */
    const file$b = "src/components/sponsor/SatoshiSlider.svelte";

    function get_each_context$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    } // (101:6) {#each marks as mark }


    function create_each_block$4(ctx) {
      let div1;
      let div0;
      let t0;
      let span;
      let t1_value =
      /*mark*/
      ctx[18].emoji + "";
      let t1;
      let span_title_value;
      let t2;
      let div1_style_value;
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          t0 = space();
          span = element("span");
          t1 = text(t1_value);
          t2 = space();
          attr_dev(div0, "class", "tick svelte-11aajt6");
          add_location(div0, file$b, 107, 10, 2715);
          attr_dev(span, "class", "bubble-icon svelte-11aajt6");
          attr_dev(span, "title", span_title_value =
          /*mark*/
          ctx[18].title);
          add_location(span, file$b, 108, 10, 2746);
          attr_dev(div1, "class", "mark svelte-11aajt6");
          attr_dev(div1, "style", div1_style_value =
          /*mark*/
          ctx[18].style);
          toggle_class(div1, "active",
          /*value*/
          ctx[0] >=
          /*mark*/
          ctx[18].minSats);
          toggle_class(div1, "over",
          /*value*/
          ctx[0] >=
          /*mark*/
          ctx[18].maxSats);
          add_location(div1, file$b, 101, 8, 2546);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div1, t0);
          append_dev(div1, span);
          append_dev(span, t1);
          append_dev(div1, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*marks*/
          8 && t1_value !== (t1_value =
          /*mark*/
          ctx[18].emoji + "")) set_data_dev(t1, t1_value);

          if (dirty &
          /*marks*/
          8 && span_title_value !== (span_title_value =
          /*mark*/
          ctx[18].title)) {
            attr_dev(span, "title", span_title_value);
          }

          if (dirty &
          /*marks*/
          8 && div1_style_value !== (div1_style_value =
          /*mark*/
          ctx[18].style)) {
            attr_dev(div1, "style", div1_style_value);
          }

          if (dirty &
          /*value, marks*/
          9) {
            toggle_class(div1, "active",
            /*value*/
            ctx[0] >=
            /*mark*/
            ctx[18].minSats);
          }

          if (dirty &
          /*value, marks*/
          9) {
            toggle_class(div1, "over",
            /*value*/
            ctx[0] >=
            /*mark*/
            ctx[18].maxSats);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$4.name,
        type: "each",
        source: "(101:6) {#each marks as mark }",
        ctx
      });
      return block;
    }

    function create_fragment$b(ctx) {
      let div3;
      let div2;
      let div0;
      let t0;
      let div1;
      let t1;
      let span;
      let mounted;
      let dispose;
      let each_value =
      /*marks*/
      ctx[3];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div3 = element("div");
          div2 = element("div");
          div0 = element("div");
          t0 = space();
          div1 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          span = element("span");
          attr_dev(div0, "class", "filled-track svelte-11aajt6");
          attr_dev(div0, "style",
          /*trackStyle*/
          ctx[5]);
          add_location(div0, file$b, 98, 4, 2437);
          attr_dev(div1, "class", "marks");
          add_location(div1, file$b, 99, 4, 2489);
          attr_dev(span, "class", "handle svelte-11aajt6");
          attr_dev(span, "style",
          /*handleStyle*/
          ctx[4]);
          attr_dev(span, "draggable", false);
          add_location(span, file$b, 112, 4, 2857);
          attr_dev(div2, "class", "track svelte-11aajt6");
          toggle_class(div2, "dragging",
          /*dragging*/
          ctx[2]);
          add_location(div2, file$b, 97, 2, 2362);
          attr_dev(div3, "class", "satoshi-slider svelte-11aajt6");
          add_location(div3, file$b, 96, 0, 2331);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div2);
          append_dev(div2, div0);
          append_dev(div2, t0);
          append_dev(div2, div1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div1, null);
          }

          append_dev(div2, t1);
          append_dev(div2, span);
          /*div2_binding*/

          ctx[11](div2);

          if (!mounted) {
            dispose = listen_dev(span, "pointerdown",
            /*startDrag*/
            ctx[6], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*trackStyle*/
          32) {
            attr_dev(div0, "style",
            /*trackStyle*/
            ctx[5]);
          }

          if (dirty &
          /*marks, value*/
          9) {
            each_value =
            /*marks*/
            ctx[3];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div1, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty &
          /*handleStyle*/
          16) {
            attr_dev(span, "style",
            /*handleStyle*/
            ctx[4]);
          }

          if (dirty &
          /*dragging*/
          4) {
            toggle_class(div2, "dragging",
            /*dragging*/
            ctx[2]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
          destroy_each(each_blocks, detaching);
          /*div2_binding*/

          ctx[11](null);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SatoshiSlider', slots, []);
      const dispatch = createEventDispatcher();
      let {
        value = 0
      } = $$props;
      let {
        max = 100000000
      } = $$props;
      let {
        logScale = false
      } = $$props;
      let {
        thresholds = []
      } = $$props;
      let trackElement, trackBounds;
      let dragging = false;
      let marks = [];
      let activeThreshold = {};
      let handleStyle;
      let trackStyle;

      function percentOfScale(amount) {
        let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000;
        let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
        let percent;

        if (logScale) {
          let logMin = Math.log10(min);
          percent = Math.max(0, Math.log10(amount) - logMin) / (Math.log10(max) - logMin) * 100;
        } else {
          percent = amount / max * 100;
        }

        return Math.min(percent, 100);
      }

      function toScale(fraction) {
        let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000;
        let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;

        if (logScale) {
          let logMin = Math.log10(min);
          const raw = Math.pow(10, fraction * (Math.log10(max) - logMin) + logMin);
          const clamped = Math.min(max, Math.max(min, raw));
          return Math.round(clamped);
        } else {
          return Math.round(fraction * max);
        }
      }

      function startDrag(e) {
        if (trackElement) {
          trackBounds = trackElement.getBoundingClientRect();
          cancelDrag();
          $$invalidate(2, dragging = true);
          window.addEventListener('pointermove', onDrag);
          window.addEventListener('pointerup', cancelDrag);
          window.addEventListener('pointercancel', cancelDrag);
          onDrag(e);
        }
      }

      function onDrag(e) {
        const dx = e.pageX - trackBounds.left;
        const fraction = dx / trackBounds.width;
        const newValue = toScale(fraction, max);
        dispatch('input', newValue);
      }

      function cancelDrag(e) {
        $$invalidate(2, dragging = false);
        window.removeEventListener('pointermove', onDrag);
        window.removeEventListener('pointerup', cancelDrag);
        window.removeEventListener('pointercancel', cancelDrag);
      }

      const writable_props = ['value', 'max', 'logScale', 'thresholds'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SatoshiSlider> was created with unknown prop '${key}'`);
      });

      function div2_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          trackElement = $$value;
          $$invalidate(1, trackElement);
        });
      }

      $$self.$$set = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('max' in $$props) $$invalidate(7, max = $$props.max);
        if ('logScale' in $$props) $$invalidate(8, logScale = $$props.logScale);
        if ('thresholds' in $$props) $$invalidate(9, thresholds = $$props.thresholds);
      };

      $$self.$capture_state = () => ({
        createEventDispatcher,
        dispatch,
        value,
        max,
        logScale,
        thresholds,
        trackElement,
        trackBounds,
        dragging,
        marks,
        activeThreshold,
        handleStyle,
        trackStyle,
        percentOfScale,
        toScale,
        startDrag,
        onDrag,
        cancelDrag
      });

      $$self.$inject_state = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('max' in $$props) $$invalidate(7, max = $$props.max);
        if ('logScale' in $$props) $$invalidate(8, logScale = $$props.logScale);
        if ('thresholds' in $$props) $$invalidate(9, thresholds = $$props.thresholds);
        if ('trackElement' in $$props) $$invalidate(1, trackElement = $$props.trackElement);
        if ('trackBounds' in $$props) trackBounds = $$props.trackBounds;
        if ('dragging' in $$props) $$invalidate(2, dragging = $$props.dragging);
        if ('marks' in $$props) $$invalidate(3, marks = $$props.marks);
        if ('activeThreshold' in $$props) $$invalidate(10, activeThreshold = $$props.activeThreshold);
        if ('handleStyle' in $$props) $$invalidate(4, handleStyle = $$props.handleStyle);
        if ('trackStyle' in $$props) $$invalidate(5, trackStyle = $$props.trackStyle);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*thresholds, max*/
        640) {
          {
            if (thresholds && thresholds.length) {
              $$invalidate(3, marks = thresholds.map(thresh => {
                return { ...thresh,
                  style: `left: ${percentOfScale(thresh.minSats, max)}%; --mark-bg: ${thresh.color};`
                };
              }));
            }
          }
        }

        if ($$self.$$.dirty &
        /*thresholds, value*/
        513) {
          {
            $$invalidate(10, activeThreshold = {});

            if (thresholds && value != null) {
              thresholds.forEach(thresh => {
                if (value >= thresh.minSats) $$invalidate(10, activeThreshold = thresh);
              });
            }
          }
        }

        if ($$self.$$.dirty &
        /*value, max, activeThreshold*/
        1153) {
          {
            $$invalidate(4, handleStyle = `left: ${percentOfScale(value, max)}%; background-color: ${activeThreshold.color || 'var(--grey)'}`);
          }
        }

        if ($$self.$$.dirty &
        /*value, max, activeThreshold*/
        1153) {
          {
            $$invalidate(5, trackStyle = `right: ${100 - percentOfScale(value, max)}%; --track-bg: ${activeThreshold.color || 'var(--grey)'}`);
          }
        }
      };

      return [value, trackElement, dragging, marks, handleStyle, trackStyle, startDrag, max, logScale, thresholds, activeThreshold, div2_binding];
    }

    class SatoshiSlider extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$b, create_fragment$b, safe_not_equal, {
          value: 0,
          max: 7,
          logScale: 8,
          thresholds: 9
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SatoshiSlider",
          options,
          id: create_fragment$b.name
        });
      }

      get value() {
        throw new Error("<SatoshiSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set value(value) {
        throw new Error("<SatoshiSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get max() {
        throw new Error("<SatoshiSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set max(value) {
        throw new Error("<SatoshiSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get logScale() {
        throw new Error("<SatoshiSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set logScale(value) {
        throw new Error("<SatoshiSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get thresholds() {
        throw new Error("<SatoshiSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set thresholds(value) {
        throw new Error("<SatoshiSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    var boltIcon = '<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg   xmlns:dc="http://purl.org/dc/elements/1.1/"   xmlns:cc="http://creativecommons.org/ns#"   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"   xmlns:svg="http://www.w3.org/2000/svg"   xmlns="http://www.w3.org/2000/svg"   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"   viewBox="0 0 512 512"   version="1.1"   id="svg4"   sodipodi:docname="cil-bolt-filled.svg"   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)">  <metadata     id="metadata10">    <rdf:RDF>      <cc:Work         rdf:about="">        <dc:format>image/svg+xml</dc:format>        <dc:type           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />        <dc:title></dc:title>      </cc:Work>    </rdf:RDF>  </metadata>  <defs     id="defs8" />  <sodipodi:namedview     pagecolor="#ffffff"     bordercolor="#666666"     borderopacity="1"     objecttolerance="10"     gridtolerance="10"     guidetolerance="10"     inkscape:pageopacity="0"     inkscape:pageshadow="2"     inkscape:window-     inkscape:window-     id="namedview6"     showgrid="false"     inkscape:zoom="0.921875"     inkscape:cx="269.08535"     inkscape:cy="199.99903"     inkscape:window-x="237"     inkscape:window-y="60"     inkscape:window-maximized="0"     inkscape:current-layer="svg4" />  <path     fill="var(--ci-primary-color, currentColor)"     d="m 331.464,192 77,-176 H 147.879 l -81,288 H 187.9 l -39.53,192 h 58.851 L 475.456,192 Z"     class="ci-primary"     id="path2"     inkscape:connector-curvature="0"     sodipodi:nodetypes="ccccccccc" /></svg>';

    var chainIcon = '<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg   xmlns:dc="http://purl.org/dc/elements/1.1/"   xmlns:cc="http://creativecommons.org/ns#"   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"   xmlns:svg="http://www.w3.org/2000/svg"   xmlns="http://www.w3.org/2000/svg"   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"   viewBox="0 0 512 512"   version="1.1"   id="svg8"   sodipodi:docname="cil-link.svg"   inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)">  <metadata     id="metadata14">    <rdf:RDF>      <cc:Work         rdf:about="">        <dc:format>image/svg+xml</dc:format>        <dc:type           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />      </cc:Work>    </rdf:RDF>  </metadata>  <defs     id="defs12" />  <sodipodi:namedview     pagecolor="#ffffff"     bordercolor="#666666"     borderopacity="1"     objecttolerance="10"     gridtolerance="10"     guidetolerance="10"     inkscape:pageopacity="0"     inkscape:pageshadow="2"     inkscape:window-     inkscape:window-     id="namedview10"     showgrid="false"     inkscape:zoom="1.3037281"     inkscape:cx="168.92648"     inkscape:cy="226.80926"     inkscape:window-x="0"     inkscape:window-y="27"     inkscape:window-maximized="1"     inkscape:current-layer="svg8" />  <path     inkscape:connector-curvature="0"     fill="var(--ci-primary-color, currentColor)"     d="m 355.64708,135.02849 -226.27417,226.27418 22.624,22.627 226.27758,-226.27377 z"     class="ci-primary"     id="path6"     sodipodi:nodetypes="ccccc" />  <path     fill="var(--ci-primary-color, currentColor)"     d="M457.47,55.833c-53.026-53.026-139.307-53.026-192.332,0L168.971,152,191.6,174.627,287.765,78.46A104,104,0,0,1,434.843,225.539l-96.167,96.167L361.3,344.333l96.167-96.167C510.5,195.14,510.5,108.86,457.47,55.833Z"     class="ci-primary"     id="path2" />  <path     fill="var(--ci-primary-color, currentColor)"     d="M225.539,434.843a104,104,0,0,1-147.078,0h0a104,104,0,0,1,0-147.078l90.511-90.511-22.627-22.627L55.833,265.138A136,136,0,1,0,248.166,457.47l90.51-90.51-22.627-22.627Z"     class="ci-primary"     id="path4" /></svg>';

    var tickIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <polygon fill="var(--ci-primary-color, currentColor)" points="200.359 382.269 61.057 251.673 82.943 228.327 199.641 337.731 428.686 108.687 451.314 131.313 200.359 382.269" class="ci-primary"/></svg>';

    var spinnerIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M410.168,133.046,381.21,104.088,464.017,104l-.034-32L328,72.144V208h32V128.132l27.541,27.541A152.5,152.5,0,0,1,279.972,416l.056,32a184.5,184.5,0,0,0,130.14-314.954Z" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M232.028,104l-.056-32a184.5,184.5,0,0,0-130.14,314.954L130.878,416H48v32H184V312H152v79.868l-27.541-27.541A152.5,152.5,0,0,1,232.028,104Z" class="ci-primary"/></svg>';

    var timerIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <rect x="240" y="384" fill="var(--ci-primary-color, currentColor)" class="ci-primary"/>  <rect width="32" height="32" x="96" y="240" fill="var(--ci-primary-color, currentColor)" class="ci-primary"/>  <rect width="32" height="32" x="384" y="240" fill="var(--ci-primary-color, currentColor)" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M414.392,97.608A222.332,222.332,0,0,0,272,32.567V32H240v96h32V64.672C370.41,72.83,448,155.519,448,256c0,105.869-86.131,192-192,192S64,361.869,64,256a191.61,191.61,0,0,1,56.408-135.942l115.624,145.88,25.078-19.876L124.6,73.828l-12.606,10.59a224,224,0,1,0,302.4,13.19Z" class="ci-primary"/></svg>';

    var emailIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M16,112V496H496V112ZM236.8,341.6a32.167,32.167,0,0,0,38.4,0L298.667,324,464,448v16H48V448L213.333,324ZM256,316,48,160V144H464v16ZM48,200,186.667,304,48,408ZM464,408,325.333,304,464,200Z" class="ci-primary"/></svg>';

    var clipboardIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">  <path fill="var(--ci-primary-color, currentColor)" d="M432,56H376V88h48V464H88V88h48V56H80A24.028,24.028,0,0,0,56,80V472a24.028,24.028,0,0,0,24,24H432a24.028,24.028,0,0,0,24-24V80A24.028,24.028,0,0,0,432,56Z" class="ci-primary"/>  <path fill="var(--ci-primary-color, currentColor)" d="M192,140H320a24.028,24.028,0,0,0,24-24V16H168V116A24.028,24.028,0,0,0,192,140Zm8-92H312v60H200Z" class="ci-primary"/></svg>';

    var browser = {};

    // can-promise has a crash in some versions of react native that dont have
    // standard global objects
    // https://github.com/soldair/node-qrcode/issues/157
    var canPromise$1 = function () {
      return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;
    };

    var qrcode = {};

    var utils$1 = {};

    let toSJISFunction;
    const CODEWORDS_COUNT = [0, // Not used
    26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
    /**
     * Returns the QR Code size for the specified version
     *
     * @param  {Number} version QR Code version
     * @return {Number}         size of QR code
     */

    utils$1.getSymbolSize = function getSymbolSize(version) {
      if (!version) throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    /**
     * Returns the total number of codewords used to store data and EC information.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Data length in bits
     */


    utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    /**
     * Encode data with Bose-Chaudhuri-Hocquenghem
     *
     * @param  {Number} data Value to encode
     * @return {Number}      Encoded value
     */


    utils$1.getBCHDigit = function (data) {
      let digit = 0;

      while (data !== 0) {
        digit++;
        data >>>= 1;
      }

      return digit;
    };

    utils$1.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== 'function') {
        throw new Error('"toSJISFunc" is not a valid function.');
      }

      toSJISFunction = f;
    };

    utils$1.isKanjiModeEnabled = function () {
      return typeof toSJISFunction !== 'undefined';
    };

    utils$1.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };

    var errorCorrectionLevel = {};

    (function (exports) {
    exports.L = {
      bit: 1
    };
    exports.M = {
      bit: 0
    };
    exports.Q = {
      bit: 3
    };
    exports.H = {
      bit: 2
    };

    function fromString(string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string');
      }

      const lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'l':
        case 'low':
          return exports.L;

        case 'm':
        case 'medium':
          return exports.M;

        case 'q':
        case 'quartile':
          return exports.Q;

        case 'h':
        case 'high':
          return exports.H;

        default:
          throw new Error('Unknown EC Level: ' + string);
      }
    }

    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;
    };

    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }

      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
    }(errorCorrectionLevel));

    function BitBuffer$1() {
      this.buffer = [];
      this.length = 0;
    }

    BitBuffer$1.prototype = {
      get: function (index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function (num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function () {
        return this.length;
      },
      putBit: function (bit) {
        const bufIndex = Math.floor(this.length / 8);

        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }

        if (bit) {
          this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
        }

        this.length++;
      }
    };
    var bitBuffer = BitBuffer$1;

    /**
     * Helper class to handle QR Code symbol modules
     *
     * @param {Number} size Symbol size
     */

    function BitMatrix$1(size) {
      if (!size || size < 1) {
        throw new Error('BitMatrix size must be defined and greater than 0');
      }

      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    /**
     * Set bit value at specified location
     * If reserved flag is set, this bit will be ignored during masking process
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     * @param {Boolean} reserved
     */


    BitMatrix$1.prototype.set = function (row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    /**
     * Returns bit value at specified location
     *
     * @param  {Number}  row
     * @param  {Number}  col
     * @return {Boolean}
     */


    BitMatrix$1.prototype.get = function (row, col) {
      return this.data[row * this.size + col];
    };
    /**
     * Applies xor operator at specified location
     * (used during masking process)
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     */


    BitMatrix$1.prototype.xor = function (row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    /**
     * Check if bit at specified location is reserved
     *
     * @param {Number}   row
     * @param {Number}   col
     * @return {Boolean}
     */


    BitMatrix$1.prototype.isReserved = function (row, col) {
      return this.reservedBit[row * this.size + col];
    };

    var bitMatrix = BitMatrix$1;

    var alignmentPattern = {};

    /**
     * Alignment pattern are fixed reference pattern in defined positions
     * in a matrix symbology, which enables the decode software to re-synchronise
     * the coordinate mapping of the image modules in the event of moderate amounts
     * of distortion of the image.
     *
     * Alignment patterns are present only in QR Code symbols of version 2 or larger
     * and their number depends on the symbol version.
     */

    (function (exports) {
    const getSymbolSize = utils$1.getSymbolSize;
    /**
     * Calculate the row/column coordinates of the center module of each alignment pattern
     * for the specified QR Code version.
     *
     * The alignment patterns are positioned symmetrically on either side of the diagonal
     * running from the top left corner of the symbol to the bottom right corner.
     *
     * Since positions are simmetrical only half of the coordinates are returned.
     * Each item of the array will represent in turn the x and y coordinate.
     * @see {@link getPositions}
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinate
     */


    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1) return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7]; // Last coord is always (size - 7)

      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }

      positions.push(6); // First coord is always 6

      return positions.reverse();
    };
    /**
     * Returns an array containing the positions of each alignment pattern.
     * Each array's element represent the center point of the pattern as (x, y) coordinates
     *
     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
     * and filtering out the items that overlaps with finder pattern
     *
     * @example
     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
     * The alignment patterns, therefore, are to be centered on (row, column)
     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
     * and are not therefore used for alignment patterns.
     *
     * let pos = getPositions(7)
     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */


    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;

      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          // Skip if position is occupied by finder patterns
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            // top-right
            continue;
          }

          coords.push([pos[i], pos[j]]);
        }
      }

      return coords;
    };
    }(alignmentPattern));

    var finderPattern = {};

    const getSymbolSize = utils$1.getSymbolSize;

    const FINDER_PATTERN_SIZE = 7;
    /**
     * Returns an array containing the positions of each finder pattern.
     * Each array's element represent the top-left point of the pattern as (x, y) coordinates
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */

    finderPattern.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [// top-left
      [0, 0], // top-right
      [size - FINDER_PATTERN_SIZE, 0], // bottom-left
      [0, size - FINDER_PATTERN_SIZE]];
    };

    var maskPattern = {};

    /**
     * Data mask pattern reference
     * @type {Object}
     */

    (function (exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    /**
     * Weighted penalty scores for the undesirable features
     * @type {Object}
     */

    const PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    /**
     * Check if mask pattern value is valid
     *
     * @param  {Number}  mask    Mask pattern
     * @return {Boolean}         true if valid, false otherwise
     */

    exports.isValid = function isValid(mask) {
      return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    /**
     * Returns mask pattern from a value.
     * If value is not valid, returns undefined
     *
     * @param  {Number|String} value        Mask pattern value
     * @return {Number}                     Valid mask pattern or undefined
     */


    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : undefined;
    };
    /**
    * Find adjacent modules in row/column with the same color
    * and assign a penalty value.
    *
    * Points: N1 + i
    * i is the amount by which the number of adjacent modules of the same color exceeds 5
    */


    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;

      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;

        for (let col = 0; col < size; col++) {
          let module = data.get(row, col);

          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }

          module = data.get(col, row);

          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }

        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }

      return points;
    };
    /**
     * Find 2x2 blocks with the same color and assign a penalty value
     *
     * Points: N2 * (m - 1) * (n - 1)
     */


    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;

      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }

      return points * PenaltyScores.N2;
    };
    /**
     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
     * preceded or followed by light area 4 modules wide
     *
     * Points: N3 * number of pattern found
     */


    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;

      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;

        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);
          if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;
          bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);
          if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
        }
      }

      return points * PenaltyScores.N3;
    };
    /**
     * Calculate proportion of dark modules in entire symbol
     *
     * Points: N4 * k
     *
     * k is the rating of the deviation of the proportion of dark modules
     * in the symbol from 50% in steps of 5%
     */


    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;

      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];

      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    /**
     * Return mask value at given position
     *
     * @param  {Number} maskPattern Pattern reference value
     * @param  {Number} i           Row
     * @param  {Number} j           Column
     * @return {Boolean}            Mask value
     */


    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;

        case exports.Patterns.PATTERN001:
          return i % 2 === 0;

        case exports.Patterns.PATTERN010:
          return j % 3 === 0;

        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;

        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;

        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;

        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;

        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;

        default:
          throw new Error('bad maskPattern:' + maskPattern);
      }
    }
    /**
     * Apply a mask pattern to a BitMatrix
     *
     * @param  {Number}    pattern Pattern reference number
     * @param  {BitMatrix} data    BitMatrix data
     */


    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;

      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    /**
     * Returns the best mask pattern for data
     *
     * @param  {BitMatrix} data
     * @return {Number} Mask pattern reference number
     */


    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;

      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data); // Calculate penalty

        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data); // Undo previously applied mask

        exports.applyMask(p, data);

        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }

      return bestPattern;
    };
    }(maskPattern));

    var errorCorrectionCode = {};

    const ECLevel$1 = errorCorrectionLevel;

    const EC_BLOCKS_TABLE = [// L  M  Q  H
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];
    const EC_CODEWORDS_TABLE = [// L  M  Q  H
    7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
    /**
     * Returns the number of error correction block that the QR Code should contain
     * for the specified version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction blocks
     */

    errorCorrectionCode.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel$1.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];

        case ECLevel$1.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];

        case ECLevel$1.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];

        case ECLevel$1.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];

        default:
          return undefined;
      }
    };
    /**
     * Returns the number of error correction codewords to use for the specified
     * version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction codewords
     */


    errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel$1.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];

        case ECLevel$1.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];

        case ECLevel$1.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];

        case ECLevel$1.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];

        default:
          return undefined;
      }
    };

    var polynomial = {};

    var galoisField = {};

    const EXP_TABLE = new Uint8Array(512);
    const LOG_TABLE = new Uint8Array(256)
    /**
     * Precompute the log and anti-log tables for faster computation later
     *
     * For each possible value in the galois field 2^8, we will pre-compute
     * the logarithm and anti-logarithm (exponential) of this value
     *
     * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
     */
    ;

    (function initTables() {
      let x = 1;

      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1; // multiply by 2
        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
        // This means that when a number is 256 or larger, it should be XORed with 0x11D.

        if (x & 0x100) {
          // similar to x >= 256, but a lot faster (because 0x100 == 256)
          x ^= 0x11D;
        }
      } // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
      // stay inside the bounds (because we will mainly use this table for the multiplication of
      // two GF numbers, no more).
      // @see {@link mul}


      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    /**
     * Returns log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */


    galoisField.log = function log(n) {
      if (n < 1) throw new Error('log(' + n + ')');
      return LOG_TABLE[n];
    };
    /**
     * Returns anti-log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */


    galoisField.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    /**
     * Multiplies two number inside Galois Field
     *
     * @param  {Number} x
     * @param  {Number} y
     * @return {Number}
     */


    galoisField.mul = function mul(x, y) {
      if (x === 0 || y === 0) return 0; // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
      // @see {@link initTables}

      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };

    (function (exports) {
    const GF = galoisField;
    /**
     * Multiplies two polynomials inside Galois Field
     *
     * @param  {Uint8Array} p1 Polynomial
     * @param  {Uint8Array} p2 Polynomial
     * @return {Uint8Array}    Product of p1 and p2
     */


    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);

      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }

      return coeff;
    };
    /**
     * Calculate the remainder of polynomials division
     *
     * @param  {Uint8Array} divident Polynomial
     * @param  {Uint8Array} divisor  Polynomial
     * @return {Uint8Array}          Remainder
     */


    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);

      while (result.length - divisor.length >= 0) {
        const coeff = result[0];

        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        } // remove all zeros from buffer head


        let offset = 0;

        while (offset < result.length && result[offset] === 0) offset++;

        result = result.slice(offset);
      }

      return result;
    };
    /**
     * Generate an irreducible generator polynomial of specified degree
     * (used by Reed-Solomon encoder)
     *
     * @param  {Number} degree Degree of the generator polynomial
     * @return {Uint8Array}    Buffer containing polynomial coefficients
     */


    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);

      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }

      return poly;
    };
    }(polynomial));

    const Polynomial = polynomial;

    function ReedSolomonEncoder$1(degree) {
      this.genPoly = undefined;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    /**
     * Initialize the encoder.
     * The input param should correspond to the number of error correction codewords.
     *
     * @param  {Number} degree
     */


    ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
      // create an irreducible generator polynomial
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    /**
     * Encodes a chunk of data
     *
     * @param  {Uint8Array} data Buffer containing input data
     * @return {Uint8Array}      Buffer containing encoded data
     */


    ReedSolomonEncoder$1.prototype.encode = function encode(data) {
      if (!this.genPoly) {
        throw new Error('Encoder not initialized');
      } // Calculate EC for this data block
      // extends data size to data+genPoly size


      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data); // The error correction codewords are the remainder after dividing the data codewords
      // by a generator polynomial

      const remainder = Polynomial.mod(paddedData, this.genPoly); // return EC data blocks (last n byte, where n is the degree of genPoly)
      // If coefficients number in remainder are less than genPoly degree,
      // pad with 0s to the left to reach the needed number of coefficients

      const start = this.degree - remainder.length;

      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }

      return remainder;
    };

    var reedSolomonEncoder = ReedSolomonEncoder$1;

    var version = {};

    var mode = {};

    var versionCheck = {};

    /**
     * Check if QR Code version is valid
     *
     * @param  {Number}  version QR Code version
     * @return {Boolean}         true if valid version, false otherwise
     */

    versionCheck.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };

    var regex = {};

    const numeric = '[0-9]+';
    const alphanumeric = '[A-Z $%*+\\-./:]+';
    let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
    kanji = kanji.replace(/u/g, '\\u');
    const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';
    regex.KANJI = new RegExp(kanji, 'g');
    regex.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
    regex.BYTE = new RegExp(byte, 'g');
    regex.NUMERIC = new RegExp(numeric, 'g');
    regex.ALPHANUMERIC = new RegExp(alphanumeric, 'g');
    const TEST_KANJI = new RegExp('^' + kanji + '$');
    const TEST_NUMERIC = new RegExp('^' + numeric + '$');
    const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

    regex.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };

    regex.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };

    regex.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };

    (function (exports) {
    const VersionCheck = versionCheck;

    const Regex = regex;
    /**
     * Numeric mode encodes data from the decimal digit set (0 - 9)
     * (byte values 30HEX to 39HEX).
     * Normally, 3 data characters are represented by 10 bits.
     *
     * @type {Object}
     */


    exports.NUMERIC = {
      id: 'Numeric',
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    /**
     * Alphanumeric mode encodes data from a set of 45 characters,
     * i.e. 10 numeric digits (0 - 9),
     *      26 alphabetic characters (A - Z),
     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
     * Normally, two input characters are represented by 11 bits.
     *
     * @type {Object}
     */

    exports.ALPHANUMERIC = {
      id: 'Alphanumeric',
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    /**
     * In byte mode, data is encoded at 8 bits per character.
     *
     * @type {Object}
     */

    exports.BYTE = {
      id: 'Byte',
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    /**
     * The Kanji mode efficiently encodes Kanji characters in accordance with
     * the Shift JIS system based on JIS X 0208.
     * The Shift JIS values are shifted from the JIS X 0208 values.
     * JIS X 0208 gives details of the shift coded representation.
     * Each two-byte character value is compacted to a 13-bit binary codeword.
     *
     * @type {Object}
     */

    exports.KANJI = {
      id: 'Kanji',
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    /**
     * Mixed mode will contain a sequences of data in a combination of any of
     * the modes described above
     *
     * @type {Object}
     */

    exports.MIXED = {
      bit: -1
    };
    /**
     * Returns the number of bits needed to store the data length
     * according to QR Code specifications.
     *
     * @param  {Mode}   mode    Data mode
     * @param  {Number} version QR Code version
     * @return {Number}         Number of bits
     */

    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);

      if (!VersionCheck.isValid(version)) {
        throw new Error('Invalid version: ' + version);
      }

      if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    /**
     * Returns the most efficient mode to store the specified data
     *
     * @param  {String} dataStr Input data string
     * @return {Mode}           Best mode
     */


    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;
    };
    /**
     * Return mode name as string
     *
     * @param {Mode} mode Mode object
     * @returns {String}  Mode name
     */


    exports.toString = function toString(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error('Invalid mode');
    };
    /**
     * Check if input param is a valid mode object
     *
     * @param   {Mode}    mode Mode object
     * @returns {Boolean} True if valid mode, false otherwise
     */


    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    /**
     * Get mode object from its name
     *
     * @param   {String} string Mode name
     * @returns {Mode}          Mode object
     */


    function fromString(string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string');
      }

      const lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'numeric':
          return exports.NUMERIC;

        case 'alphanumeric':
          return exports.ALPHANUMERIC;

        case 'kanji':
          return exports.KANJI;

        case 'byte':
          return exports.BYTE;

        default:
          throw new Error('Unknown mode: ' + string);
      }
    }
    /**
     * Returns mode from a value.
     * If value is not a valid mode, returns defaultValue
     *
     * @param  {Mode|String} value        Encoding mode
     * @param  {Mode}        defaultValue Fallback value
     * @return {Mode}                     Encoding mode
     */


    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }

      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
    }(mode));

    (function (exports) {
    const Utils = utils$1;

    const ECCode = errorCorrectionCode;

    const ECLevel = errorCorrectionLevel;

    const Mode = mode;

    const VersionCheck = versionCheck; // Generator polynomial used to encode version information


    const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    const G18_BCH = Utils.getBCHDigit(G18);

    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }

      return undefined;
    }

    function getReservedBitsCount(mode, version) {
      // Character count indicator + mode indicator bits
      return Mode.getCharCountIndicator(mode, version) + 4;
    }

    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function (data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }

    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);

        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }

      return undefined;
    }
    /**
     * Returns version number from a value.
     * If value is not a valid version, returns defaultValue
     *
     * @param  {Number|String} value        QR Code version
     * @param  {Number}        defaultValue Fallback value
     * @return {Number}                     QR Code version number
     */


    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }

      return defaultValue;
    };
    /**
     * Returns how much data can be stored with the specified QR code version
     * and error correction level
     *
     * @param  {Number} version              QR Code version (1-40)
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Mode}   mode                 Data mode
     * @return {Number}                      Quantity of storable data
     */


    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error('Invalid QR Code version');
      } // Use Byte mode as default


      if (typeof mode === 'undefined') mode = Mode.BYTE; // Total codewords for this QR code version (Data + Error correction)

      const totalCodewords = Utils.getSymbolTotalCodewords(version); // Total number of error correction codewords

      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords

      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version); // Return max number of storable codewords

      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);

        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);

        case Mode.KANJI:
          return Math.floor(usableBits / 13);

        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    /**
     * Returns the minimum version needed to contain the amount of data
     *
     * @param  {Segment} data                    Segment of data
     * @param  {Number} [errorCorrectionLevel=H] Error correction level
     * @param  {Mode} mode                       Data mode
     * @return {Number}                          QR Code version
     */


    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }

        if (data.length === 0) {
          return 1;
        }

        seg = data[0];
      } else {
        seg = data;
      }

      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    /**
     * Returns version information with relative error correction bits
     *
     * The version information is included in QR Code symbols of version 7 or larger.
     * It consists of an 18-bit sequence containing 6 data bits,
     * with 12 error correction bits calculated using the (18, 6) Golay code.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Encoded version info bits
     */


    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error('Invalid QR Code version');
      }

      let d = version << 12;

      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }

      return version << 12 | d;
    };
    }(version));

    var formatInfo = {};

    const Utils$3 = utils$1;

    const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    const G15_BCH = Utils$3.getBCHDigit(G15);
    /**
     * Returns format information with relative error correction bits
     *
     * The format information is a 15-bit sequence containing 5 data bits,
     * with 10 error correction bits calculated using the (15, 5) BCH code.
     *
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Number} mask                 Mask pattern
     * @return {Number}                      Encoded format information bits
     */

    formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;

      while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils$3.getBCHDigit(d) - G15_BCH;
      } // xor final data with mask pattern in order to ensure that
      // no combination of Error Correction Level and data mask pattern
      // will result in an all-zero data string


      return (data << 10 | d) ^ G15_MASK;
    };

    var segments = {};

    const Mode$4 = mode;

    function NumericData(data) {
      this.mode = Mode$4.NUMERIC;
      this.data = data.toString();
    }

    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };

    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };

    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };

    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value; // The input data string is divided into groups of three digits,
      // and each group is converted to its 10-bit binary equivalent.

      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      } // If the number of input digits is not an exact multiple of three,
      // the final one or two digits are converted to 4 or 7 bits respectively.


      const remainingNum = this.data.length - i;

      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };

    var numericData = NumericData;

    const Mode$3 = mode;
    /**
     * Array of characters available in alphanumeric mode
     *
     * As per QR Code specification, to each character
     * is assigned a value from 0 to 44 which in this case coincides
     * with the array index
     *
     * @type {Array}
     */


    const ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];

    function AlphanumericData(data) {
      this.mode = Mode$3.ALPHANUMERIC;
      this.data = data;
    }

    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };

    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };

    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };

    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i; // Input data characters are divided into groups of two characters
      // and encoded as 11-bit binary codes.

      for (i = 0; i + 2 <= this.data.length; i += 2) {
        // The character value of the first character is multiplied by 45
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45; // The character value of the second digit is added to the product

        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]); // The sum is then stored as 11-bit binary number

        bitBuffer.put(value, 11);
      } // If the number of input data characters is not a multiple of two,
      // the character value of the final character is encoded as a 6-bit binary number.


      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };

    var alphanumericData = AlphanumericData;

    var encodeUtf8$1 = function encodeUtf8(input) {
      var result = [];
      var size = input.length;

      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);

        if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {
          var second = input.charCodeAt(index + 1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            index += 1;
          }
        } // US-ASCII


        if (point < 0x80) {
          result.push(point);
          continue;
        } // 2-byte UTF-8


        if (point < 0x800) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        } // 3-byte UTF-8


        if (point < 0xD800 || point >= 0xE000 && point < 0x10000) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        } // 4-byte UTF-8


        if (point >= 0x10000 && point <= 0x10FFFF) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        } // Invalid character


        result.push(0xEF, 0xBF, 0xBD);
      }

      return new Uint8Array(result).buffer;
    };

    const encodeUtf8 = encodeUtf8$1;

    const Mode$2 = mode;

    function ByteData(data) {
      this.mode = Mode$2.BYTE;
      this.data = new Uint8Array(encodeUtf8(data));
    }

    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };

    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };

    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };

    ByteData.prototype.write = function (bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };

    var byteData = ByteData;

    const Mode$1 = mode;

    const Utils$2 = utils$1;

    function KanjiData(data) {
      this.mode = Mode$1.KANJI;
      this.data = data;
    }

    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };

    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };

    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };

    KanjiData.prototype.write = function (bitBuffer) {
      let i; // In the Shift JIS system, Kanji characters are represented by a two byte combination.
      // These byte values are shifted from the JIS X 0208 values.
      // JIS X 0208 gives details of the shift coded representation.

      for (i = 0; i < this.data.length; i++) {
        let value = Utils$2.toSJIS(this.data[i]); // For characters with Shift JIS values from 0x8140 to 0x9FFC:

        if (value >= 0x8140 && value <= 0x9FFC) {
          // Subtract 0x8140 from Shift JIS value
          value -= 0x8140; // For characters with Shift JIS values from 0xE040 to 0xEBBF
        } else if (value >= 0xE040 && value <= 0xEBBF) {
          // Subtract 0xC140 from Shift JIS value
          value -= 0xC140;
        } else {
          throw new Error('Invalid SJIS character: ' + this.data[i] + '\n' + 'Make sure your charset is UTF-8');
        } // Multiply most significant byte of result by 0xC0
        // and add least significant byte to product


        value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff); // Convert result to a 13-bit binary string

        bitBuffer.put(value, 13);
      }
    };

    var kanjiData = KanjiData;

    var dijkstra = {exports: {}};

    (function (module) {
    /******************************************************************************
     * Created 2008-08-19.
     *
     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
     *
     * Copyright (C) 2008
     *   Wyatt Baldwin <self@wyattbaldwin.com>
     *   All rights reserved
     *
     * Licensed under the MIT license.
     *
     *   http://www.opensource.org/licenses/mit-license.php
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *****************************************************************************/

    var dijkstra = {
      single_source_shortest_paths: function (graph, s, d) {
        // Predecessor map for each node that has been encountered.
        // node ID => predecessor node ID
        var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.
        // node ID => cost

        var costs = {};
        costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from
        // `costs` in that it provides easy access to the node that currently has
        // the known shortest path from s.
        // XXX: Do we actually need both `costs` and `open`?

        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;

        while (!open.empty()) {
          // In the nodes remaining in graph that have a known cost from s,
          // find the node, u, that currently has the shortest path from s.
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...

          adjacent_nodes = graph[u] || {}; // ...and explore the edges that connect u to those nodes, updating
          // the cost of the shortest paths to any or all of those nodes as
          // necessary. v is the node across the current edge from u.

          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              // Get the cost of the edge running from u to v.
              cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*
              // cost from s to v that may or may not be less than the current
              // known cost to v.

              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to
              // v is greater than the new cost we just found (cost of s to u plus
              // cost of u to v across e), update v's cost in the cost list and
              // update v's predecessor in the predecessor list (it's now u).

              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === 'undefined';

              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }

        if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
          var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
          throw new Error(msg);
        }

        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function (predecessors, d) {
        var nodes = [];
        var u = d;

        while (u) {
          nodes.push(u);
          u = predecessors[u];
        }

        nodes.reverse();
        return nodes;
      },
      find_path: function (graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
      },

      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function (opts) {
          var T = dijkstra.PriorityQueue,
              t = {},
              key;
          opts = opts || {};

          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }

          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function (a, b) {
          return a.cost - b.cost;
        },

        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function (value, cost) {
          var item = {
            value: value,
            cost: cost
          };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },

        /**
         * Return the highest priority element in the queue.
         */
        pop: function () {
          return this.queue.shift();
        },
        empty: function () {
          return this.queue.length === 0;
        }
      }
    }; // node.js module exports

    {
      module.exports = dijkstra;
    }
    }(dijkstra));

    (function (exports) {
    const Mode = mode;

    const NumericData = numericData;

    const AlphanumericData = alphanumericData;

    const ByteData = byteData;

    const KanjiData = kanjiData;

    const Regex = regex;

    const Utils = utils$1;

    const dijkstra$1 = dijkstra.exports;
    /**
     * Returns UTF8 byte length
     *
     * @param  {String} str Input string
     * @return {Number}     Number of byte
     */


    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    /**
     * Get a list of segments of the specified mode
     * from a string
     *
     * @param  {Mode}   mode Segment mode
     * @param  {String} str  String to process
     * @return {Array}       Array of object with segments data
     */


    function getSegments(regex, mode, str) {
      const segments = [];
      let result;

      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode: mode,
          length: result[0].length
        });
      }

      return segments;
    }
    /**
     * Extracts a series of segments with the appropriate
     * modes from a string
     *
     * @param  {String} dataStr Input string
     * @return {Array}          Array of object with segments data
     */


    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;

      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }

      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function (s1, s2) {
        return s1.index - s2.index;
      }).map(function (obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    /**
     * Returns how many bits are needed to encode a string of
     * specified length with the specified mode
     *
     * @param  {Number} length String length
     * @param  {Mode} mode     Segment mode
     * @return {Number}        Bit length
     */


    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);

        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);

        case Mode.KANJI:
          return KanjiData.getBitsLength(length);

        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    /**
     * Merges adjacent segments which have the same mode
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */


    function mergeSegments(segs) {
      return segs.reduce(function (acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;

        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }

        acc.push(curr);
        return acc;
      }, []);
    }
    /**
     * Generates a list of all possible nodes combination which
     * will be used to build a segments graph.
     *
     * Nodes are divided by groups. Each group will contain a list of all the modes
     * in which is possible to encode the given text.
     *
     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
     * The group for '12345' will contain then 3 objects, one for each
     * possible encoding mode.
     *
     * Each node represents a possible segment.
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */


    function buildNodes(segs) {
      const nodes = [];

      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];

        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.ALPHANUMERIC,
              length: seg.length
            }, {
              data: seg.data,
              mode: Mode.BYTE,
              length: seg.length
            }]);
            break;

          case Mode.ALPHANUMERIC:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.BYTE,
              length: seg.length
            }]);
            break;

          case Mode.KANJI:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.BYTE,
              length: getStringByteLength(seg.data)
            }]);
            break;

          case Mode.BYTE:
            nodes.push([{
              data: seg.data,
              mode: Mode.BYTE,
              length: getStringByteLength(seg.data)
            }]);
        }
      }

      return nodes;
    }
    /**
     * Builds a graph from a list of nodes.
     * All segments in each node group will be connected with all the segments of
     * the next group and so on.
     *
     * At each connection will be assigned a weight depending on the
     * segment's byte length.
     *
     * @param  {Array} nodes    Array of object with segments data
     * @param  {Number} version QR Code version
     * @return {Object}         Graph of all possible segments
     */


    function buildGraph(nodes, version) {
      const table = {};
      const graph = {
        start: {}
      };
      let prevNodeIds = ['start'];

      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];

        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = '' + i + j;
          currentNodeIds.push(key);
          table[key] = {
            node: node,
            lastCount: 0
          };
          graph[key] = {};

          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];

            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
            }
          }
        }

        prevNodeIds = currentNodeIds;
      }

      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }

      return {
        map: graph,
        table: table
      };
    }
    /**
     * Builds a segment from a specified data and mode.
     * If a mode is not specified, the more suitable will be used.
     *
     * @param  {String} data             Input data
     * @param  {Mode | String} modesHint Data mode
     * @return {Segment}                 Segment
     */


    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode); // Make sure data can be encoded

      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\n Suggested mode is: ' + Mode.toString(bestMode));
      } // Use Mode.BYTE if Kanji support is disabled


      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }

      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);

        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);

        case Mode.KANJI:
          return new KanjiData(data);

        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    /**
     * Builds a list of segments from an array.
     * Array can contain Strings or Objects with segment's info.
     *
     * For each item which is a string, will be generated a segment with the given
     * string and the more appropriate encoding mode.
     *
     * For each item which is an object, will be generated a segment with the given
     * data and mode.
     * Objects must contain at least the property "data".
     * If property "mode" is not present, the more suitable mode will be used.
     *
     * @param  {Array} array Array of objects with segments data
     * @return {Array}       Array of Segments
     */


    exports.fromArray = function fromArray(array) {
      return array.reduce(function (acc, seg) {
        if (typeof seg === 'string') {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }

        return acc;
      }, []);
    };
    /**
     * Builds an optimized sequence of segments from a string,
     * which will produce the shortest possible bitstream.
     *
     * @param  {String} data    Input string
     * @param  {Number} version QR Code version
     * @return {Array}          Array of segments
     */


    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra$1.find_path(graph.map, 'start', 'end');
      const optimizedSegs = [];

      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }

      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    /**
     * Splits a string in various segments with the modes which
     * best represent their content.
     * The produced segments are far from being optimized.
     * The output of this function is only used to estimate a QR Code version
     * which may contain the data.
     *
     * @param  {string} data Input string
     * @return {Array}       Array of segments
     */


    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
    }(segments));

    const Utils$1 = utils$1;

    const ECLevel = errorCorrectionLevel;

    const BitBuffer = bitBuffer;

    const BitMatrix = bitMatrix;

    const AlignmentPattern = alignmentPattern;

    const FinderPattern = finderPattern;

    const MaskPattern = maskPattern;

    const ECCode = errorCorrectionCode;

    const ReedSolomonEncoder = reedSolomonEncoder;

    const Version = version;

    const FormatInfo = formatInfo;

    const Mode = mode;

    const Segments = segments;
    /**
     * QRCode for JavaScript
     *
     * modified by Ryan Day for nodejs support
     * Copyright (c) 2011 Ryan Day
     *
     * Licensed under the MIT license:
     *   http://www.opensource.org/licenses/mit-license.php
     *
    //---------------------------------------------------------------------
    // QRCode for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //   http://www.opensource.org/licenses/mit-license.php
    //
    // The word "QR Code" is registered trademark of
    // DENSO WAVE INCORPORATED
    //   http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    */

    /**
     * Add finder patterns bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */


    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;

          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue;

            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    /**
     * Add timing pattern bits to matrix
     *
     * Note: this function must be called before {@link setupAlignmentPattern}
     *
     * @param  {BitMatrix} matrix Modules matrix
     */


    function setupTimingPattern(matrix) {
      const size = matrix.size;

      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    /**
     * Add alignment patterns bits to matrix
     *
     * Note: this function must be called after {@link setupTimingPattern}
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */


    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    /**
     * Add version info bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */


    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;

      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    /**
     * Add format info bits to matrix
     *
     * @param  {BitMatrix} matrix               Modules matrix
     * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
     * @param  {Number}    maskPattern          Mask pattern reference value
     */


    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;

      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1; // vertical

        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        } // horizontal


        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      } // fixed module


      matrix.set(size - 8, 8, 1, true);
    }
    /**
     * Add encoded data bits to matrix
     *
     * @param  {BitMatrix}  matrix Modules matrix
     * @param  {Uint8Array} data   Data codewords
     */


    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;

      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;

        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;

              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }

              matrix.set(row, col - c, dark);
              bitIndex--;

              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    /**
     * Create encoded codewords from data input
     *
     * @param  {Number}   version              QR Code version
     * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
     * @param  {ByteData} data                 Data input
     * @return {Uint8Array}                    Buffer containing encoded codewords
     */


    function createData(version, errorCorrectionLevel, segments) {
      // Prepare data buffer
      const buffer = new BitBuffer();
      segments.forEach(function (data) {
        // prefix data with mode indicator (4 bits)
        buffer.put(data.mode.bit, 4); // Prefix data with character count indicator.
        // The character count indicator is a string of bits that represents the
        // number of characters that are being encoded.
        // The character count indicator must be placed after the mode indicator
        // and must be a certain number of bits long, depending on the QR version
        // and data mode
        // @see {@link Mode.getCharCountIndicator}.

        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version)); // add binary data sequence to buffer

        data.write(buffer);
      }); // Calculate required number of bits

      const totalCodewords = Utils$1.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8; // Add a terminator.
      // If the bit string is shorter than the total number of required bits,
      // a terminator of up to four 0s must be added to the right side of the string.
      // If the bit string is more than four bits shorter than the required number of bits,
      // add four 0s to the end.

      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      } // If the bit string is fewer than four bits shorter, add only the number of 0s that
      // are needed to reach the required number of bits.
      // After adding the terminator, if the number of bits in the string is not a multiple of 8,
      // pad the string on the right with 0s to make the string's length a multiple of 8.


      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      } // Add pad bytes if the string is still shorter than the total number of required bits.
      // Extend the buffer to fill the data capacity of the symbol corresponding to
      // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
      // and 00010001 (0x11) alternately.


      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;

      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 0x11 : 0xEC, 8);
      }

      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    /**
     * Encode input data with Reed-Solomon and return codewords with
     * relative error correction bits
     *
     * @param  {BitBuffer} bitBuffer            Data to encode
     * @param  {Number}    version              QR Code version
     * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
     * @return {Uint8Array}                     Buffer containing encoded codewords
     */


    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      // Total codewords for this QR code version (Data + Error correction)
      const totalCodewords = Utils$1.getSymbolTotalCodewords(version); // Total number of error correction codewords

      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords

      const dataTotalCodewords = totalCodewords - ecTotalCodewords; // Total number of blocks

      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel); // Calculate how many blocks each group should contain

      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1; // Number of EC codewords is the same for both groups

      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1; // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount

      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer); // Divide the buffer into the required number of blocks

      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2; // extract a block of data from buffer

        dcData[b] = buffer.slice(offset, offset + dataSize); // Calculate EC codewords for this data block

        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      } // Create final data
      // Interleave the data and error correction codewords from each block


      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r; // Add data codewords

      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      } // Apped EC codewords


      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }

      return data;
    }
    /**
     * Build QR Code symbol
     *
     * @param  {String} data                 Input string
     * @param  {Number} version              QR Code version
     * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
     * @param  {MaskPattern} maskPattern     Mask pattern
     * @return {Object}                      Object containing symbol data
     */


    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;

      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === 'string') {
        let estimatedVersion = version;

        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data); // Estimate best version that can contain raw splitted segments

          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        } // Build optimized segments
        // If estimated version is undefined, try with the highest version


        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error('Invalid data');
      } // Get the min version that can contain data


      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel); // If no version is found, data cannot be stored

      if (!bestVersion) {
        throw new Error('The amount of data is too big to be stored in a QR Code');
      } // If not specified, use min version as default


      if (!version) {
        version = bestVersion; // Check if the specified version can contain the data
      } else if (version < bestVersion) {
        throw new Error('\n' + 'The chosen QR Code version cannot contain this amount of data.\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\n');
      }

      const dataBits = createData(version, errorCorrectionLevel, segments); // Allocate matrix buffer

      const moduleCount = Utils$1.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount); // Add function modules

      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version); // Add temporary dummy bits for format info just to set them as reserved.
      // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
      // since the masking operation must be performed only on the encoding region.
      // These blocks will be replaced with correct values later in code.

      setupFormatInfo(modules, errorCorrectionLevel, 0);

      if (version >= 7) {
        setupVersionInfo(modules, version);
      } // Add data codewords


      setupData(modules, dataBits);

      if (isNaN(maskPattern)) {
        // Find best mask pattern
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      } // Apply mask pattern


      MaskPattern.applyMask(maskPattern, modules); // Replace format info bits with correct values

      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules: modules,
        version: version,
        errorCorrectionLevel: errorCorrectionLevel,
        maskPattern: maskPattern,
        segments: segments
      };
    }
    /**
     * QR Code
     *
     * @param {String | Array} data                 Input data
     * @param {Object} options                      Optional configurations
     * @param {Number} options.version              QR Code version
     * @param {String} options.errorCorrectionLevel Error correction level
     * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
     */


    qrcode.create = function create(data, options) {
      if (typeof data === 'undefined' || data === '') {
        throw new Error('No input text');
      }

      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;

      if (typeof options !== 'undefined') {
        // Use higher error correction level as default
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);

        if (options.toSJISFunc) {
          Utils$1.setToSJISFunction(options.toSJISFunc);
        }
      }

      return createSymbol(data, version, errorCorrectionLevel, mask);
    };

    var canvas = {};

    var utils = {};

    (function (exports) {
    function hex2rgba(hex) {
      if (typeof hex === 'number') {
        hex = hex.toString();
      }

      if (typeof hex !== 'string') {
        throw new Error('Color should be defined as hex string');
      }

      let hexCode = hex.slice().replace('#', '').split('');

      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error('Invalid hex color: ' + hex);
      } // Convert from short to long form (fff -> ffffff)


      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
          return [c, c];
        }));
      } // Add default alpha value


      if (hexCode.length === 6) hexCode.push('F', 'F');
      const hexValue = parseInt(hexCode.join(''), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: '#' + hexCode.slice(0, 6).join('')
      };
    }

    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : undefined;
      const scale = options.scale || 4;
      return {
        width: width,
        scale: width ? 4 : scale,
        margin: margin,
        color: {
          dark: hex2rgba(options.color.dark || '#000000ff'),
          light: hex2rgba(options.color.light || '#ffffffff')
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };

    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };

    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };

    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];

      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;

          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }

          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
    }(utils));

    (function (exports) {
    const Utils = utils;

    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + 'px';
      canvas.style.width = size + 'px';
    }

    function getCanvasElement() {
      try {
        return document.createElement('canvas');
      } catch (e) {
        throw new Error('You need to specify a canvas element');
      }
    }

    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!canvas) {
        canvasEl = getCanvasElement();
      }

      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext('2d');
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };

    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || 'image/png';
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
    }(canvas));

    var svgTag = {};

    const Utils = utils;

    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }

    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== 'undefined') str += ' ' + y;
      return str;
    }

    function qrToPath(data, size, margin) {
      let path = '';
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;

      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;

        if (data[i]) {
          lineLength++;

          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);
            moveBy = 0;
            newRow = false;
          }

          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd('h', lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }

      return path;
    }

    svgTag.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';
      const path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';
      const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

      if (typeof cb === 'function') {
        cb(null, svgTag);
      }

      return svgTag;
    };

    const canPromise = canPromise$1;

    const QRCode = qrcode;

    const CanvasRenderer = canvas;

    const SvgRenderer = svgTag;

    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === 'function';

      if (!isLastArgCb && !canPromise()) {
        throw new Error('Callback required as last argument');
      }

      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error('Too few arguments provided');
        }

        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === 'undefined') {
            cb = opts;
            opts = undefined;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = undefined;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error('Too few arguments provided');
        }

        if (argsNum === 1) {
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = undefined;
        }

        return new Promise(function (resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }

      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }

    browser.create = QRCode.create;
    browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL); // only svg for now.

    browser.toString = renderCanvas.bind(null, function (data, _, opts) {
      return SvgRenderer.render(data, opts);
    });

    /* src/components/DonationOverlay.svelte generated by Svelte v3.44.3 */
    const {
      console: console_1
    } = globals;
    const file$a = "src/components/DonationOverlay.svelte";

    function get_each_context$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[68] = list[i];
      child_ctx[70] = i;
      return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[71] = list[i];
      return child_ctx;
    } // (447:10) {#each tierThresholds as tier}


    function create_each_block_1$1(ctx) {
      let tiercard;
      let current;
      const tiercard_spread_levels = [
      /*tier*/
      ctx[71], {
        active:
        /*btc*/
        ctx[10] >=
        /*tier*/
        ctx[71].min &&
        /*btc*/
        ctx[10] <
        /*tier*/
        ctx[71].max
      }];

      function click_handler() {
        return (
          /*click_handler*/
          ctx[42](
          /*tier*/
          ctx[71])
        );
      }

      let tiercard_props = {};

      for (let i = 0; i < tiercard_spread_levels.length; i += 1) {
        tiercard_props = assign(tiercard_props, tiercard_spread_levels[i]);
      }

      tiercard = new TierCard({
        props: tiercard_props,
        $$inline: true
      });
      tiercard.$on("click", click_handler);
      const block = {
        c: function create() {
          create_component(tiercard.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(tiercard, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const tiercard_changes = dirty[0] &
          /*tierThresholds, btc*/
          4195328 ? get_spread_update(tiercard_spread_levels, [dirty[0] &
          /*tierThresholds*/
          4194304 && get_spread_object(
          /*tier*/
          ctx[71]), {
            active:
            /*btc*/
            ctx[10] >=
            /*tier*/
            ctx[71].min &&
            /*btc*/
            ctx[10] <
            /*tier*/
            ctx[71].max
          }]) : {};
          tiercard.$set(tiercard_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiercard.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiercard.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(tiercard, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$1.name,
        type: "each",
        source: "(447:10) {#each tierThresholds as tier}",
        ctx
      });
      return block;
    } // (461:12) {:else}


    function create_else_block_3(ctx) {
      let input;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          input = element("input");
          attr_dev(input, "type", "number");
          input.value =
          /*btc*/
          ctx[10];
          attr_dev(input, "step", "0.0001");
          attr_dev(input, "min", "0.000001");
          attr_dev(input, "class", "svelte-ae07vc");
          add_location(input, file$a, 461, 14, 13637);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_handler_2*/
            ctx[45], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*btc*/
          1024 && input.value !==
          /*btc*/
          ctx[10]) {
            prop_dev(input, "value",
            /*btc*/
            ctx[10]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_3.name,
        type: "else",
        source: "(461:12) {:else}",
        ctx
      });
      return block;
    } // (459:12) {#if unit === 'sats'}


    function create_if_block_12$1(ctx) {
      let input;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          input = element("input");
          attr_dev(input, "type", "number");
          input.value =
          /*sats*/
          ctx[9];
          attr_dev(input, "step", "100");
          attr_dev(input, "min", "100");
          attr_dev(input, "class", "svelte-ae07vc");
          add_location(input, file$a, 459, 14, 13492);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_handler_1*/
            ctx[44], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*sats*/
          512 && input.value !==
          /*sats*/
          ctx[9]) {
            prop_dev(input, "value",
            /*sats*/
            ctx[9]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12$1.name,
        type: "if",
        source: "(459:12) {#if unit === 'sats'}",
        ctx
      });
      return block;
    } // (470:8) {#if $tiers && btc >= $tiers.hero.min}


    function create_if_block_9$1(ctx) {
      let t0;
      let div2;
      let div1;
      let label;
      let t2;
      let div0;
      let span0;
      let icon;
      let t3;
      let span1;
      let t5;
      let input;
      let t6;
      let current;
      let mounted;
      let dispose;

      function select_block_type_1(ctx, dirty) {
        if (
        /*btc*/
        ctx[10] >=
        /*$tiers*/
        ctx[6].sponsor.min) return create_if_block_11$1;
        return create_else_block_2;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block0 = current_block_type(ctx);
      icon = new Icon({
        props: {
          icon: twitterIcon,
          inline: true
        },
        $$inline: true
      });
      let if_block1 =
      /*btc*/
      ctx[10] >=
      /*$tiers*/
      ctx[6].sponsor.min && create_if_block_10$1(ctx);
      const block = {
        c: function create() {
          if_block0.c();
          t0 = space();
          div2 = element("div");
          div1 = element("div");
          label = element("label");
          label.textContent = "Twitter";
          t2 = space();
          div0 = element("div");
          span0 = element("span");
          create_component(icon.$$.fragment);
          t3 = space();
          span1 = element("span");
          span1.textContent = "@";
          t5 = space();
          input = element("input");
          t6 = space();
          if (if_block1) if_block1.c();
          attr_dev(label, "for", "twitterHandle");
          add_location(label, file$a, 483, 14, 14563);
          attr_dev(span0, "class", "icon-wrapper svelte-ae07vc");
          add_location(span0, file$a, 485, 16, 14678);
          attr_dev(span1, "class", "prefix svelte-ae07vc");
          add_location(span1, file$a, 486, 16, 14763);
          attr_dev(input, "id", "twitterHandle");
          attr_dev(input, "type", "text");
          attr_dev(input, "class", "svelte-ae07vc");
          add_location(input, file$a, 487, 16, 14809);
          attr_dev(div0, "class", "text-input twitter prefixed svelte-ae07vc");
          add_location(div0, file$a, 484, 14, 14620);
          attr_dev(div1, "class", "field svelte-ae07vc");
          add_location(div1, file$a, 482, 12, 14529);
          attr_dev(div2, "class", "donor-info-form svelte-ae07vc");
          add_location(div2, file$a, 481, 10, 14487);
        },
        m: function mount(target, anchor) {
          if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, div1);
          append_dev(div1, label);
          append_dev(div1, t2);
          append_dev(div1, div0);
          append_dev(div0, span0);
          mount_component(icon, span0, null);
          append_dev(div0, t3);
          append_dev(div0, span1);
          append_dev(div0, t5);
          append_dev(div0, input);
          set_input_value(input,
          /*twitter*/
          ctx[11]);
          append_dev(div2, t6);
          if (if_block1) if_block1.m(div2, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler*/
            ctx[46]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          }

          if (dirty[0] &
          /*twitter*/
          2048 && input.value !==
          /*twitter*/
          ctx[11]) {
            set_input_value(input,
            /*twitter*/
            ctx[11]);
          }

          if (
          /*btc*/
          ctx[10] >=
          /*$tiers*/
          ctx[6].sponsor.min) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*btc, $tiers*/
              1088) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_10$1(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div2, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if_block0.d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div2);
          destroy_component(icon);
          if (if_block1) if_block1.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9$1.name,
        type: "if",
        source: "(470:8) {#if $tiers && btc >= $tiers.hero.min}",
        ctx
      });
      return block;
    } // (475:10) {:else}


    function create_else_block_2(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "Enter your twitter handle to be added to our Heroes Hall of Fame! Or leave this field blank to donate anonymously.";
          attr_dev(p, "class", "credit-info");
          add_location(p, file$a, 475, 12, 14289);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2.name,
        type: "else",
        source: "(475:10) {:else}",
        ctx
      });
      return block;
    } // (471:10) {#if btc >= $tiers.sponsor.min}


    function create_if_block_11$1(ctx) {
      let p;
      const block = {
        c: function create() {
          p = element("p");
          p.textContent = "Enter your email or twitter handle so we can reach you to say thanks and confirm sponsorship details! Or leave these fields blank to donate anonymously.";
          attr_dev(p, "class", "credit-info");
          add_location(p, file$a, 471, 12, 14051);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11$1.name,
        type: "if",
        source: "(471:10) {#if btc >= $tiers.sponsor.min}",
        ctx
      });
      return block;
    } // (491:12) {#if btc >= $tiers.sponsor.min}


    function create_if_block_10$1(ctx) {
      let div1;
      let label;
      let t1;
      let div0;
      let span;
      let icon;
      let t2;
      let input;
      let current;
      let mounted;
      let dispose;
      icon = new Icon({
        props: {
          icon: emailIcon,
          inline: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div1 = element("div");
          label = element("label");
          label.textContent = "Email";
          t1 = space();
          div0 = element("div");
          span = element("span");
          create_component(icon.$$.fragment);
          t2 = space();
          input = element("input");
          attr_dev(label, "for", "twitterHandle");
          add_location(label, file$a, 492, 16, 15003);
          attr_dev(span, "class", "icon-wrapper svelte-ae07vc");
          add_location(span, file$a, 494, 18, 15115);
          attr_dev(input, "id", "emailAddress");
          attr_dev(input, "type", "email");
          attr_dev(input, "class", "svelte-ae07vc");
          add_location(input, file$a, 495, 18, 15200);
          attr_dev(div0, "class", "text-input email-input svelte-ae07vc");
          add_location(div0, file$a, 493, 16, 15060);
          attr_dev(div1, "class", "field svelte-ae07vc");
          add_location(div1, file$a, 491, 14, 14967);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, label);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div0, span);
          mount_component(icon, span, null);
          append_dev(div0, t2);
          append_dev(div0, input);
          set_input_value(input,
          /*email*/
          ctx[12]);
          current = true;

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler_1*/
            ctx[47]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*email*/
          4096 && input.value !==
          /*email*/
          ctx[12]) {
            set_input_value(input,
            /*email*/
            ctx[12]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(icon);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10$1.name,
        type: "if",
        source: "(491:12) {#if btc >= $tiers.sponsor.min}",
        ctx
      });
      return block;
    } // (508:10) {:else}


    function create_else_block_1$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Request an invoice");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$1.name,
        type: "else",
        source: "(508:10) {:else}",
        ctx
      });
      return block;
    } // (506:43) 


    function create_if_block_8$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Request a new invoice");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$1.name,
        type: "if",
        source: "(506:43) ",
        ctx
      });
      return block;
    } // (504:10) {#if waitingForInvoice }


    function create_if_block_7$1(ctx) {
      let span;
      let icon;
      let t;
      let current;
      icon = new Icon({
        props: {
          icon: spinnerIcon
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          t = text(" loading");
          attr_dev(span, "class", "animate-spin spinner svelte-ae07vc");
          add_location(span, file$a, 504, 12, 15466);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          insert_dev(target, t, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$1.name,
        type: "if",
        source: "(504:10) {#if waitingForInvoice }",
        ctx
      });
      return block;
    } // (516:12) 


    function create_left_slot(ctx) {
      let span;
      let icon;
      let t;
      let current;
      icon = new Icon({
        props: {
          icon: chainIcon,
          inline: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          t = text(" On-Chain");
          attr_dev(span, "slot", "left");
          add_location(span, file$a, 515, 12, 15930);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          append_dev(span, t);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_left_slot.name,
        type: "slot",
        source: "(516:12) ",
        ctx
      });
      return block;
    } // (517:12) 


    function create_right_slot(ctx) {
      let span;
      let icon;
      let t;
      let current;
      icon = new Icon({
        props: {
          icon: boltIcon,
          inline: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(icon.$$.fragment);
          t = text(" Lightning");
          attr_dev(span, "slot", "right");
          add_location(span, file$a, 516, 12, 16009);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(icon, span, null);
          append_dev(span, t);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_right_slot.name,
        type: "slot",
        source: "(517:12) ",
        ctx
      });
      return block;
    } // (523:12) {#if invoicePaidLabel}


    function create_if_block_6$1(ctx) {
      let p;
      let span;
      let t1;
      let t2;
      const block = {
        c: function create() {
          p = element("p");
          span = element("span");
          span.textContent = "Total Received:";
          t1 = space();
          t2 = text(
          /*invoicePaidLabel*/
          ctx[15]);
          attr_dev(span, "class", "field-label svelte-ae07vc");
          add_location(span, file$a, 523, 44, 16409);
          attr_dev(p, "class", "field invoice-paid svelte-ae07vc");
          add_location(p, file$a, 523, 14, 16379);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, span);
          append_dev(p, t1);
          append_dev(p, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*invoicePaidLabel*/
          32768) set_data_dev(t2,
          /*invoicePaidLabel*/
          ctx[15]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$1.name,
        type: "if",
        source: "(523:12) {#if invoicePaidLabel}",
        ctx
      });
      return block;
    } // (526:12) {#if invoicePayments && invoicePayments.length}


    function create_if_block_5$1(ctx) {
      let ul;
      let each_value =
      /*invoicePayments*/
      ctx[21];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(ul, "class", "payments");
          add_location(ul, file$a, 526, 12, 16573);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*invoicePayments, invoiceUnit*/
          2097160) {
            each_value =
            /*invoicePayments*/
            ctx[21];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$3(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$1.name,
        type: "if",
        source: "(526:12) {#if invoicePayments && invoicePayments.length}",
        ctx
      });
      return block;
    } // (528:14) {#each invoicePayments as payment, index }


    function create_each_block$3(ctx) {
      let li;
      let t0;
      let t1_value =
      /*index*/
      ctx[70] + 1 + "";
      let t1;
      let t2;
      let t3_value = amountToLabel(
      /*payment*/
      ctx[68].value,
      /*invoiceUnit*/
      ctx[3]) + "";
      let t3;
      let t4;
      let t5_value =
      /*payment*/
      ctx[68].status + "";
      let t5;
      let t6;
      const block = {
        c: function create() {
          li = element("li");
          t0 = text("Payment #");
          t1 = text(t1_value);
          t2 = text(": ");
          t3 = text(t3_value);
          t4 = text(" (");
          t5 = text(t5_value);
          t6 = text(")");
          attr_dev(li, "class", "field payment-status svelte-ae07vc");
          add_location(li, file$a, 528, 16, 16668);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, t2);
          append_dev(li, t3);
          append_dev(li, t4);
          append_dev(li, t5);
          append_dev(li, t6);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*invoicePayments, invoiceUnit*/
          2097160 && t3_value !== (t3_value = amountToLabel(
          /*payment*/
          ctx[68].value,
          /*invoiceUnit*/
          ctx[3]) + "")) set_data_dev(t3, t3_value);
          if (dirty[0] &
          /*invoicePayments*/
          2097152 && t5_value !== (t5_value =
          /*payment*/
          ctx[68].status + "")) set_data_dev(t5, t5_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$3.name,
        type: "each",
        source: "(528:14) {#each invoicePayments as payment, index }",
        ctx
      });
      return block;
    } // (535:12) {#if showCopyButton}


    function create_if_block_3$1(ctx) {
      let button;
      let icon;
      let t;
      let current;
      let mounted;
      let dispose;
      icon = new Icon({
        props: {
          icon: clipboardIcon,
          color: "var(--palette-x)"
        },
        $$inline: true
      });
      let if_block =
      /*copied*/
      ctx[25] && create_if_block_4$1(ctx);
      const block = {
        c: function create() {
          button = element("button");
          create_component(icon.$$.fragment);
          t = space();
          if (if_block) if_block.c();
          attr_dev(button, "class", "copy-button svelte-ae07vc");
          attr_dev(button, "title", "Copy to clipboard");
          attr_dev(button, "alt", "Copy to clipboard");
          add_location(button, file$a, 535, 14, 17210);
        },
        m: function mount(target, anchor) {
          insert_dev(target, button, anchor);
          mount_component(icon, button, null);
          append_dev(button, t);
          if (if_block) if_block.m(button, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(button, "click",
            /*copyInvoice*/
            ctx[35], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (
          /*copied*/
          ctx[25]) {
            if (if_block) {
              if (dirty[0] &
              /*copied*/
              33554432) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_4$1(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(button, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(button);
          destroy_component(icon);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$1.name,
        type: "if",
        source: "(535:12) {#if showCopyButton}",
        ctx
      });
      return block;
    } // (538:16) {#if copied }


    function create_if_block_4$1(ctx) {
      let span;
      let span_transition;
      let current;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "Copied to clipboard!";
          attr_dev(span, "class", "copy-notif svelte-ae07vc");
          add_location(span, file$a, 538, 18, 17431);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!span_transition) span_transition = create_bidirectional_transition(span, fly, {
              y: -5
            }, true);
            span_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!span_transition) span_transition = create_bidirectional_transition(span, fly, {
            y: -5
          }, false);
          span_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching && span_transition) span_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$1.name,
        type: "if",
        source: "(538:16) {#if copied }",
        ctx
      });
      return block;
    } // (543:12) {#if !invoice || !invoice.id || !invoiceHexLabel }


    function create_if_block_2$2(ctx) {
      let div;
      let p;
      let div_transition;
      let current;
      const block = {
        c: function create() {
          div = element("div");
          p = element("p");
          p.textContent = "Payment Details";
          attr_dev(p, "class", "placeholder-label svelte-ae07vc");
          add_location(p, file$a, 544, 16, 17738);
          attr_dev(div, "class", "placeholder-overlay svelte-ae07vc");
          add_location(div, file$a, 543, 14, 17652);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
              duration: 300
            }, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
            duration: 300
          }, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$2.name,
        type: "if",
        source: "(543:12) {#if !invoice || !invoice.id || !invoiceHexLabel }",
        ctx
      });
      return block;
    } // (554:12) {:else}


    function create_else_block$3(ctx) {
      let div;
      let icon;
      let current;
      icon = new Icon({
        props: {
          icon: boltIcon,
          color: "white"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(icon.$$.fragment);
          attr_dev(div, "class", "invoice-icon svelte-ae07vc");
          add_location(div, file$a, 554, 14, 18127);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(icon, div, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$3.name,
        type: "else",
        source: "(554:12) {:else}",
        ctx
      });
      return block;
    } // (551:12) {#if invoiceExpired}


    function create_if_block_1$3(ctx) {
      let div;
      let icon;
      let t0;
      let h3;
      let current;
      icon = new Icon({
        props: {
          icon: timerIcon,
          color: "white"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(icon.$$.fragment);
          t0 = space();
          h3 = element("h3");
          h3.textContent = "Invoice Expired";
          attr_dev(div, "class", "invoice-icon svelte-ae07vc");
          add_location(div, file$a, 551, 14, 17959);
          attr_dev(h3, "class", "invoice-status svelte-ae07vc");
          add_location(h3, file$a, 552, 14, 18045);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(icon, div, null);
          insert_dev(target, t0, anchor);
          insert_dev(target, h3, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(icon);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$3.name,
        type: "if",
        source: "(551:12) {#if invoiceExpired}",
        ctx
      });
      return block;
    } // (557:12) {#if qrSrc && !invoicePaid && !invoiceExpired}


    function create_if_block$6(ctx) {
      let div;
      let img;
      let img_src_value;
      const block = {
        c: function create() {
          div = element("div");
          img = element("img");
          if (!src_url_equal(img.src, img_src_value =
          /*qrSrc*/
          ctx[20])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "class", "qr-image svelte-ae07vc");
          attr_dev(img, "alt", "invoice qr code");
          add_location(img, file$a, 558, 16, 18336);
          attr_dev(div, "class", "qr-image-wrapper svelte-ae07vc");
          add_location(div, file$a, 557, 14, 18289);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, img);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*qrSrc*/
          1048576 && !src_url_equal(img.src, img_src_value =
          /*qrSrc*/
          ctx[20])) {
            attr_dev(img, "src", img_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(557:12) {#if qrSrc && !invoicePaid && !invoiceExpired}",
        ctx
      });
      return block;
    } // (426:0) <Overlay name="donation" fullSize on:close={onClose}>


    function create_default_slot$1(ctx) {
      let section;
      let div0;
      let button0;
      let t1;
      let h2;
      let t3;
      let button1;
      let t5;
      let div15;
      let div6;
      let p0;
      let t7;
      let p1;
      let t9;
      let p2;
      let t11;
      let div1;
      let t12;
      let div5;
      let div2;
      let satoshislider;
      let t13;
      let div3;
      let t14;
      let div4;
      let pill0;
      let t15;
      let t16;
      let button2;
      let current_block_type_index;
      let if_block2;
      let t17;
      let div11;
      let div7;
      let pill1;
      let t18;
      let div10;
      let div8;
      let p3;
      let span0;
      let t20;
      let t21;
      let t22;
      let t23;
      let t24;
      let p4;
      let span1;
      let t26;
      let t27;
      let t28;
      let p5;
      let span2;
      let t29;
      let t30;
      let t31;
      let span3;
      let t32_value = (
      /*invoiceHexLabel*/
      ctx[19] || invoiceHexPlaceholder) + "";
      let t32;
      let t33;
      let t34;
      let t35;
      let div9;
      let current_block_type_index_1;
      let if_block7;
      let t36;
      let t37;
      let button3;
      let t39;
      let div14;
      let div13;
      let h30;
      let t41;
      let div12;
      let icon;
      let t42;
      let h31;
      let div15_class_value;
      let current;
      let mounted;
      let dispose;
      let each_value_1 =
      /*tierThresholds*/
      ctx[22];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      satoshislider = new SatoshiSlider({
        props: {
          value:
          /*sats*/
          ctx[9],
          max: btcToSats(1),
          thresholds:
          /*tierThresholds*/
          ctx[22],
          logScale: true
        },
        $$inline: true
      });
      satoshislider.$on("input",
      /*input_handler*/
      ctx[43]);

      function select_block_type(ctx, dirty) {
        if (
        /*unit*/
        ctx[8] === 'sats') return create_if_block_12$1;
        return create_else_block_3;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);
      pill0 = new Pill({
        props: {
          left: "sats",
          right: "btc",
          active:
          /*unit*/
          ctx[8] === 'btc'
        },
        $$inline: true
      });
      pill0.$on("click",
      /*toggleUnits*/
      ctx[34]);
      let if_block1 =
      /*$tiers*/
      ctx[6] &&
      /*btc*/
      ctx[10] >=
      /*$tiers*/
      ctx[6].hero.min && create_if_block_9$1(ctx);
      const if_block_creators = [create_if_block_7$1, create_if_block_8$1, create_else_block_1$1];
      const if_blocks = [];

      function select_block_type_2(ctx, dirty) {
        if (
        /*waitingForInvoice*/
        ctx[7]) return 0;
        if (
        /*invoice*/
        ctx[2] &&
        /*invoice*/
        ctx[2].id) return 1;
        return 2;
      }

      current_block_type_index = select_block_type_2(ctx);
      if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      pill1 = new Pill({
        props: {
          leftDisabled: !
          /*canPayOnChain*/
          ctx[4],
          rightDisabled: !
          /*canPayLightning*/
          ctx[5],
          active: !
          /*payOnChain*/
          ctx[1],
          $$slots: {
            right: [create_right_slot],
            left: [create_left_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      pill1.$on("click",
      /*togglePaymentMethod*/
      ctx[33]);
      let if_block3 =
      /*invoicePaidLabel*/
      ctx[15] && create_if_block_6$1(ctx);
      let if_block4 =
      /*invoicePayments*/
      ctx[21] &&
      /*invoicePayments*/
      ctx[21].length && create_if_block_5$1(ctx);
      let if_block5 =
      /*showCopyButton*/
      ctx[26] && create_if_block_3$1(ctx);
      let if_block6 = (!
      /*invoice*/
      ctx[2] || !
      /*invoice*/
      ctx[2].id || !
      /*invoiceHexLabel*/
      ctx[19]) && create_if_block_2$2(ctx);
      const if_block_creators_1 = [create_if_block_1$3, create_else_block$3];
      const if_blocks_1 = [];

      function select_block_type_3(ctx, dirty) {
        if (
        /*invoiceExpired*/
        ctx[14]) return 0;
        return 1;
      }

      current_block_type_index_1 = select_block_type_3(ctx);
      if_block7 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
      let if_block8 =
      /*qrSrc*/
      ctx[20] && !
      /*invoicePaid*/
      ctx[13] && !
      /*invoiceExpired*/
      ctx[14] && create_if_block$6(ctx);
      icon = new Icon({
        props: {
          icon: tickIcon,
          color: "white"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          section = element("section");
          div0 = element("div");
          button0 = element("button");
          button0.textContent = "←";
          t1 = space();
          h2 = element("h2");
          h2.textContent = "Support Bitfeed";
          t3 = space();
          button1 = element("button");
          button1.textContent = "→";
          t5 = space();
          div15 = element("div");
          div6 = element("div");
          p0 = element("p");
          p0.textContent = "Every satoshi helps to keep Bitfeed running and funds development of new features!";
          t7 = space();
          p1 = element("p");
          p1.textContent = "We accept donations in Bitcoin, either on-chain or over Lightning.";
          t9 = space();
          p2 = element("p");
          p2.textContent = "Choose your level of support:";
          t11 = space();
          div1 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t12 = space();
          div5 = element("div");
          div2 = element("div");
          create_component(satoshislider.$$.fragment);
          t13 = space();
          div3 = element("div");
          if_block0.c();
          t14 = space();
          div4 = element("div");
          create_component(pill0.$$.fragment);
          t15 = space();
          if (if_block1) if_block1.c();
          t16 = space();
          button2 = element("button");
          if_block2.c();
          t17 = space();
          div11 = element("div");
          div7 = element("div");
          create_component(pill1.$$.fragment);
          t18 = space();
          div10 = element("div");
          div8 = element("div");
          p3 = element("p");
          span0 = element("span");
          span0.textContent = "Amount:";
          t20 = space();
          t21 = text(
          /*invoiceAmountLabel*/
          ctx[16]);
          t22 = space();
          if (if_block3) if_block3.c();
          t23 = space();
          if (if_block4) if_block4.c();
          t24 = space();
          p4 = element("p");
          span1 = element("span");
          span1.textContent = "Expiry:";
          t26 = space();
          t27 = text(
          /*invoiceExpiryLabel*/
          ctx[17]);
          t28 = space();
          p5 = element("p");
          span2 = element("span");
          t29 = text(
          /*invoiceDestinationLabel*/
          ctx[18]);
          t30 = text(":");
          t31 = space();
          span3 = element("span");
          t32 = text(t32_value);
          t33 = space();
          if (if_block5) if_block5.c();
          t34 = space();
          if (if_block6) if_block6.c();
          t35 = space();
          div9 = element("div");
          if_block7.c();
          t36 = space();
          if (if_block8) if_block8.c();
          t37 = space();
          button3 = element("button");
          button3.textContent = "Start Over";
          t39 = space();
          div14 = element("div");
          div13 = element("div");
          h30 = element("h3");
          h30.textContent = "Confirmed";
          t41 = space();
          div12 = element("div");
          create_component(icon.$$.fragment);
          t42 = space();
          h31 = element("h3");
          h31.textContent = "Thank you!";
          attr_dev(button0, "class", "to left svelte-ae07vc");
          toggle_class(button0, "disabled", !
          /*canTabLeft*/
          ctx[23]);
          add_location(button0, file$a, 428, 6, 12248);
          add_location(h2, file$a, 429, 6, 12342);
          attr_dev(button1, "class", "to right svelte-ae07vc");
          toggle_class(button1, "disabled", !
          /*canTabRight*/
          ctx[24]);
          add_location(button1, file$a, 430, 6, 12373);
          attr_dev(div0, "class", "tab-nav svelte-ae07vc");
          add_location(div0, file$a, 427, 4, 12220);
          attr_dev(p0, "class", "info svelte-ae07vc");
          add_location(p0, file$a, 435, 8, 12553);
          attr_dev(p1, "class", "info svelte-ae07vc");
          add_location(p1, file$a, 438, 8, 12684);
          attr_dev(p2, "class", "info svelte-ae07vc");
          add_location(p2, file$a, 441, 8, 12799);
          attr_dev(div1, "class", "support-tiers svelte-ae07vc");
          add_location(div1, file$a, 445, 8, 12878);
          attr_dev(div2, "class", "amount-slider svelte-ae07vc");
          add_location(div2, file$a, 454, 10, 13222);
          attr_dev(div3, "class", "amount-input svelte-ae07vc");
          add_location(div3, file$a, 457, 10, 13417);
          attr_dev(div4, "class", "unit-picker svelte-ae07vc");
          add_location(div4, file$a, 464, 10, 13799);
          attr_dev(div5, "class", "choose-amount svelte-ae07vc");
          add_location(div5, file$a, 453, 8, 13184);
          attr_dev(button2, "class", "action-button");
          add_location(button2, file$a, 502, 8, 15360);
          attr_dev(div6, "class", "tab form svelte-ae07vc");
          add_location(div6, file$a, 434, 6, 12522);
          attr_dev(div7, "class", "method-toggle");
          add_location(div7, file$a, 513, 8, 15758);
          attr_dev(span0, "class", "field-label svelte-ae07vc");
          add_location(span0, file$a, 521, 44, 16262);
          attr_dev(p3, "class", "field invoice-amount svelte-ae07vc");
          add_location(p3, file$a, 521, 12, 16230);
          attr_dev(span1, "class", "field-label svelte-ae07vc");
          add_location(span1, file$a, 532, 45, 16898);
          attr_dev(p4, "class", "field invoice-expires svelte-ae07vc");
          add_location(p4, file$a, 532, 12, 16865);
          attr_dev(span2, "class", "field-label svelte-ae07vc");
          add_location(span2, file$a, 533, 37, 17003);
          attr_dev(span3, "class", "hex svelte-ae07vc");
          add_location(span3, file$a, 533, 99, 17065);
          attr_dev(p5, "class", "field invoice svelte-ae07vc");
          add_location(p5, file$a, 533, 12, 16978);
          attr_dev(div8, "class", "invoice-info svelte-ae07vc");
          toggle_class(div8, "ready",
          /*invoice*/
          ctx[2] &&
          /*invoice*/
          ctx[2].id);
          add_location(div8, file$a, 520, 10, 16155);
          attr_dev(div9, "class", "qr-container svelte-ae07vc");
          toggle_class(div9, "expired",
          /*invoiceExpired*/
          ctx[14]);
          add_location(div9, file$a, 549, 10, 17854);
          attr_dev(div10, "class", "invoice-area svelte-ae07vc");
          add_location(div10, file$a, 519, 8, 16118);
          attr_dev(button3, "class", "action-button");
          add_location(button3, file$a, 564, 8, 18473);
          attr_dev(div11, "class", "tab invoice svelte-ae07vc");
          add_location(div11, file$a, 512, 6, 15724);
          attr_dev(h30, "class", "invoice-status svelte-ae07vc");
          add_location(h30, file$a, 570, 10, 18675);
          attr_dev(div12, "class", "invoice-icon svelte-ae07vc");
          add_location(div12, file$a, 571, 10, 18727);
          attr_dev(h31, "class", "invoice-status svelte-ae07vc");
          add_location(h31, file$a, 572, 10, 18808);
          attr_dev(div13, "class", "qr-container paid svelte-ae07vc");
          add_location(div13, file$a, 569, 8, 18633);
          attr_dev(div14, "class", "tab success svelte-ae07vc");
          add_location(div14, file$a, 568, 6, 18599);
          attr_dev(div15, "class", div15_class_value = "modal-tabs show-" +
          /*tab*/
          ctx[0] + " svelte-ae07vc");
          add_location(div15, file$a, 433, 4, 12480);
          attr_dev(section, "class", "donation-modal svelte-ae07vc");
          add_location(section, file$a, 426, 2, 12183);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div0);
          append_dev(div0, button0);
          append_dev(div0, t1);
          append_dev(div0, h2);
          append_dev(div0, t3);
          append_dev(div0, button1);
          append_dev(section, t5);
          append_dev(section, div15);
          append_dev(div15, div6);
          append_dev(div6, p0);
          append_dev(div6, t7);
          append_dev(div6, p1);
          append_dev(div6, t9);
          append_dev(div6, p2);
          append_dev(div6, t11);
          append_dev(div6, div1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div1, null);
          }

          append_dev(div6, t12);
          append_dev(div6, div5);
          append_dev(div5, div2);
          mount_component(satoshislider, div2, null);
          append_dev(div5, t13);
          append_dev(div5, div3);
          if_block0.m(div3, null);
          append_dev(div5, t14);
          append_dev(div5, div4);
          mount_component(pill0, div4, null);
          append_dev(div6, t15);
          if (if_block1) if_block1.m(div6, null);
          append_dev(div6, t16);
          append_dev(div6, button2);
          if_blocks[current_block_type_index].m(button2, null);
          append_dev(div15, t17);
          append_dev(div15, div11);
          append_dev(div11, div7);
          mount_component(pill1, div7, null);
          append_dev(div11, t18);
          append_dev(div11, div10);
          append_dev(div10, div8);
          append_dev(div8, p3);
          append_dev(p3, span0);
          append_dev(p3, t20);
          append_dev(p3, t21);
          append_dev(div8, t22);
          if (if_block3) if_block3.m(div8, null);
          append_dev(div8, t23);
          if (if_block4) if_block4.m(div8, null);
          append_dev(div8, t24);
          append_dev(div8, p4);
          append_dev(p4, span1);
          append_dev(p4, t26);
          append_dev(p4, t27);
          append_dev(div8, t28);
          append_dev(div8, p5);
          append_dev(p5, span2);
          append_dev(span2, t29);
          append_dev(span2, t30);
          append_dev(p5, t31);
          append_dev(p5, span3);
          append_dev(span3, t32);
          /*span3_binding*/

          ctx[48](span3);
          append_dev(div8, t33);
          if (if_block5) if_block5.m(div8, null);
          append_dev(div8, t34);
          if (if_block6) if_block6.m(div8, null);
          append_dev(div10, t35);
          append_dev(div10, div9);
          if_blocks_1[current_block_type_index_1].m(div9, null);
          append_dev(div9, t36);
          if (if_block8) if_block8.m(div9, null);
          append_dev(div11, t37);
          append_dev(div11, button3);
          append_dev(div15, t39);
          append_dev(div15, div14);
          append_dev(div14, div13);
          append_dev(div13, h30);
          append_dev(div13, t41);
          append_dev(div13, div12);
          mount_component(icon, div12, null);
          append_dev(div13, t42);
          append_dev(div13, h31);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(button0, "click",
            /*tabLeft*/
            ctx[29], false, false, false), listen_dev(button1, "click",
            /*tabRight*/
            ctx[30], false, false, false), listen_dev(button2, "click",
            /*generateInvoice*/
            ctx[32], false, false, false), listen_dev(button3, "click",
            /*click_handler_1*/
            ctx[49], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*canTabLeft*/
          8388608) {
            toggle_class(button0, "disabled", !
            /*canTabLeft*/
            ctx[23]);
          }

          if (dirty[0] &
          /*canTabRight*/
          16777216) {
            toggle_class(button1, "disabled", !
            /*canTabRight*/
            ctx[24]);
          }

          if (dirty[0] &
          /*tierThresholds, btc*/
          4195328 | dirty[1] &
          /*setAmount*/
          1) {
            each_value_1 =
            /*tierThresholds*/
            ctx[22];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block_1$1(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(div1, null);
              }
            }

            group_outros();

            for (i = each_value_1.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          const satoshislider_changes = {};
          if (dirty[0] &
          /*sats*/
          512) satoshislider_changes.value =
          /*sats*/
          ctx[9];
          if (dirty[0] &
          /*tierThresholds*/
          4194304) satoshislider_changes.thresholds =
          /*tierThresholds*/
          ctx[22];
          satoshislider.$set(satoshislider_changes);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div3, null);
            }
          }

          const pill0_changes = {};
          if (dirty[0] &
          /*unit*/
          256) pill0_changes.active =
          /*unit*/
          ctx[8] === 'btc';
          pill0.$set(pill0_changes);

          if (
          /*$tiers*/
          ctx[6] &&
          /*btc*/
          ctx[10] >=
          /*$tiers*/
          ctx[6].hero.min) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*$tiers, btc*/
              1088) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_9$1(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div6, t16);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_2(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block2 = if_blocks[current_block_type_index];

            if (!if_block2) {
              if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block2.c();
            } else {
              if_block2.p(ctx, dirty);
            }

            transition_in(if_block2, 1);
            if_block2.m(button2, null);
          }

          const pill1_changes = {};
          if (dirty[0] &
          /*canPayOnChain*/
          16) pill1_changes.leftDisabled = !
          /*canPayOnChain*/
          ctx[4];
          if (dirty[0] &
          /*canPayLightning*/
          32) pill1_changes.rightDisabled = !
          /*canPayLightning*/
          ctx[5];
          if (dirty[0] &
          /*payOnChain*/
          2) pill1_changes.active = !
          /*payOnChain*/
          ctx[1];

          if (dirty[2] &
          /*$$scope*/
          4096) {
            pill1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          pill1.$set(pill1_changes);
          if (!current || dirty[0] &
          /*invoiceAmountLabel*/
          65536) set_data_dev(t21,
          /*invoiceAmountLabel*/
          ctx[16]);

          if (
          /*invoicePaidLabel*/
          ctx[15]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_6$1(ctx);
              if_block3.c();
              if_block3.m(div8, t23);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if (
          /*invoicePayments*/
          ctx[21] &&
          /*invoicePayments*/
          ctx[21].length) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block_5$1(ctx);
              if_block4.c();
              if_block4.m(div8, t24);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }

          if (!current || dirty[0] &
          /*invoiceExpiryLabel*/
          131072) set_data_dev(t27,
          /*invoiceExpiryLabel*/
          ctx[17]);
          if (!current || dirty[0] &
          /*invoiceDestinationLabel*/
          262144) set_data_dev(t29,
          /*invoiceDestinationLabel*/
          ctx[18]);
          if ((!current || dirty[0] &
          /*invoiceHexLabel*/
          524288) && t32_value !== (t32_value = (
          /*invoiceHexLabel*/
          ctx[19] || invoiceHexPlaceholder) + "")) set_data_dev(t32, t32_value);

          if (
          /*showCopyButton*/
          ctx[26]) {
            if (if_block5) {
              if_block5.p(ctx, dirty);

              if (dirty[0] &
              /*showCopyButton*/
              67108864) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block_3$1(ctx);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(div8, t34);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }

          if (!
          /*invoice*/
          ctx[2] || !
          /*invoice*/
          ctx[2].id || !
          /*invoiceHexLabel*/
          ctx[19]) {
            if (if_block6) {
              if (dirty[0] &
              /*invoice, invoiceHexLabel*/
              524292) {
                transition_in(if_block6, 1);
              }
            } else {
              if_block6 = create_if_block_2$2(ctx);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(div8, null);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }

          if (dirty[0] &
          /*invoice*/
          4) {
            toggle_class(div8, "ready",
            /*invoice*/
            ctx[2] &&
            /*invoice*/
            ctx[2].id);
          }

          let previous_block_index_1 = current_block_type_index_1;
          current_block_type_index_1 = select_block_type_3(ctx);

          if (current_block_type_index_1 === previous_block_index_1) {
            if_blocks_1[current_block_type_index_1].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
              if_blocks_1[previous_block_index_1] = null;
            });
            check_outros();
            if_block7 = if_blocks_1[current_block_type_index_1];

            if (!if_block7) {
              if_block7 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
              if_block7.c();
            } else {
              if_block7.p(ctx, dirty);
            }

            transition_in(if_block7, 1);
            if_block7.m(div9, t36);
          }

          if (
          /*qrSrc*/
          ctx[20] && !
          /*invoicePaid*/
          ctx[13] && !
          /*invoiceExpired*/
          ctx[14]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);
            } else {
              if_block8 = create_if_block$6(ctx);
              if_block8.c();
              if_block8.m(div9, null);
            }
          } else if (if_block8) {
            if_block8.d(1);
            if_block8 = null;
          }

          if (dirty[0] &
          /*invoiceExpired*/
          16384) {
            toggle_class(div9, "expired",
            /*invoiceExpired*/
            ctx[14]);
          }

          if (!current || dirty[0] &
          /*tab*/
          1 && div15_class_value !== (div15_class_value = "modal-tabs show-" +
          /*tab*/
          ctx[0] + " svelte-ae07vc")) {
            attr_dev(div15, "class", div15_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(satoshislider.$$.fragment, local);
          transition_in(pill0.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(pill1.$$.fragment, local);
          transition_in(if_block5);
          transition_in(if_block6);
          transition_in(if_block7);
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(satoshislider.$$.fragment, local);
          transition_out(pill0.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(pill1.$$.fragment, local);
          transition_out(if_block5);
          transition_out(if_block6);
          transition_out(if_block7);
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          destroy_each(each_blocks, detaching);
          destroy_component(satoshislider);
          if_block0.d();
          destroy_component(pill0);
          if (if_block1) if_block1.d();
          if_blocks[current_block_type_index].d();
          destroy_component(pill1);
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          /*span3_binding*/

          ctx[48](null);
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if_blocks_1[current_block_type_index_1].d();
          if (if_block8) if_block8.d();
          destroy_component(icon);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$1.name,
        type: "slot",
        source: "(426:0) <Overlay name=\\\"donation\\\" fullSize on:close={onClose}>",
        ctx
      });
      return block;
    }

    function create_fragment$a(ctx) {
      let overlay_1;
      let current;
      overlay_1 = new Overlay({
        props: {
          name: "donation",
          fullSize: true,
          $$slots: {
            default: [create_default_slot$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      overlay_1.$on("close",
      /*onClose*/
      ctx[36]);
      const block = {
        c: function create() {
          create_component(overlay_1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(overlay_1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const overlay_1_changes = {};

          if (dirty[0] &
          /*tab, invoiceExpired, qrSrc, invoicePaid, invoice, invoiceHexLabel, copied, showCopyButton, invoiceSpan, invoiceDestinationLabel, invoiceExpiryLabel, invoicePayments, invoiceUnit, invoicePaidLabel, invoiceAmountLabel, canPayOnChain, canPayLightning, payOnChain, waitingForInvoice, email, btc, $tiers, twitter, unit, sats, tierThresholds, canTabRight, canTabLeft*/
          268435455 | dirty[2] &
          /*$$scope*/
          4096) {
            overlay_1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          overlay_1.$set(overlay_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(overlay_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(overlay_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(overlay_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const invoiceHexPlaceholder = 'lnbcxxxxxxt8l4pp5umz5kyakc0u8z3w2y568entyyq2gafgc3n5a7khdtk5m9fehkxnqdq6gf5hgen9v4jzqer0deshg6t0dccqzpgxqzjcsp5arlylwgraa2u75g4wh40swvxyvt0cpyrmnl4cha40uj5x2fr0t8q9qy9qsqzh3dtfag0ymaf8dpyxrly9p04jwlgdaxkh6g9ysaxyzz7jtrrkpsxv52mlzl6wgn6l6eur9yrl5q2quh5p8kagmng45gqjz9e2c6uxgqx5ezjr';

    function amountToLabel(amount, unit) {
      if (unit === 'btc') {
        return `${amount} btc`;
      } else {
        return `${btcToSats(amount)} sats`;
      }
    }

    function satsToBtc(sats) {
      return sats / 100000000;
    }

    function btcToSats(btc) {
      return Math.round(btc * 100000000);
    }

    function instance$a($$self, $$props, $$invalidate) {
      let $urlPath;
      let $overlay;
      let $tiers;
      validate_store(urlPath, 'urlPath');
      component_subscribe($$self, urlPath, $$value => $$invalidate(55, $urlPath = $$value));
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(41, $overlay = $$value));
      validate_store(tiers, 'tiers');
      component_subscribe($$self, tiers, $$value => $$invalidate(6, $tiers = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('DonationOverlay', slots, []);
      let tab = 'form'; // form | invoice | success

      let waitingForInvoice = false;
      let unit = 'sats';
      let sats = 2500;
      let btc = 0.000025;
      let twitter = null;
      let email = null;
      let isPrivate = false;
      let payOnChain = true;
      let invoice = null;
      let invoicePaid = false;
      let invoiceExpired = false;
      let invoiceProcessing = false;
      let lightningInvoice, chainInvoice, selectedMethod;
      let invoicePoll;
      let pollingEnabled = false;
      let invoiceUnit = 'sats';
      let invoicePaidLabel;
      let invoiceAmountLabel;
      let invoiceExpiryLabel;
      let invoiceDestinationLabel;
      let invoiceHexLabel;
      let qrSrc = null;
      let invoicePayments = [];
      let tierThresholds = [];
      let canPayOnChain, canPayLightning;
      let canTabLeft, canTabRight;

      function setTab(to) {
        if (tab !== to) {
          $$invalidate(0, tab = to);
          const overlayInner = document.getElementById('donationOverlay');
          if (overlayInner) overlayInner.scrollTop = 0;
        }
      }

      function tabLeft() {
        if (canTabLeft) setTab('form');
      }

      function tabRight() {
        if (canTabRight) setTab('invoice');
      }

      async function setQR(invoice) {
        try {
          $$invalidate(20, qrSrc = await browser.toDataURL(invoice.toUpperCase()));
        } catch (err) {
          console.log('error generating QR code: ', err);
        }
      }

      let expiryTick;
      let expiresIn = null; // time till expiry in seconds

      function expiryTimer() {
        if (invoice && invoice.expirationTime) $$invalidate(40, expiresIn = Math.round((invoice.expirationTime * 1000 - Date.now()) / 1000));else $$invalidate(40, expiresIn = null);
      }

      function stopExpiryTimer() {
        if (expiryTick) clearInterval(expiryTick);
        expiryTick = null;
      }

      function startExpiryTimer() {
        if (!expiryTick && $overlay === 'donation' && invoice && invoice.id) {
          stopExpiryTimer();
          expiryTick = setInterval(expiryTimer, 200);
        }
      }

      onMount(() => {
        $$invalidate(26, showCopyButton = navigator && navigator.clipboard && navigator.clipboard.writeText || !!invoiceSpan); // check for existing invoice in local storage:

        const loadedInvoiceJSON = localStorage.getItem(`donation-invoice`); // localStorage.removeItem('donation-invoice')

        if (loadedInvoiceJSON) {
          try {
            const loadedInvoice = JSON.parse(loadedInvoiceJSON);

            if (loadedInvoice && loadedInvoice.id && loadedInvoice.status && (loadedInvoice.status === 'New' || loadedInvoice.status === 'Processing') && loadedInvoice.expirationTime * 1000 > Date.now()) {
              setTab('invoice');
              processNewInvoice(loadedInvoice, true);
            }
          } catch (err) {
            console.log('error loading/parsing invoice');
          }
        }
      });

      function resetInvoice() {
        $$invalidate(13, invoicePaid = false);
        $$invalidate(14, invoiceExpired = false);
        invoiceProcessing = false;
        $$invalidate(2, invoice = null);
        $$invalidate(37, lightningInvoice = null);
        $$invalidate(38, chainInvoice = null);
        $$invalidate(39, selectedMethod = null);
        $$invalidate(20, qrSrc = null);
        setTab('form');
      }

      function checkResetInvoice() {
        if (!invoice || !(invoice.status === 'New' || invoice.status === 'Processing')) resetInvoice();
      }

      function stopPollingInvoice() {
        pollingEnabled = false;
        if (invoicePoll) clearTimeout(invoicePoll);
        invoicePoll = null;
      }

      function updateInvoice(state) {
        // do not overwrite the state of a different invoice
        if (state && invoice && invoice.id === state.id) {
          $$invalidate(2, invoice = state);

          if (invoice.status === 'Settled') {
            $$invalidate(13, invoicePaid = true);
            $$invalidate(14, invoiceExpired = false);
            invoiceProcessing = false;
            analytics.trackEvent('donations', 'invoice', 'paid', btcToSats(invoice.amount));
            localStorage.removeItem('donation-invoice');
            $$invalidate(2, invoice = null);
            setTab('success');
          } else if (invoice.status === 'Expired' || invoice.status === "Invalid" || invoice.expirationTime * 1000 < Date.now()) {
            $$invalidate(13, invoicePaid = false); // localStorage.removeItem('donation-invoice')

            $$invalidate(14, invoiceExpired = true);
            invoiceProcessing = false;
            localStorage.setItem('donation-invoice', JSON.stringify(invoice));
          } else if (invoice.status === 'New') {
            $$invalidate(13, invoicePaid = false); // localStorage.removeItem('donation-invoice')

            $$invalidate(14, invoiceExpired = false);
            invoiceProcessing = false;
            localStorage.setItem('donation-invoice', JSON.stringify(invoice));
            invoicePoll = setTimeout(pollInvoice, 2000);
          } else if (invoice.status === 'Processing') {
            $$invalidate(13, invoicePaid = false);
            $$invalidate(14, invoiceExpired = false);
            invoiceProcessing = true;
            localStorage.setItem('donation-invoice', JSON.stringify(invoice));
            invoicePoll = setTimeout(pollInvoice, 2000);
          }

          $$invalidate(21, invoicePayments = []);

          if (invoice && invoice.paymentMethods) {
            $$invalidate(38, chainInvoice = null);
            $$invalidate(37, lightningInvoice = null);
            invoice.paymentMethods.forEach(method => {
              if (method.paymentMethod === 'BTC-LightningNetwork') {
                processLightningInvoice(method);
              } else if (method.paymentMethod === 'BTC') processChainInvoice(method);
            });
          }
        }
      }

      function processNewInvoice(newInvoice) {
        let fillForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        $$invalidate(2, invoice = newInvoice);

        if (newInvoice) {
          $$invalidate(1, payOnChain = true);
          startExpiryTimer();
          updateInvoice(newInvoice);

          if (fillForm) {
            if (invoice.amount) {
              setAmount(invoice.amount, true);
            }

            if (invoice.metadata) {
              if (invoice.metadata.twitter) $$invalidate(11, twitter = invoice.metadata.twitter);
              if (invoice.metadata.email) $$invalidate(12, email = invoice.metadata.email);
              if (invoice.metadata.isPrivate != null) isPrivate = !!invoice.metadata.isPrivate;
            }
          }

          if (canPayLightning && invoice.amount && invoice.amount < 0.001) {
            $$invalidate(1, payOnChain = false);
          } else {
            $$invalidate(1, payOnChain = true);
          }
        }
      }

      function setAmount(amount) {
        let inBTC = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (inBTC) {
          $$invalidate(9, sats = btcToSats(amount));
          $$invalidate(10, btc = amount);
        } else {
          $$invalidate(9, sats = amount);
          $$invalidate(10, btc = satsToBtc(amount));
        }
      }

      function processLightningInvoice(invoice) {
        $$invalidate(5, canPayLightning = true);
        $$invalidate(37, lightningInvoice = invoice);

        if (invoice && invoice.payments && invoice.payments.length) {
          $$invalidate(21, invoicePayments = invoicePayments.concat(invoice.payments));
        }
      }

      function processChainInvoice(invoice) {
        $$invalidate(4, canPayOnChain = true);
        $$invalidate(38, chainInvoice = invoice);

        if (invoice && invoice.payments && invoice.payments.length) {
          $$invalidate(21, invoicePayments = invoicePayments.concat(invoice.payments));
        }
      }

      async function pollInvoice() {
        if (pollingEnabled && invoice && (invoice.status === 'New' || invoice.status === 'Processing')) {
          try {
            const response = await fetch(`${config$1.donationRoot}/api/invoice/${invoice.id}`, {
              method: 'GET'
            });
            let invoiceState = await response.json();
            updateInvoice(invoiceState);
          } catch (e) {
            console.log('error polling invoice: ', e);
          }
        }
      }

      async function generateInvoice() {
        if (sats) {
          analytics.trackEvent('donations', 'invoice', 'generate', sats);
          resetInvoice();
          $$invalidate(7, waitingForInvoice = true);
          const response = await fetch(`${config$1.donationRoot}/api/invoice/new`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              amount: satsToBtc(sats),
              twitter,
              email,
              isPrivate
            })
          });
          let newInvoice = await response.json();

          if (newInvoice && newInvoice.amount) {
            analytics.trackEvent('donations', 'invoice', 'generate-success', btcToSats(newInvoice.amount));
            setTab('invoice');
          }

          processNewInvoice(newInvoice);
          $$invalidate(7, waitingForInvoice = false);
        }
      }

      function togglePaymentMethod() {
        $$invalidate(1, payOnChain = !payOnChain);
      }

      function toggleUnits() {
        if (unit === 'sats') $$invalidate(8, unit = 'btc');else $$invalidate(8, unit = 'sats');
      }

      let copied = false;
      let showCopyButton = true;
      let invoiceSpan;

      async function copyInvoice() {
        if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(invoiceHexLabel);
          $$invalidate(25, copied = true);
          setTimeout(() => {
            $$invalidate(25, copied = false);
          }, 2000);
        } else if (invoiceSpan) {
          // fallback
          const range = document.createRange();
          range.selectNodeContents(invoiceSpan);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          $$invalidate(25, copied = document.execCommand('copy'));
          setTimeout(() => {
            $$invalidate(25, copied = false);
            selection.removeAllRanges();
          }, 2000);
        }

        analytics.trackEvent('donations', 'invoice', 'copy');
      }

      function onClose() {
        set_store_value(urlPath, $urlPath = "/", $urlPath);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<DonationOverlay> was created with unknown prop '${key}'`);
      });

      const click_handler = tier => {
        setAmount(tier.min || 0.00005000, true);
      };

      const input_handler = e => {
        setAmount(e.detail);
      };

      const input_handler_1 = e => {
        setAmount(e.target.value, false);
      };

      const input_handler_2 = e => {
        setAmount(e.target.value, true);
      };

      function input_input_handler() {
        twitter = this.value;
        $$invalidate(11, twitter);
      }

      function input_input_handler_1() {
        email = this.value;
        $$invalidate(12, email);
      }

      function span3_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          invoiceSpan = $$value;
          $$invalidate(27, invoiceSpan);
        });
      }

      const click_handler_1 = () => {
        setTab('form');
      };

      $$self.$capture_state = () => ({
        analytics,
        config: config$1,
        onMount,
        Overlay,
        TierCard,
        SatoshiSlider,
        Pill,
        Icon,
        boltIcon,
        chainIcon,
        tickIcon,
        spinnerIcon,
        timerIcon,
        emailIcon,
        clipboardIcon,
        twitterIcon,
        fade,
        fly,
        durationFormat,
        overlay,
        tiers,
        urlPath,
        QRCode: browser,
        tab,
        waitingForInvoice,
        unit,
        sats,
        btc,
        twitter,
        email,
        isPrivate,
        payOnChain,
        invoice,
        invoicePaid,
        invoiceExpired,
        invoiceProcessing,
        lightningInvoice,
        chainInvoice,
        selectedMethod,
        invoicePoll,
        pollingEnabled,
        invoiceUnit,
        invoicePaidLabel,
        invoiceAmountLabel,
        invoiceExpiryLabel,
        invoiceDestinationLabel,
        invoiceHexLabel,
        invoiceHexPlaceholder,
        qrSrc,
        invoicePayments,
        tierThresholds,
        canPayOnChain,
        canPayLightning,
        canTabLeft,
        canTabRight,
        setTab,
        tabLeft,
        tabRight,
        amountToLabel,
        setQR,
        expiryTick,
        expiresIn,
        expiryTimer,
        stopExpiryTimer,
        startExpiryTimer,
        resetInvoice,
        checkResetInvoice,
        stopPollingInvoice,
        updateInvoice,
        processNewInvoice,
        satsToBtc,
        btcToSats,
        setAmount,
        processLightningInvoice,
        processChainInvoice,
        pollInvoice,
        generateInvoice,
        togglePaymentMethod,
        toggleUnits,
        copied,
        showCopyButton,
        invoiceSpan,
        copyInvoice,
        onClose,
        $urlPath,
        $overlay,
        $tiers
      });

      $$self.$inject_state = $$props => {
        if ('tab' in $$props) $$invalidate(0, tab = $$props.tab);
        if ('waitingForInvoice' in $$props) $$invalidate(7, waitingForInvoice = $$props.waitingForInvoice);
        if ('unit' in $$props) $$invalidate(8, unit = $$props.unit);
        if ('sats' in $$props) $$invalidate(9, sats = $$props.sats);
        if ('btc' in $$props) $$invalidate(10, btc = $$props.btc);
        if ('twitter' in $$props) $$invalidate(11, twitter = $$props.twitter);
        if ('email' in $$props) $$invalidate(12, email = $$props.email);
        if ('isPrivate' in $$props) isPrivate = $$props.isPrivate;
        if ('payOnChain' in $$props) $$invalidate(1, payOnChain = $$props.payOnChain);
        if ('invoice' in $$props) $$invalidate(2, invoice = $$props.invoice);
        if ('invoicePaid' in $$props) $$invalidate(13, invoicePaid = $$props.invoicePaid);
        if ('invoiceExpired' in $$props) $$invalidate(14, invoiceExpired = $$props.invoiceExpired);
        if ('invoiceProcessing' in $$props) invoiceProcessing = $$props.invoiceProcessing;
        if ('lightningInvoice' in $$props) $$invalidate(37, lightningInvoice = $$props.lightningInvoice);
        if ('chainInvoice' in $$props) $$invalidate(38, chainInvoice = $$props.chainInvoice);
        if ('selectedMethod' in $$props) $$invalidate(39, selectedMethod = $$props.selectedMethod);
        if ('invoicePoll' in $$props) invoicePoll = $$props.invoicePoll;
        if ('pollingEnabled' in $$props) pollingEnabled = $$props.pollingEnabled;
        if ('invoiceUnit' in $$props) $$invalidate(3, invoiceUnit = $$props.invoiceUnit);
        if ('invoicePaidLabel' in $$props) $$invalidate(15, invoicePaidLabel = $$props.invoicePaidLabel);
        if ('invoiceAmountLabel' in $$props) $$invalidate(16, invoiceAmountLabel = $$props.invoiceAmountLabel);
        if ('invoiceExpiryLabel' in $$props) $$invalidate(17, invoiceExpiryLabel = $$props.invoiceExpiryLabel);
        if ('invoiceDestinationLabel' in $$props) $$invalidate(18, invoiceDestinationLabel = $$props.invoiceDestinationLabel);
        if ('invoiceHexLabel' in $$props) $$invalidate(19, invoiceHexLabel = $$props.invoiceHexLabel);
        if ('qrSrc' in $$props) $$invalidate(20, qrSrc = $$props.qrSrc);
        if ('invoicePayments' in $$props) $$invalidate(21, invoicePayments = $$props.invoicePayments);
        if ('tierThresholds' in $$props) $$invalidate(22, tierThresholds = $$props.tierThresholds);
        if ('canPayOnChain' in $$props) $$invalidate(4, canPayOnChain = $$props.canPayOnChain);
        if ('canPayLightning' in $$props) $$invalidate(5, canPayLightning = $$props.canPayLightning);
        if ('canTabLeft' in $$props) $$invalidate(23, canTabLeft = $$props.canTabLeft);
        if ('canTabRight' in $$props) $$invalidate(24, canTabRight = $$props.canTabRight);
        if ('expiryTick' in $$props) expiryTick = $$props.expiryTick;
        if ('expiresIn' in $$props) $$invalidate(40, expiresIn = $$props.expiresIn);
        if ('copied' in $$props) $$invalidate(25, copied = $$props.copied);
        if ('showCopyButton' in $$props) $$invalidate(26, showCopyButton = $$props.showCopyButton);
        if ('invoiceSpan' in $$props) $$invalidate(27, invoiceSpan = $$props.invoiceSpan);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*$tiers*/
        64) {
          {
            if ($tiers) {
              $$invalidate(22, tierThresholds = [{
                title: 'Supporter',
                description: "Help to keep the lights on with a small donation",
                emoji: '🙏',
                color: 'var(--bold-b)',
                optional: true,
                min: 0.00005000,
                minSats: 5000,
                max: $tiers.hero.min,
                maxSats: btcToSats($tiers.hero.min)
              }, {
                title: 'Community Hero',
                description: "Add your Twitter profile to our Supporters page",
                emoji: '🦸',
                color: 'var(--bold-c)',
                min: $tiers.hero.min,
                minSats: btcToSats($tiers.hero.min),
                max: $tiers.sponsor.min,
                maxSats: btcToSats($tiers.sponsor.min)
              }, {
                title: 'Enterprise Sponsor',
                description: "Display your logo on Bitfeed, with a link to your website",
                emoji: '🕴️',
                color: 'var(--bold-a)',
                min: $tiers.sponsor.min,
                minSats: btcToSats($tiers.sponsor.min),
                max: Infinity,
                maxSats: Infinity
              }]);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*canPayOnChain, payOnChain, canPayLightning, invoiceUnit*/
        58 | $$self.$$.dirty[1] &
        /*chainInvoice, lightningInvoice, selectedMethod*/
        448) {
          {
            $$invalidate(4, canPayOnChain = !!chainInvoice);
            $$invalidate(5, canPayLightning = !!lightningInvoice);
            if (!canPayOnChain && payOnChain) $$invalidate(1, payOnChain = false);else if (!canPayLightning && !payOnChain) $$invalidate(1, payOnChain = true);
            $$invalidate(39, selectedMethod = payOnChain ? chainInvoice : lightningInvoice);

            if (selectedMethod) {
              let totalPaid = Number.parseFloat(selectedMethod.totalPaid);
              let amount = Number.parseFloat(selectedMethod.amount);

              if (amount >= 0.001) {
                $$invalidate(3, invoiceUnit = 'btc');
              } else {
                $$invalidate(3, invoiceUnit = 'sats');
              }

              $$invalidate(15, invoicePaidLabel = totalPaid ? amountToLabel(totalPaid, invoiceUnit) : null);
              $$invalidate(16, invoiceAmountLabel = amountToLabel(amount, invoiceUnit));
              $$invalidate(18, invoiceDestinationLabel = selectedMethod.paymentMethod === 'BTC' ? 'Payment Address' : 'Payment Request');
              $$invalidate(19, invoiceHexLabel = selectedMethod.destination);
              setQR(selectedMethod.paymentLink);
            } else {
              $$invalidate(20, qrSrc = null);
              $$invalidate(19, invoiceHexLabel = null);
              $$invalidate(15, invoicePaidLabel = null);
              $$invalidate(16, invoiceAmountLabel = null);
              $$invalidate(18, invoiceDestinationLabel = null);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*tab, invoice*/
        5) {
          {
            $$invalidate(23, canTabLeft = tab !== 'form');
            $$invalidate(24, canTabRight = tab === 'form' && !!invoice);
          }
        }

        if ($$self.$$.dirty[1] &
        /*expiresIn*/
        512) {
          {
            $$invalidate(17, invoiceExpiryLabel = expiresIn == null ? '' : durationFormat.format(expiresIn * 1000));
          }
        }

        if ($$self.$$.dirty[1] &
        /*$overlay*/
        1024) {
          {
            if ($overlay === 'donation') {
              set_store_value(urlPath, $urlPath = '/donate', $urlPath);
              startExpiryTimer();
              stopPollingInvoice();
              pollingEnabled = true;
              pollInvoice();
            } else {
              stopExpiryTimer();
              stopPollingInvoice();
              checkResetInvoice();
            }
          }
        }
      };

      return [tab, payOnChain, invoice, invoiceUnit, canPayOnChain, canPayLightning, $tiers, waitingForInvoice, unit, sats, btc, twitter, email, invoicePaid, invoiceExpired, invoicePaidLabel, invoiceAmountLabel, invoiceExpiryLabel, invoiceDestinationLabel, invoiceHexLabel, qrSrc, invoicePayments, tierThresholds, canTabLeft, canTabRight, copied, showCopyButton, invoiceSpan, setTab, tabLeft, tabRight, setAmount, generateInvoice, togglePaymentMethod, toggleUnits, copyInvoice, onClose, lightningInvoice, chainInvoice, selectedMethod, expiresIn, $overlay, click_handler, input_handler, input_handler_1, input_handler_2, input_input_handler, input_input_handler_1, span3_binding, click_handler_1];
    }

    class DonationOverlay extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$a, create_fragment$a, safe_not_equal, {}, null, [-1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "DonationOverlay",
          options,
          id: create_fragment$a.name
        });
      }

    }

    /* src/components/SupportersOverlay.svelte generated by Svelte v3.44.3 */
    const {
      Object: Object_1$1
    } = globals;
    const file$9 = "src/components/SupportersOverlay.svelte";

    function get_each_context$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i];
      return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      return child_ctx;
    } // (28:4) {#if $sponsors && $sponsors.length}


    function create_if_block_1$2(ctx) {
      let div1;
      let h3;
      let t1;
      let div0;
      let t2;
      let button;
      let mounted;
      let dispose;
      let each_value_1 =
      /*$sponsors*/
      ctx[2];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          div1 = element("div");
          h3 = element("h3");
          h3.textContent = "Enterprise Sponsors";
          t1 = space();
          div0 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          button = element("button");
          button.textContent = "Become a Sponsor!";
          attr_dev(h3, "class", "svelte-1y6x2n5");
          add_location(h3, file$9, 29, 8, 783);
          attr_dev(div0, "class", "entries svelte-1y6x2n5");
          add_location(div0, file$9, 30, 8, 820);
          attr_dev(div1, "class", "group svelte-1y6x2n5");
          add_location(div1, file$9, 28, 6, 755);
          attr_dev(button, "class", "action-button");
          add_location(button, file$9, 39, 6, 1138);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h3);
          append_dev(div1, t1);
          append_dev(div1, div0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div0, null);
          }

          insert_dev(target, t2, anchor);
          insert_dev(target, button, anchor);

          if (!mounted) {
            dispose = listen_dev(button, "click",
            /*click_handler*/
            ctx[4], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$sponsors*/
          4) {
            each_value_1 =
            /*$sponsors*/
            ctx[2];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div0, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$2.name,
        type: "if",
        source: "(28:4) {#if $sponsors && $sponsors.length}",
        ctx
      });
      return block;
    } // (32:10) {#each $sponsors as sponsor}


    function create_each_block_1(ctx) {
      let a;
      let img;
      let img_src_value;
      let img_alt_value;
      let t0;
      let span;
      let t1_value =
      /*sponsor*/
      ctx[9].name + "";
      let t1;
      let t2;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          img = element("img");
          t0 = space();
          span = element("span");
          t1 = text(t1_value);
          t2 = space();
          if (!src_url_equal(img.src, img_src_value =
          /*sponsor*/
          ctx[9].img)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", img_alt_value =
          /*sponsor*/
          ctx[9].name);
          attr_dev(img, "class", "svelte-1y6x2n5");
          add_location(img, file$9, 33, 14, 968);
          attr_dev(span, "class", "label svelte-1y6x2n5");
          add_location(span, file$9, 34, 14, 1025);
          attr_dev(a, "class", "supporter svelte-1y6x2n5");
          attr_dev(a, "target", "_blank");
          attr_dev(a, "href", a_href_value =
          /*sponsor*/
          ctx[9].website);
          add_location(a, file$9, 32, 12, 893);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, img);
          append_dev(a, t0);
          append_dev(a, span);
          append_dev(span, t1);
          append_dev(a, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$sponsors*/
          4 && !src_url_equal(img.src, img_src_value =
          /*sponsor*/
          ctx[9].img)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*$sponsors*/
          4 && img_alt_value !== (img_alt_value =
          /*sponsor*/
          ctx[9].name)) {
            attr_dev(img, "alt", img_alt_value);
          }

          if (dirty &
          /*$sponsors*/
          4 && t1_value !== (t1_value =
          /*sponsor*/
          ctx[9].name + "")) set_data_dev(t1, t1_value);

          if (dirty &
          /*$sponsors*/
          4 && a_href_value !== (a_href_value =
          /*sponsor*/
          ctx[9].website)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(32:10) {#each $sponsors as sponsor}",
        ctx
      });
      return block;
    } // (44:4) {#if $heroes && displayHeroes.length}


    function create_if_block$5(ctx) {
      let div1;
      let h3;
      let t1;
      let div0;
      let t2;
      let button;
      let mounted;
      let dispose;
      let each_value =
      /*displayHeroes*/
      ctx[1];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div1 = element("div");
          h3 = element("h3");
          h3.textContent = "Community Heroes";
          t1 = space();
          div0 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          button = element("button");
          button.textContent = "Become a Community Hero!";
          attr_dev(h3, "class", "svelte-1y6x2n5");
          add_location(h3, file$9, 45, 8, 1340);
          attr_dev(div0, "class", "entries svelte-1y6x2n5");
          add_location(div0, file$9, 46, 8, 1374);
          attr_dev(div1, "class", "group svelte-1y6x2n5");
          add_location(div1, file$9, 44, 6, 1312);
          attr_dev(button, "class", "action-button");
          add_location(button, file$9, 55, 6, 1732);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h3);
          append_dev(div1, t1);
          append_dev(div1, div0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div0, null);
          }

          insert_dev(target, t2, anchor);
          insert_dev(target, button, anchor);

          if (!mounted) {
            dispose = listen_dev(button, "click",
            /*click_handler_1*/
            ctx[5], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*displayHeroes*/
          2) {
            each_value =
            /*displayHeroes*/
            ctx[1];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$2(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div0, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(44:4) {#if $heroes && displayHeroes.length}",
        ctx
      });
      return block;
    } // (48:10) {#each displayHeroes as hero}


    function create_each_block$2(ctx) {
      let a;
      let img;
      let img_src_value;
      let img_alt_value;
      let t0;
      let span;
      let t1;
      let t2_value =
      /*hero*/
      ctx[6].username + "";
      let t2;
      let t3;
      let a_href_value;
      let a_title_value;
      const block = {
        c: function create() {
          a = element("a");
          img = element("img");
          t0 = space();
          span = element("span");
          t1 = text("@");
          t2 = text(t2_value);
          t3 = space();
          if (!src_url_equal(img.src, img_src_value =
          /*hero*/
          ctx[6].img)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", img_alt_value =
          /*hero*/
          ctx[6].name);
          attr_dev(img, "class", "svelte-1y6x2n5");
          add_location(img, file$9, 49, 14, 1566);
          attr_dev(span, "class", "label svelte-1y6x2n5");
          add_location(span, file$9, 50, 14, 1617);
          attr_dev(a, "class", "supporter hero svelte-1y6x2n5");
          attr_dev(a, "target", "_blank");
          attr_dev(a, "href", a_href_value = "https://twitter.com/" +
          /*hero*/
          ctx[6].username);
          attr_dev(a, "title", a_title_value =
          /*hero*/
          ctx[6].name);
          add_location(a, file$9, 48, 12, 1448);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, img);
          append_dev(a, t0);
          append_dev(a, span);
          append_dev(span, t1);
          append_dev(span, t2);
          append_dev(a, t3);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*displayHeroes*/
          2 && !src_url_equal(img.src, img_src_value =
          /*hero*/
          ctx[6].img)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*displayHeroes*/
          2 && img_alt_value !== (img_alt_value =
          /*hero*/
          ctx[6].name)) {
            attr_dev(img, "alt", img_alt_value);
          }

          if (dirty &
          /*displayHeroes*/
          2 && t2_value !== (t2_value =
          /*hero*/
          ctx[6].username + "")) set_data_dev(t2, t2_value);

          if (dirty &
          /*displayHeroes*/
          2 && a_href_value !== (a_href_value = "https://twitter.com/" +
          /*hero*/
          ctx[6].username)) {
            attr_dev(a, "href", a_href_value);
          }

          if (dirty &
          /*displayHeroes*/
          2 && a_title_value !== (a_title_value =
          /*hero*/
          ctx[6].name)) {
            attr_dev(a, "title", a_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$2.name,
        type: "each",
        source: "(48:10) {#each displayHeroes as hero}",
        ctx
      });
      return block;
    } // (22:0) <Overlay name="supporters" fullSize>


    function create_default_slot(ctx) {
      let section;
      let h2;
      let t1;
      let p;
      let t3;
      let t4;
      let if_block0 =
      /*$sponsors*/
      ctx[2] &&
      /*$sponsors*/
      ctx[2].length && create_if_block_1$2(ctx);
      let if_block1 =
      /*$heroes*/
      ctx[0] &&
      /*displayHeroes*/
      ctx[1].length && create_if_block$5(ctx);
      const block = {
        c: function create() {
          section = element("section");
          h2 = element("h2");
          h2.textContent = "Our Supporters";
          t1 = space();
          p = element("p");
          p.textContent = "Bitfeed is only possible thanks to the generosity of our supporters:";
          t3 = space();
          if (if_block0) if_block0.c();
          t4 = space();
          if (if_block1) if_block1.c();
          add_location(h2, file$9, 23, 4, 580);
          attr_dev(p, "class", "info svelte-1y6x2n5");
          add_location(p, file$9, 24, 4, 608);
          attr_dev(section, "class", "supporters-modal svelte-1y6x2n5");
          add_location(section, file$9, 22, 2, 541);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, h2);
          append_dev(section, t1);
          append_dev(section, p);
          append_dev(section, t3);
          if (if_block0) if_block0.m(section, null);
          append_dev(section, t4);
          if (if_block1) if_block1.m(section, null);
        },
        p: function update(ctx, dirty) {
          if (
          /*$sponsors*/
          ctx[2] &&
          /*$sponsors*/
          ctx[2].length) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_1$2(ctx);
              if_block0.c();
              if_block0.m(section, t4);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*$heroes*/
          ctx[0] &&
          /*displayHeroes*/
          ctx[1].length) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block$5(ctx);
              if_block1.c();
              if_block1.m(section, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot.name,
        type: "slot",
        source: "(22:0) <Overlay name=\\\"supporters\\\" fullSize>",
        ctx
      });
      return block;
    }

    function create_fragment$9(ctx) {
      let overlay_1;
      let current;
      overlay_1 = new Overlay({
        props: {
          name: "supporters",
          fullSize: true,
          $$slots: {
            default: [create_default_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(overlay_1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(overlay_1, target, anchor);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          const overlay_1_changes = {};

          if (dirty &
          /*$$scope, $overlay, displayHeroes, $heroes, $sponsors*/
          4111) {
            overlay_1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          overlay_1.$set(overlay_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(overlay_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(overlay_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(overlay_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
      let $heroes;
      let $sponsors;
      let $overlay;
      validate_store(heroes, 'heroes');
      component_subscribe($$self, heroes, $$value => $$invalidate(0, $heroes = $$value));
      validate_store(sponsors, 'sponsors');
      component_subscribe($$self, sponsors, $$value => $$invalidate(2, $sponsors = $$value));
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(3, $overlay = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('SupportersOverlay', slots, []);
      let displayHeroes = [];
      const writable_props = [];
      Object_1$1.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SupportersOverlay> was created with unknown prop '${key}'`);
      });

      const click_handler = () => {
        set_store_value(overlay, $overlay = 'donation', $overlay);
      };

      const click_handler_1 = () => {
        set_store_value(overlay, $overlay = 'donation', $overlay);
      };

      $$self.$capture_state = () => ({
        config: config$1,
        onMount,
        Overlay,
        overlay,
        tiers,
        sponsors,
        heroes,
        displayHeroes,
        $heroes,
        $sponsors,
        $overlay
      });

      $$self.$inject_state = $$props => {
        if ('displayHeroes' in $$props) $$invalidate(1, displayHeroes = $$props.displayHeroes);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$heroes*/
        1) {
          {
            if ($heroes) {
              $$invalidate(1, displayHeroes = Object.values($heroes).filter(hero => {
                return hero && hero.id && hero.img_ext;
              }).map(hero => {
                return { ...hero,
                  img: `${config$1.donationRoot}/img/avatar/${hero.id}${hero.img_ext}`
                };
              }));
            }
          }
        }
      };

      return [$heroes, displayHeroes, $sponsors, $overlay, click_handler, click_handler_1];
    }

    class SupportersOverlay extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SupportersOverlay",
          options,
          id: create_fragment$9.name
        });
      }

    }

    /* src/components/util/LoadingAnimation.svelte generated by Svelte v3.44.3 */
    const file$8 = "src/components/util/LoadingAnimation.svelte";

    function create_fragment$8(ctx) {
      let div25;
      let div0;
      let t0;
      let div24;
      let div23;
      let div2;
      let div1;
      let t1;
      let div4;
      let div3;
      let t2;
      let div6;
      let div5;
      let t3;
      let div8;
      let div7;
      let t4;
      let div10;
      let div9;
      let t5;
      let div12;
      let div11;
      let t6;
      let div14;
      let div13;
      let t7;
      let div16;
      let div15;
      let t8;
      let div18;
      let div17;
      let t9;
      let div20;
      let div19;
      let t10;
      let div22;
      let div21;
      const block = {
        c: function create() {
          div25 = element("div");
          div0 = element("div");
          t0 = space();
          div24 = element("div");
          div23 = element("div");
          div2 = element("div");
          div1 = element("div");
          t1 = space();
          div4 = element("div");
          div3 = element("div");
          t2 = space();
          div6 = element("div");
          div5 = element("div");
          t3 = space();
          div8 = element("div");
          div7 = element("div");
          t4 = space();
          div10 = element("div");
          div9 = element("div");
          t5 = space();
          div12 = element("div");
          div11 = element("div");
          t6 = space();
          div14 = element("div");
          div13 = element("div");
          t7 = space();
          div16 = element("div");
          div15 = element("div");
          t8 = space();
          div18 = element("div");
          div17 = element("div");
          t9 = space();
          div20 = element("div");
          div19 = element("div");
          t10 = space();
          div22 = element("div");
          div21 = element("div");
          attr_dev(div0, "class", "sizer svelte-h61izi");
          add_location(div0, file$8, 329, 2, 4866);
          attr_dev(div1, "class", "tx-inner svelte-h61izi");
          add_location(div1, file$8, 332, 49, 4989);
          attr_dev(div2, "class", "tx small a svelte-h61izi");
          set_style(div2, "left", "25%");
          add_location(div2, file$8, 332, 6, 4946);
          attr_dev(div3, "class", "tx-inner svelte-h61izi");
          add_location(div3, file$8, 333, 49, 5073);
          attr_dev(div4, "class", "tx small b svelte-h61izi");
          set_style(div4, "left", "35%");
          add_location(div4, file$8, 333, 6, 5030);
          attr_dev(div5, "class", "tx-inner svelte-h61izi");
          add_location(div5, file$8, 334, 49, 5157);
          attr_dev(div6, "class", "tx small c svelte-h61izi");
          set_style(div6, "left", "45%");
          add_location(div6, file$8, 334, 6, 5114);
          attr_dev(div7, "class", "tx-inner svelte-h61izi");
          add_location(div7, file$8, 335, 49, 5241);
          attr_dev(div8, "class", "tx large d svelte-h61izi");
          set_style(div8, "left", "55%");
          add_location(div8, file$8, 335, 6, 5198);
          attr_dev(div9, "class", "tx-inner svelte-h61izi");
          add_location(div9, file$8, 336, 49, 5325);
          attr_dev(div10, "class", "tx large e svelte-h61izi");
          set_style(div10, "left", "25%");
          add_location(div10, file$8, 336, 6, 5282);
          attr_dev(div11, "class", "tx-inner svelte-h61izi");
          add_location(div11, file$8, 337, 49, 5409);
          attr_dev(div12, "class", "tx small f svelte-h61izi");
          set_style(div12, "left", "45%");
          add_location(div12, file$8, 337, 6, 5366);
          attr_dev(div13, "class", "tx-inner svelte-h61izi");
          add_location(div13, file$8, 338, 49, 5493);
          attr_dev(div14, "class", "tx large g svelte-h61izi");
          set_style(div14, "left", "45%");
          add_location(div14, file$8, 338, 6, 5450);
          attr_dev(div15, "class", "tx-inner svelte-h61izi");
          add_location(div15, file$8, 339, 49, 5577);
          attr_dev(div16, "class", "tx small h svelte-h61izi");
          set_style(div16, "left", "65%");
          add_location(div16, file$8, 339, 6, 5534);
          attr_dev(div17, "class", "tx-inner svelte-h61izi");
          add_location(div17, file$8, 340, 49, 5661);
          attr_dev(div18, "class", "tx small i svelte-h61izi");
          set_style(div18, "left", "25%");
          add_location(div18, file$8, 340, 6, 5618);
          attr_dev(div19, "class", "tx-inner svelte-h61izi");
          add_location(div19, file$8, 341, 49, 5745);
          attr_dev(div20, "class", "tx small j svelte-h61izi");
          set_style(div20, "left", "35%");
          add_location(div20, file$8, 341, 6, 5702);
          attr_dev(div21, "class", "tx-inner svelte-h61izi");
          add_location(div21, file$8, 342, 49, 5829);
          attr_dev(div22, "class", "tx small j svelte-h61izi");
          set_style(div22, "left", "65%");
          add_location(div22, file$8, 342, 6, 5786);
          attr_dev(div23, "class", "mempool svelte-h61izi");
          add_location(div23, file$8, 331, 4, 4918);
          attr_dev(div24, "class", "bf-loader svelte-h61izi");
          add_location(div24, file$8, 330, 2, 4890);
          attr_dev(div25, "class", "wrapper svelte-h61izi");
          add_location(div25, file$8, 328, 0, 4842);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div25, anchor);
          append_dev(div25, div0);
          append_dev(div25, t0);
          append_dev(div25, div24);
          append_dev(div24, div23);
          append_dev(div23, div2);
          append_dev(div2, div1);
          append_dev(div23, t1);
          append_dev(div23, div4);
          append_dev(div4, div3);
          append_dev(div23, t2);
          append_dev(div23, div6);
          append_dev(div6, div5);
          append_dev(div23, t3);
          append_dev(div23, div8);
          append_dev(div8, div7);
          append_dev(div23, t4);
          append_dev(div23, div10);
          append_dev(div10, div9);
          append_dev(div23, t5);
          append_dev(div23, div12);
          append_dev(div12, div11);
          append_dev(div23, t6);
          append_dev(div23, div14);
          append_dev(div14, div13);
          append_dev(div23, t7);
          append_dev(div23, div16);
          append_dev(div16, div15);
          append_dev(div23, t8);
          append_dev(div23, div18);
          append_dev(div18, div17);
          append_dev(div23, t9);
          append_dev(div23, div20);
          append_dev(div20, div19);
          append_dev(div23, t10);
          append_dev(div23, div22);
          append_dev(div22, div21);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div25);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$8.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$8($$self, $$props) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('LoadingAnimation', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingAnimation> was created with unknown prop '${key}'`);
      });
      return [];
    }

    class LoadingAnimation extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "LoadingAnimation",
          options,
          id: create_fragment$8.name
        });
      }

    }

    /* src/components/alert/ByMononaut.svelte generated by Svelte v3.44.3 */
    const file$7 = "src/components/alert/ByMononaut.svelte";

    function create_fragment$7(ctx) {
      let div1;
      let h3;
      let t1;
      let p;
      let t3;
      let div0;
      let mononaut;
      let current;
      mononaut = new Mononaut({
        $$inline: true
      });
      const block = {
        c: function create() {
          div1 = element("div");
          h3 = element("h3");
          h3.textContent = "Bitfeed";
          t1 = space();
          p = element("p");
          p.textContent = "by mononaut";
          t3 = space();
          div0 = element("div");
          create_component(mononaut.$$.fragment);
          attr_dev(h3, "class", "svelte-1mnby4q");
          add_location(h3, file$7, 5, 2, 104);
          attr_dev(p, "class", "by svelte-1mnby4q");
          add_location(p, file$7, 6, 2, 123);
          attr_dev(div0, "class", "monkey-avatar svelte-1mnby4q");
          add_location(div0, file$7, 7, 2, 155);
          attr_dev(div1, "class", "alert-content by-mononaut svelte-1mnby4q");
          add_location(div1, file$7, 4, 0, 62);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h3);
          append_dev(div1, t1);
          append_dev(div1, p);
          append_dev(div1, t3);
          append_dev(div1, div0);
          mount_component(mononaut, div0, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(mononaut.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(mononaut.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(mononaut);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$7.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('ByMononaut', slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ByMononaut> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        Mononaut
      });

      return [];
    }

    class ByMononaut extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ByMononaut",
          options,
          id: create_fragment$7.name
        });
      }

    }

    /* src/components/alert/Hero.svelte generated by Svelte v3.44.3 */
    const {
      Object: Object_1
    } = globals;
    const file$6 = "src/components/alert/Hero.svelte";

    function get_each_context$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[3] = list[i];
      return child_ctx;
    } // (36:4) {#each displayHeroes as hero}


    function create_each_block$1(ctx) {
      let img;
      let img_src_value;
      let img_alt_value;
      let img_title_value;
      const block = {
        c: function create() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value =
          /*hero*/
          ctx[3].img)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", img_alt_value =
          /*hero*/
          ctx[3].username);
          attr_dev(img, "title", img_title_value =
          /*hero*/
          ctx[3].name);
          attr_dev(img, "class", "hero svelte-9j0k7k");
          add_location(img, file$6, 36, 6, 905);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*displayHeroes*/
          1 && !src_url_equal(img.src, img_src_value =
          /*hero*/
          ctx[3].img)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*displayHeroes*/
          1 && img_alt_value !== (img_alt_value =
          /*hero*/
          ctx[3].username)) {
            attr_dev(img, "alt", img_alt_value);
          }

          if (dirty &
          /*displayHeroes*/
          1 && img_title_value !== (img_title_value =
          /*hero*/
          ctx[3].name)) {
            attr_dev(img, "title", img_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$1.name,
        type: "each",
        source: "(36:4) {#each displayHeroes as hero}",
        ctx
      });
      return block;
    }

    function create_fragment$6(ctx) {
      let div1;
      let p;
      let t1;
      let div0;
      let each_value =
      /*displayHeroes*/
      ctx[0];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div1 = element("div");
          p = element("p");
          p.textContent = "Thank you to all of our Community Heroes!";
          t1 = space();
          div0 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(p, "class", "msg svelte-9j0k7k");
          add_location(p, file$6, 33, 2, 782);
          attr_dev(div0, "class", "heros svelte-9j0k7k");
          add_location(div0, file$6, 34, 2, 845);
          attr_dev(div1, "class", "alert-content svelte-9j0k7k");
          add_location(div1, file$6, 32, 0, 752);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, p);
          append_dev(div1, t1);
          append_dev(div1, div0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div0, null);
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*displayHeroes*/
          1) {
            each_value =
            /*displayHeroes*/
            ctx[0];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$1(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div0, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$6.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
      let $heroes;
      validate_store(heroes, 'heroes');
      component_subscribe($$self, heroes, $$value => $$invalidate(1, $heroes = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Hero', slots, []);
      let displayHeroes = [];

      function chooseRandomHeroes() {
        $$invalidate(0, displayHeroes = []);
        const validHeroes = Object.values($heroes).filter(hero => {
          return hero && hero.id && hero.img_ext;
        });
        const randomIndex = Math.floor(Math.random() * validHeroes.length);

        for (let i = 0; i < Math.min(3, validHeroes.length); i++) {
          const randomHero = validHeroes[(randomIndex + i) % validHeroes.length];
          displayHeroes.push({ ...randomHero,
            img: `${config$1.donationRoot}/img/avatar/${randomHero.id}${randomHero.img_ext}`
          });
        }
      }

      const writable_props = [];
      Object_1.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hero> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        onMount,
        config: config$1,
        heroes,
        displayHeroes,
        chooseRandomHeroes,
        $heroes
      });

      $$self.$inject_state = $$props => {
        if ('displayHeroes' in $$props) $$invalidate(0, displayHeroes = $$props.displayHeroes);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$heroes, displayHeroes*/
        3) {
          {
            if ($heroes && !displayHeroes.length) {
              chooseRandomHeroes();
            }
          }
        }
      };

      return [displayHeroes, $heroes];
    }

    class Hero extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Hero",
          options,
          id: create_fragment$6.name
        });
      }

    }

    /* src/components/alert/Sponsored.svelte generated by Svelte v3.44.3 */
    const file$5 = "src/components/alert/Sponsored.svelte"; // (9:2) {#if img}

    function create_if_block$4(ctx) {
      let img_1;
      let img_1_src_value;
      const block = {
        c: function create() {
          img_1 = element("img");
          if (!src_url_equal(img_1.src, img_1_src_value =
          /*img*/
          ctx[0])) attr_dev(img_1, "src", img_1_src_value);
          attr_dev(img_1, "alt", "name");
          attr_dev(img_1, "class", "logo svelte-14stmeo");
          add_location(img_1, file$5, 9, 4, 162);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img_1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*img*/
          1 && !src_url_equal(img_1.src, img_1_src_value =
          /*img*/
          ctx[0])) {
            attr_dev(img_1, "src", img_1_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(9:2) {#if img}",
        ctx
      });
      return block;
    }

    function create_fragment$5(ctx) {
      let div;
      let p;
      let t1;
      let h3;
      let t2;
      let t3;
      let if_block =
      /*img*/
      ctx[0] && create_if_block$4(ctx);
      const block = {
        c: function create() {
          div = element("div");
          p = element("p");
          p.textContent = "Sponsored by";
          t1 = space();
          h3 = element("h3");
          t2 = text(
          /*name*/
          ctx[1]);
          t3 = space();
          if (if_block) if_block.c();
          attr_dev(p, "class", "msg svelte-14stmeo");
          add_location(p, file$5, 6, 2, 94);
          attr_dev(h3, "class", "svelte-14stmeo");
          add_location(h3, file$5, 7, 2, 128);
          attr_dev(div, "class", "alert-content sponsored-by svelte-14stmeo");
          add_location(div, file$5, 5, 0, 51);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p);
          append_dev(div, t1);
          append_dev(div, h3);
          append_dev(h3, t2);
          append_dev(div, t3);
          if (if_block) if_block.m(div, null);
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*name*/
          2) set_data_dev(t2,
          /*name*/
          ctx[1]);

          if (
          /*img*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$4(ctx);
              if_block.c();
              if_block.m(div, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$5.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Sponsored', slots, []);
      let {
        img
      } = $$props;
      let {
        name
      } = $$props;
      const writable_props = ['img', 'name'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sponsored> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('img' in $$props) $$invalidate(0, img = $$props.img);
        if ('name' in $$props) $$invalidate(1, name = $$props.name);
      };

      $$self.$capture_state = () => ({
        img,
        name
      });

      $$self.$inject_state = $$props => {
        if ('img' in $$props) $$invalidate(0, img = $$props.img);
        if ('name' in $$props) $$invalidate(1, name = $$props.name);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [img, name];
    }

    class Sponsored extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$5, create_fragment$5, safe_not_equal, {
          img: 0,
          name: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Sponsored",
          options,
          id: create_fragment$5.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*img*/
        ctx[0] === undefined && !('img' in props)) {
          console.warn("<Sponsored> was created without expected prop 'img'");
        }

        if (
        /*name*/
        ctx[1] === undefined && !('name' in props)) {
          console.warn("<Sponsored> was created without expected prop 'name'");
        }
      }

      get img() {
        throw new Error("<Sponsored>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set img(value) {
        throw new Error("<Sponsored>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get name() {
        throw new Error("<Sponsored>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set name(value) {
        throw new Error("<Sponsored>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/alert/GenericAlert.svelte generated by Svelte v3.44.3 */
    const file$4 = "src/components/alert/GenericAlert.svelte"; // (14:2) {#if img}

    function create_if_block$3(ctx) {
      let img_1;
      let img_1_src_value;
      const block = {
        c: function create() {
          img_1 = element("img");
          if (!src_url_equal(img_1.src, img_1_src_value =
          /*img*/
          ctx[2])) attr_dev(img_1, "src", img_1_src_value);
          attr_dev(img_1, "alt", "");
          attr_dev(img_1, "class", "svelte-1kuvj17");
          add_location(img_1, file$4, 14, 4, 236);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img_1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*img*/
          4 && !src_url_equal(img_1.src, img_1_src_value =
          /*img*/
          ctx[2])) {
            attr_dev(img_1, "src", img_1_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(14:2) {#if img}",
        ctx
      });
      return block;
    }

    function create_fragment$4(ctx) {
      let div;
      let p0;
      let t0;
      let p1;
      let raw1_value = (
      /*shortmsg*/
      ctx[1] ||
      /*msg*/
      ctx[0]) + "";
      let t1;
      let if_block =
      /*img*/
      ctx[2] && create_if_block$3(ctx);
      const block = {
        c: function create() {
          div = element("div");
          p0 = element("p");
          t0 = space();
          p1 = element("p");
          t1 = space();
          if (if_block) if_block.c();
          attr_dev(p0, "class", "msg svelte-1kuvj17");
          add_location(p0, file$4, 7, 2, 121);
          attr_dev(p1, "class", "shortmsg svelte-1kuvj17");
          add_location(p1, file$4, 10, 2, 163);
          attr_dev(div, "class", "alert-content generic-alert svelte-1kuvj17");
          add_location(div, file$4, 6, 0, 77);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p0);
          p0.innerHTML =
          /*msg*/
          ctx[0];
          append_dev(div, t0);
          append_dev(div, p1);
          p1.innerHTML = raw1_value;
          append_dev(div, t1);
          if (if_block) if_block.m(div, null);
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*msg*/
          1) p0.innerHTML =
          /*msg*/
          ctx[0];
          if (dirty &
          /*shortmsg, msg*/
          3 && raw1_value !== (raw1_value = (
          /*shortmsg*/
          ctx[1] ||
          /*msg*/
          ctx[0]) + "")) p1.innerHTML = raw1_value;

          if (
          /*img*/
          ctx[2]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$3(ctx);
              if_block.c();
              if_block.m(div, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$4.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('GenericAlert', slots, []);
      let {
        msg
      } = $$props;
      let {
        shortmsg = null
      } = $$props;
      let {
        img
      } = $$props;
      const writable_props = ['msg', 'shortmsg', 'img'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GenericAlert> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
        if ('shortmsg' in $$props) $$invalidate(1, shortmsg = $$props.shortmsg);
        if ('img' in $$props) $$invalidate(2, img = $$props.img);
      };

      $$self.$capture_state = () => ({
        msg,
        shortmsg,
        img
      });

      $$self.$inject_state = $$props => {
        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
        if ('shortmsg' in $$props) $$invalidate(1, shortmsg = $$props.shortmsg);
        if ('img' in $$props) $$invalidate(2, img = $$props.img);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [msg, shortmsg, img];
    }

    class GenericAlert extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
          msg: 0,
          shortmsg: 1,
          img: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "GenericAlert",
          options,
          id: create_fragment$4.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*msg*/
        ctx[0] === undefined && !('msg' in props)) {
          console.warn("<GenericAlert> was created without expected prop 'msg'");
        }

        if (
        /*img*/
        ctx[2] === undefined && !('img' in props)) {
          console.warn("<GenericAlert> was created without expected prop 'img'");
        }
      }

      get msg() {
        throw new Error("<GenericAlert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set msg(value) {
        throw new Error("<GenericAlert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get shortmsg() {
        throw new Error("<GenericAlert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set shortmsg(value) {
        throw new Error("<GenericAlert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get img() {
        throw new Error("<GenericAlert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set img(value) {
        throw new Error("<GenericAlert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/alert/GenericAlertv2.svelte generated by Svelte v3.44.3 */
    const file$3 = "src/components/alert/GenericAlertv2.svelte";

    function get_each_context(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[5] = list[i];
      return child_ctx;
    } // (37:4) {:else}


    function create_else_block$2(ctx) {
      let img;
      let img_src_value;
      let img_alt_value;
      let img_title_value;
      const block = {
        c: function create() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value =
          /*img*/
          ctx[5].img)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", img_alt_value =
          /*img*/
          ctx[5].name);
          attr_dev(img, "title", img_title_value =
          /*img*/
          ctx[5].name);
          attr_dev(img, "class", "image svelte-iikpw9");
          add_location(img, file$3, 37, 6, 804);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*displayImgs*/
          4 && !src_url_equal(img.src, img_src_value =
          /*img*/
          ctx[5].img)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*displayImgs*/
          4 && img_alt_value !== (img_alt_value =
          /*img*/
          ctx[5].name)) {
            attr_dev(img, "alt", img_alt_value);
          }

          if (dirty &
          /*displayImgs*/
          4 && img_title_value !== (img_title_value =
          /*img*/
          ctx[5].name)) {
            attr_dev(img, "title", img_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(37:4) {:else}",
        ctx
      });
      return block;
    } // (33:4) {#if img.href }


    function create_if_block$2(ctx) {
      let a;
      let img;
      let img_src_value;
      let img_alt_value;
      let img_title_value;
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          img = element("img");
          t = space();
          if (!src_url_equal(img.src, img_src_value =
          /*img*/
          ctx[5].img)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", img_alt_value =
          /*img*/
          ctx[5].name);
          attr_dev(img, "title", img_title_value =
          /*img*/
          ctx[5].name);
          attr_dev(img, "class", "image svelte-iikpw9");
          add_location(img, file$3, 34, 8, 709);
          attr_dev(a, "href", a_href_value =
          /*img*/
          ctx[5].href);
          attr_dev(a, "target", "_blank");
          add_location(a, file$3, 33, 6, 665);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, img);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*displayImgs*/
          4 && !src_url_equal(img.src, img_src_value =
          /*img*/
          ctx[5].img)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*displayImgs*/
          4 && img_alt_value !== (img_alt_value =
          /*img*/
          ctx[5].name)) {
            attr_dev(img, "alt", img_alt_value);
          }

          if (dirty &
          /*displayImgs*/
          4 && img_title_value !== (img_title_value =
          /*img*/
          ctx[5].name)) {
            attr_dev(img, "title", img_title_value);
          }

          if (dirty &
          /*displayImgs*/
          4 && a_href_value !== (a_href_value =
          /*img*/
          ctx[5].href)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(33:4) {#if img.href }",
        ctx
      });
      return block;
    } // (32:4) {#each displayImgs as img}


    function create_each_block(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (
        /*img*/
        ctx[5].href) return create_if_block$2;
        return create_else_block$2;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block.name,
        type: "each",
        source: "(32:4) {#each displayImgs as img}",
        ctx
      });
      return block;
    }

    function create_fragment$3(ctx) {
      let div1;
      let p0;
      let t0;
      let p1;
      let raw1_value = (
      /*shortmsg*/
      ctx[1] ||
      /*msg*/
      ctx[0]) + "";
      let t1;
      let div0;
      let each_value =
      /*displayImgs*/
      ctx[2];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div1 = element("div");
          p0 = element("p");
          t0 = space();
          p1 = element("p");
          t1 = space();
          div0 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(p0, "class", "msg svelte-iikpw9");
          add_location(p0, file$3, 24, 2, 488);
          attr_dev(p1, "class", "shortmsg svelte-iikpw9");
          add_location(p1, file$3, 27, 2, 530);
          attr_dev(div0, "class", "imgs svelte-iikpw9");
          add_location(div0, file$3, 30, 2, 589);
          attr_dev(div1, "class", "alert-content svelte-iikpw9");
          add_location(div1, file$3, 23, 0, 458);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, p0);
          p0.innerHTML =
          /*msg*/
          ctx[0];
          append_dev(div1, t0);
          append_dev(div1, p1);
          p1.innerHTML = raw1_value;
          append_dev(div1, t1);
          append_dev(div1, div0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div0, null);
          }
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;
          if (dirty &
          /*msg*/
          1) p0.innerHTML =
          /*msg*/
          ctx[0];
          if (dirty &
          /*shortmsg, msg*/
          3 && raw1_value !== (raw1_value = (
          /*shortmsg*/
          ctx[1] ||
          /*msg*/
          ctx[0]) + "")) p1.innerHTML = raw1_value;

          if (dirty &
          /*displayImgs*/
          4) {
            each_value =
            /*displayImgs*/
            ctx[2];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div0, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$3.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('GenericAlertv2', slots, []);
      let {
        msg
      } = $$props;
      let {
        shortmsg = null
      } = $$props;
      let {
        imgs
      } = $$props;
      let displayImgs = [];

      function chooseImgs() {
        $$invalidate(2, displayImgs = []);
        const randomIndex = Math.floor(Math.random() * imgs.length);

        for (let i = 0; i < Math.min(3, imgs.length); i++) {
          const randomImg = imgs[(randomIndex + i) % imgs.length];
          if (randomImg && randomImg.img) displayImgs.push(randomImg);
        }
      }

      const writable_props = ['msg', 'shortmsg', 'imgs'];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GenericAlertv2> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
        if ('shortmsg' in $$props) $$invalidate(1, shortmsg = $$props.shortmsg);
        if ('imgs' in $$props) $$invalidate(3, imgs = $$props.imgs);
      };

      $$self.$capture_state = () => ({
        msg,
        shortmsg,
        imgs,
        displayImgs,
        chooseImgs
      });

      $$self.$inject_state = $$props => {
        if ('msg' in $$props) $$invalidate(0, msg = $$props.msg);
        if ('shortmsg' in $$props) $$invalidate(1, shortmsg = $$props.shortmsg);
        if ('imgs' in $$props) $$invalidate(3, imgs = $$props.imgs);
        if ('displayImgs' in $$props) $$invalidate(2, displayImgs = $$props.displayImgs);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*imgs, displayImgs*/
        12) {
          {
            if (imgs && !displayImgs.length) {
              chooseImgs();
            }
          }
        }
      };

      return [msg, shortmsg, displayImgs, imgs];
    }

    class GenericAlertv2 extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$3, create_fragment$3, safe_not_equal, {
          msg: 0,
          shortmsg: 1,
          imgs: 3
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "GenericAlertv2",
          options,
          id: create_fragment$3.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*msg*/
        ctx[0] === undefined && !('msg' in props)) {
          console.warn("<GenericAlertv2> was created without expected prop 'msg'");
        }

        if (
        /*imgs*/
        ctx[3] === undefined && !('imgs' in props)) {
          console.warn("<GenericAlertv2> was created without expected prop 'imgs'");
        }
      }

      get msg() {
        throw new Error("<GenericAlertv2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set msg(value) {
        throw new Error("<GenericAlertv2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get shortmsg() {
        throw new Error("<GenericAlertv2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set shortmsg(value) {
        throw new Error("<GenericAlertv2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get imgs() {
        throw new Error("<GenericAlertv2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set imgs(value) {
        throw new Error("<GenericAlertv2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src/components/alert/Alerts.svelte generated by Svelte v3.44.3 */
    const file$2 = "src/components/alert/Alerts.svelte"; // (101:6) {#if alert && alert.component }

    function create_if_block$1(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_1$1, create_if_block_2$1, create_else_block$1];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*alert*/
        ctx[0].href) return 0;
        if (
        /*alert*/
        ctx[0].action) return 1;
        return 2;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$1.name,
        type: "if",
        source: "(101:6) {#if alert && alert.component }",
        ctx
      });
      return block;
    } // (110:8) {:else}


    function create_else_block$1(ctx) {
      let div;
      let switch_instance;
      let current;
      const switch_instance_spread_levels = [
      /*alert*/
      ctx[0], {
        sequence:
        /*sequences*/
        ctx[1][
        /*alert*/
        ctx[0].key]
      }];
      var switch_value =
      /*alert*/
      ctx[0].component;

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }

        return {
          props: switch_instance_props,
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(div, "class", "alert svelte-1qjc0zv");
          add_location(div, file$2, 110, 10, 2923);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = dirty &
          /*alert, sequences*/
          3 ? get_spread_update(switch_instance_spread_levels, [dirty &
          /*alert*/
          1 && get_spread_object(
          /*alert*/
          ctx[0]), {
            sequence:
            /*sequences*/
            ctx[1][
            /*alert*/
            ctx[0].key]
          }]) : {};

          if (switch_value !== (switch_value =
          /*alert*/
          ctx[0].component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(110:8) {:else}",
        ctx
      });
      return block;
    } // (106:31) 


    function create_if_block_2$1(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      const switch_instance_spread_levels = [
      /*alert*/
      ctx[0], {
        sequence:
        /*sequences*/
        ctx[1][
        /*alert*/
        ctx[0].key]
      }];
      var switch_value =
      /*alert*/
      ctx[0].component;

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }

        return {
          props: switch_instance_props,
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(div, "class", "alert action svelte-1qjc0zv");
          add_location(div, file$2, 106, 10, 2730);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click", function () {
              if (is_function(
              /*alert*/
              ctx[0].action))
                /*alert*/
                ctx[0].action.apply(this, arguments);
            }, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const switch_instance_changes = dirty &
          /*alert, sequences*/
          3 ? get_spread_update(switch_instance_spread_levels, [dirty &
          /*alert*/
          1 && get_spread_object(
          /*alert*/
          ctx[0]), {
            sequence:
            /*sequences*/
            ctx[1][
            /*alert*/
            ctx[0].key]
          }]) : {};

          if (switch_value !== (switch_value =
          /*alert*/
          ctx[0].component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$1.name,
        type: "if",
        source: "(106:31) ",
        ctx
      });
      return block;
    } // (102:8) {#if alert.href}


    function create_if_block_1$1(ctx) {
      let a;
      let switch_instance;
      let a_href_value;
      let current;
      const switch_instance_spread_levels = [
      /*alert*/
      ctx[0], {
        sequence:
        /*sequences*/
        ctx[1][
        /*alert*/
        ctx[0].key]
      }];
      var switch_value =
      /*alert*/
      ctx[0].component;

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }

        return {
          props: switch_instance_props,
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          a = element("a");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr_dev(a, "class", "alert link svelte-1qjc0zv");
          attr_dev(a, "target", "_blank");
          attr_dev(a, "rel", "noopener");
          attr_dev(a, "href", a_href_value =
          /*alert*/
          ctx[0].href);
          add_location(a, file$2, 102, 10, 2502);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);

          if (switch_instance) {
            mount_component(switch_instance, a, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          const switch_instance_changes = dirty &
          /*alert, sequences*/
          3 ? get_spread_update(switch_instance_spread_levels, [dirty &
          /*alert*/
          1 && get_spread_object(
          /*alert*/
          ctx[0]), {
            sequence:
            /*sequences*/
            ctx[1][
            /*alert*/
            ctx[0].key]
          }]) : {};

          if (switch_value !== (switch_value =
          /*alert*/
          ctx[0].component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, a, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }

          if (!current || dirty &
          /*alert*/
          1 && a_href_value !== (a_href_value =
          /*alert*/
          ctx[0].href)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          if (switch_instance) destroy_component(switch_instance);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(102:8) {#if alert.href}",
        ctx
      });
      return block;
    } // (99:2) {#key alert && alert.key}


    function create_key_block(ctx) {
      let div;
      let div_intro;
      let div_outro;
      let current;
      let if_block =
      /*alert*/
      ctx[0] &&
      /*alert*/
      ctx[0].component && create_if_block$1(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block) if_block.c();
          attr_dev(div, "class", "alert-wrapper svelte-1qjc0zv");
          add_location(div, file$2, 99, 4, 2348);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*alert*/
          ctx[0] &&
          /*alert*/
          ctx[0].component) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*alert*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$1(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          add_render_callback(() => {
            if (div_outro) div_outro.end(1);
            div_intro = create_in_transition(div, fly, {
              y: -100,
              delay: 400
            });
            div_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          if (div_intro) div_intro.invalidate();
          div_outro = create_out_transition(div, fly, {
            x: 400
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
          if (detaching && div_outro) div_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_key_block.name,
        type: "key",
        source: "(99:2) {#key alert && alert.key}",
        ctx
      });
      return block;
    }

    function create_fragment$2(ctx) {
      let div;
      let previous_key =
      /*alert*/
      ctx[0] &&
      /*alert*/
      ctx[0].key;
      let current;
      let key_block = create_key_block(ctx);
      const block = {
        c: function create() {
          div = element("div");
          key_block.c();
          attr_dev(div, "class", "alert-bar svelte-1qjc0zv");
          add_location(div, file$2, 97, 0, 2292);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          key_block.m(div, null);
          current = true;
        },
        p: function update(ctx, _ref) {
          let [dirty] = _ref;

          if (dirty &
          /*alert*/
          1 && safe_not_equal(previous_key, previous_key =
          /*alert*/
          ctx[0] &&
          /*alert*/
          ctx[0].key)) {
            group_outros();
            transition_out(key_block, 1, 1, noop);
            check_outros();
            key_block = create_key_block(ctx);
            key_block.c();
            transition_in(key_block);
            key_block.m(div, null);
          } else {
            key_block.p(ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(key_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(key_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          key_block.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$2.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
      let $alerts;
      let $sidebarToggle;
      let $overlay;
      let $haveSupporters;
      validate_store(alerts, 'alerts');
      component_subscribe($$self, alerts, $$value => $$invalidate(3, $alerts = $$value));
      validate_store(sidebarToggle, 'sidebarToggle');
      component_subscribe($$self, sidebarToggle, $$value => $$invalidate(9, $sidebarToggle = $$value));
      validate_store(overlay, 'overlay');
      component_subscribe($$self, overlay, $$value => $$invalidate(10, $overlay = $$value));
      validate_store(haveSupporters, 'haveSupporters');
      component_subscribe($$self, haveSupporters, $$value => $$invalidate(4, $haveSupporters = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('Alerts', slots, []);
      const components = {
        mononaut: ByMononaut,
        "sponsored-by": Sponsored,
        // "be-a-hero": BeAHero,
        "thank-you-hero": Hero,
        msg: GenericAlert,
        msg2: GenericAlertv2
      };
      let ready;
      const actions = {
        support: () => {
          set_store_value(overlay, $overlay = 'donation', $overlay);
        },
        supporters: () => {
          set_store_value(overlay, $overlay = 'supporters', $overlay);
        },
        contact: () => {
          set_store_value(sidebarToggle, $sidebarToggle = 'contact', $sidebarToggle);
        }
      };
      const sequences = {};
      let rotating = false;
      let processedAlerts = [];

      function processAlert(alert) {
        if (alert && alert.type && components[alert.type] && ready[alert.type] && (!alert.publicOnly || config$1.public)) {
          if (!sequences[alert.key]) $$invalidate(1, sequences[alert.key] = 0, sequences);
          return { ...alert,
            component: components[alert.type],
            action: actions[alert.action] || null
          };
        } else return null;
      }

      let alert;
      let lastIndex = -1;
      onMount(() => {
        startAlerts();
      });

      function startAlerts() {
        if (!rotating && processedAlerts && processedAlerts.length) {
          rotating = true;
          $$invalidate(0, alert = processedAlerts[0] || {
            key: 'null1'
          });
          lastIndex = 0;
          if (rotateTimer) clearTimeout(rotateTimer);
          rotateTimer = setTimeout(rotateAlerts, config$1.alertDuration);
        }
      }

      let rotateTimer;

      function rotateAlerts() {
        if (rotateTimer) clearTimeout(rotateTimer);

        if (processedAlerts && processedAlerts.length > 1) {
          // find the next alert in the queue
          let currentIndex = (lastIndex + 1) % processedAlerts.length;
          lastIndex = currentIndex;
          $$invalidate(0, alert = processedAlerts[currentIndex]);
        }

        rotateTimer = setTimeout(rotateAlerts, config$1.alertDuration);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Alerts> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        onMount,
        alerts,
        heroes,
        sponsors,
        overlay,
        sidebarToggle,
        haveSupporters,
        config: config$1,
        ByMononaut,
        HeroMsg: Hero,
        SponsoredMsg: Sponsored,
        GenericAlert,
        GenericAlertv2,
        fly,
        components,
        ready,
        actions,
        sequences,
        rotating,
        processedAlerts,
        processAlert,
        alert,
        lastIndex,
        startAlerts,
        rotateTimer,
        rotateAlerts,
        $alerts,
        $sidebarToggle,
        $overlay,
        $haveSupporters
      });

      $$self.$inject_state = $$props => {
        if ('ready' in $$props) $$invalidate(2, ready = $$props.ready);
        if ('rotating' in $$props) rotating = $$props.rotating;
        if ('processedAlerts' in $$props) processedAlerts = $$props.processedAlerts;
        if ('alert' in $$props) $$invalidate(0, alert = $$props.alert);
        if ('lastIndex' in $$props) lastIndex = $$props.lastIndex;
        if ('rotateTimer' in $$props) rotateTimer = $$props.rotateTimer;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$haveSupporters*/
        16) {
          {
            $$invalidate(2, ready = {
              mononaut: true,
              "sponsored-by": true,
              "thank-you-hero": $haveSupporters ? Hero : null,
              msg: true,
              msg2: true
            });
          }
        }

        if ($$self.$$.dirty &
        /*$alerts, ready*/
        12) {
          {
            if ($alerts && ready) {
              processedAlerts = $alerts.map(processAlert).filter(alert => alert != null);
              startAlerts();
            }
          }
        }
      };

      return [alert, sequences, ready, $alerts, $haveSupporters];
    }

    class Alerts extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Alerts",
          options,
          id: create_fragment$2.name
        });
      }

    }

    /* src/components/TxViz.svelte generated by Svelte v3.44.3 */
    const {
      window: window_1
    } = globals;
    const file$1 = "src/components/TxViz.svelte"; // (481:6) {:else}

    function create_else_block_1(ctx) {
      let span;
      let t0;
      let t1_value = numberFormat.format(Math.round(
      /*$mempoolCount*/
      ctx[10])) + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text("Mempool: ");
          t1 = text(t1_value);
          t2 = text(" unconfirmed");
          attr_dev(span, "class", "mempool-count svelte-1ffk99m");
          add_location(span, file$1, 481, 8, 11268);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          append_dev(span, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$mempoolCount*/
          1024 && t1_value !== (t1_value = numberFormat.format(Math.round(
          /*$mempoolCount*/
          ctx[10])) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1.name,
        type: "else",
        source: "(481:6) {:else}",
        ctx
      });
      return block;
    } // (476:6) {#if $tinyScreen}


    function create_if_block_12(ctx) {
      let div;
      let span0;
      let t1;
      let span1;
      let t2_value = numberFormat.format(Math.round(
      /*$mempoolCount*/
      ctx[10])) + "";
      let t2;
      const block = {
        c: function create() {
          div = element("div");
          span0 = element("span");
          span0.textContent = "Mempool";
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          attr_dev(span0, "class", "left");
          add_location(span0, file$1, 477, 10, 11109);
          attr_dev(span1, "class", "right");
          add_location(span1, file$1, 478, 10, 11153);
          attr_dev(div, "class", "mempool-info svelte-1ffk99m");
          add_location(div, file$1, 476, 8, 11072);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span0);
          append_dev(div, t1);
          append_dev(div, span1);
          append_dev(span1, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$mempoolCount*/
          1024 && t2_value !== (t2_value = numberFormat.format(Math.round(
          /*$mempoolCount*/
          ctx[10])) + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12.name,
        type: "if",
        source: "(476:6) {#if $tinyScreen}",
        ctx
      });
      return block;
    } // (492:8) {#if config.dev && config.debug && $devSettings.guides }


    function create_if_block_11(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "guide-area svelte-1ffk99m");
          add_location(div, file$1, 492, 10, 11883);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11.name,
        type: "if",
        source: "(492:8) {#if config.dev && config.debug && $devSettings.guides }",
        ctx
      });
      return block;
    } // (501:2) {#if $selectedTx }


    function create_if_block_10(ctx) {
      let txinfo;
      let current;
      txinfo = new TxInfo({
        props: {
          tx:
          /*$selectedTx*/
          ctx[16],
          position:
          /*mousePosition*/
          ctx[6]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(txinfo.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(txinfo, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const txinfo_changes = {};
          if (dirty[0] &
          /*$selectedTx*/
          65536) txinfo_changes.tx =
          /*$selectedTx*/
          ctx[16];
          if (dirty[0] &
          /*mousePosition*/
          64) txinfo_changes.position =
          /*mousePosition*/
          ctx[6];
          txinfo.$set(txinfo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(txinfo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(txinfo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(txinfo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10.name,
        type: "if",
        source: "(501:2) {#if $selectedTx }",
        ctx
      });
      return block;
    } // (508:8) {#if $settings.showFX && fxLabel }


    function create_if_block_9(ctx) {
      let span;
      let t;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          span = element("span");
          t = text(
          /*fxLabel*/
          ctx[5]);
          attr_dev(span, "class", "fx-ticker " + fxColor + " svelte-1ffk99m");
          add_location(span, file$1, 508, 10, 12262);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler*/
            ctx[33], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*fxLabel*/
          32) set_data_dev(t,
          /*fxLabel*/
          ctx[5]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9.name,
        type: "if",
        source: "(508:8) {#if $settings.showFX && fxLabel }",
        ctx
      });
      return block;
    } // (511:8) {#if $tinyScreen && $currentBlock }


    function create_if_block_8(ctx) {
      let span;
      let b;
      let t1_value = numberFormat.format(
      /*$currentBlock*/
      ctx[14].height) + "";
      let t1;
      const block = {
        c: function create() {
          span = element("span");
          b = element("b");
          b.textContent = "Block: ";
          t1 = text(t1_value);
          add_location(b, file$1, 511, 37, 12458);
          attr_dev(span, "class", "block-height svelte-1ffk99m");
          add_location(span, file$1, 511, 10, 12431);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, b);
          append_dev(span, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$currentBlock*/
          16384 && t1_value !== (t1_value = numberFormat.format(
          /*$currentBlock*/
          ctx[14].height) + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8.name,
        type: "if",
        source: "(511:8) {#if $tinyScreen && $currentBlock }",
        ctx
      });
      return block;
    } // (516:8) {#if $settings.showNetworkStatus }


    function create_if_block_7(ctx) {
      let div;
      let div_class_value;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", div_class_value = "status-light " +
          /*connectionColor*/
          ctx[8] + " svelte-1ffk99m");
          attr_dev(div, "title",
          /*connectionTitle*/
          ctx[7]);
          add_location(div, file$1, 516, 10, 12629);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*connectionColor*/
          256 && div_class_value !== (div_class_value = "status-light " +
          /*connectionColor*/
          ctx[8] + " svelte-1ffk99m")) {
            attr_dev(div, "class", div_class_value);
          }

          if (dirty[0] &
          /*connectionTitle*/
          128) {
            attr_dev(div, "title",
            /*connectionTitle*/
            ctx[7]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7.name,
        type: "if",
        source: "(516:8) {#if $settings.showNetworkStatus }",
        ctx
      });
      return block;
    } // (521:4) {#if $settings.showSearch && !$tinyScreen && !$compactScreen }


    function create_if_block_6(ctx) {
      let div;
      let searchbar;
      let current;
      searchbar = new SearchBar({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(searchbar.$$.fragment);
          attr_dev(div, "class", "search-bar-wrapper svelte-1ffk99m");
          add_location(div, file$1, 521, 6, 12815);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(searchbar, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(searchbar.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(searchbar.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(searchbar);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6.name,
        type: "if",
        source: "(521:4) {#if $settings.showSearch && !$tinyScreen && !$compactScreen }",
        ctx
      });
      return block;
    } // (526:4) {#if !$tinyScreen}


    function create_if_block_4(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let current;
      const if_block_creators = [create_if_block_5, create_else_block];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (config$1.messagesEnabled &&
        /*$settings*/
        ctx[1].showMessages) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          div = element("div");
          if_block.c();
          attr_dev(div, "class", "alert-bar-wrapper svelte-1ffk99m");
          add_location(div, file$1, 526, 6, 12922);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index !== previous_block_index) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4.name,
        type: "if",
        source: "(526:4) {#if !$tinyScreen}",
        ctx
      });
      return block;
    } // (530:8) {:else}


    function create_else_block(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "spacer svelte-1ffk99m");
          add_location(div, file$1, 530, 10, 13064);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block.name,
        type: "else",
        source: "(530:8) {:else}",
        ctx
      });
      return block;
    } // (528:8) {#if config.messagesEnabled && $settings.showMessages}


    function create_if_block_5(ctx) {
      let alerts;
      let current;
      alerts = new Alerts({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(alerts.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(alerts, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(alerts.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(alerts.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(alerts, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5.name,
        type: "if",
        source: "(528:8) {#if config.messagesEnabled && $settings.showMessages}",
        ctx
      });
      return block;
    } // (541:2) {#if config.donationsEnabled }


    function create_if_block_2(ctx) {
      let donationoverlay;
      let t;
      let if_block_anchor;
      let current;
      donationoverlay = new DonationOverlay({
        $$inline: true
      });
      let if_block =
      /*$haveSupporters*/
      ctx[19] && create_if_block_3(ctx);
      const block = {
        c: function create() {
          create_component(donationoverlay.$$.fragment);
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          mount_component(donationoverlay, target, anchor);
          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*$haveSupporters*/
          ctx[19]) {
            if (if_block) {
              if (dirty[0] &
              /*$haveSupporters*/
              524288) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_3(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(donationoverlay.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(donationoverlay.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(donationoverlay, detaching);
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2.name,
        type: "if",
        source: "(541:2) {#if config.donationsEnabled }",
        ctx
      });
      return block;
    } // (543:4) {#if $haveSupporters}


    function create_if_block_3(ctx) {
      let supportersoverlay;
      let current;
      supportersoverlay = new SupportersOverlay({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(supportersoverlay.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(supportersoverlay, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(supportersoverlay.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(supportersoverlay.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(supportersoverlay, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3.name,
        type: "if",
        source: "(543:4) {#if $haveSupporters}",
        ctx
      });
      return block;
    } // (548:2) {#if $loading}


    function create_if_block_1(ctx) {
      let div1;
      let div0;
      let loadinganimation;
      let t0;
      let p;
      let div1_intro;
      let div1_outro;
      let current;
      loadinganimation = new LoadingAnimation({
        $$inline: true
      });
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          create_component(loadinganimation.$$.fragment);
          t0 = space();
          p = element("p");
          p.textContent = "loading";
          attr_dev(p, "class", "loading-msg svelte-1ffk99m");
          add_location(p, file$1, 551, 8, 13521);
          attr_dev(div0, "class", "loading-wrapper svelte-1ffk99m");
          add_location(div0, file$1, 549, 6, 13454);
          attr_dev(div1, "class", "loading-overlay svelte-1ffk99m");
          add_location(div1, file$1, 548, 4, 13348);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          mount_component(loadinganimation, div0, null);
          append_dev(div0, t0);
          append_dev(div0, p);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(loadinganimation.$$.fragment, local);
          add_render_callback(() => {
            if (div1_outro) div1_outro.end(1);
            div1_intro = create_in_transition(div1, fade, {
              delay: 1000,
              duration: 500
            });
            div1_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(loadinganimation.$$.fragment, local);
          if (div1_intro) div1_intro.invalidate();
          div1_outro = create_out_transition(div1, fade, {
            duration: 200
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(loadinganimation);
          if (detaching && div1_outro) div1_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1.name,
        type: "if",
        source: "(548:2) {#if $loading}",
        ctx
      });
      return block;
    } // (557:2) {#if config.dev && config.debug && $devSettings.guides }


    function create_if_block(ctx) {
      let div4;
      let div0;
      let t0;
      let div1;
      let t1;
      let div2;
      let t2;
      let div3;
      const block = {
        c: function create() {
          div4 = element("div");
          div0 = element("div");
          t0 = space();
          div1 = element("div");
          t1 = space();
          div2 = element("div");
          t2 = space();
          div3 = element("div");
          attr_dev(div0, "class", "guide v-half svelte-1ffk99m");
          add_location(div0, file$1, 558, 6, 13686);
          attr_dev(div1, "class", "guide h-half svelte-1ffk99m");
          add_location(div1, file$1, 559, 6, 13721);
          attr_dev(div2, "class", "guide mempool-height svelte-1ffk99m");
          add_location(div2, file$1, 560, 6, 13756);
          attr_dev(div3, "class", "area block-area");
          add_location(div3, file$1, 561, 6, 13799);
          attr_dev(div4, "class", "guide-overlay svelte-1ffk99m");
          add_location(div4, file$1, 557, 4, 13652);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          append_dev(div4, div0);
          append_dev(div4, t0);
          append_dev(div4, div1);
          append_dev(div4, t1);
          append_dev(div4, div2);
          append_dev(div4, t2);
          append_dev(div4, div3);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div4);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block.name,
        type: "if",
        source: "(557:2) {#if config.dev && config.debug && $devSettings.guides }",
        ctx
      });
      return block;
    }

    function create_fragment$1(ctx) {
      let div13;
      let div8;
      let txrender;
      let t0;
      let div1;
      let div0;
      let t1;
      let t2;
      let div7;
      let div2;
      let t3;
      let div4;
      let div3;
      let blockinfo;
      let t4;
      let t5;
      let div5;
      let t6;
      let div6;
      let t7;
      let t8;
      let div12;
      let div11;
      let div9;
      let t9;
      let t10;
      let div10;
      let t11;
      let t12;
      let t13;
      let sidebar;
      let t14;
      let transactionoverlay;
      let t15;
      let aboutoverlay;
      let t16;
      let t17;
      let t18;
      let current;
      let mounted;
      let dispose;
      txrender = new TxRender({
        props: {
          controller:
          /*txController*/
          ctx[0]
        },
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*$tinyScreen*/
        ctx[12]) return create_if_block_12;
        return create_else_block_1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);
      blockinfo = new BlockInfo({
        props: {
          block:
          /*$currentBlock*/
          ctx[14],
          visible:
          /*$blockVisible*/
          ctx[2] && !
          /*$tinyScreen*/
          ctx[12]
        },
        $$inline: true
      });
      blockinfo.$on("hideBlock",
      /*hideBlock*/
      ctx[22]);
      blockinfo.$on("quitExploring",
      /*quitExploring*/
      ctx[23]);
      let if_block1 = config$1.dev && config$1.debug &&
      /*$devSettings*/
      ctx[15].guides && create_if_block_11(ctx);
      let if_block2 =
      /*$selectedTx*/
      ctx[16] && create_if_block_10(ctx);
      let if_block3 =
      /*$settings*/
      ctx[1].showFX &&
      /*fxLabel*/
      ctx[5] && create_if_block_9(ctx);
      let if_block4 =
      /*$tinyScreen*/
      ctx[12] &&
      /*$currentBlock*/
      ctx[14] && create_if_block_8(ctx);
      let if_block5 =
      /*$settings*/
      ctx[1].showNetworkStatus && create_if_block_7(ctx);
      let if_block6 =
      /*$settings*/
      ctx[1].showSearch && !
      /*$tinyScreen*/
      ctx[12] && !
      /*$compactScreen*/
      ctx[18] && create_if_block_6(ctx);
      let if_block7 = !
      /*$tinyScreen*/
      ctx[12] && create_if_block_4(ctx);
      sidebar = new Sidebar({
        $$inline: true
      });
      transactionoverlay = new TransactionOverlay({
        $$inline: true
      });
      aboutoverlay = new AboutOverlay({
        $$inline: true
      });
      let if_block8 = config$1.donationsEnabled && create_if_block_2(ctx);
      let if_block9 =
      /*$loading*/
      ctx[20] && create_if_block_1(ctx);
      let if_block10 = config$1.dev && config$1.debug &&
      /*$devSettings*/
      ctx[15].guides && create_if_block(ctx);
      const block = {
        c: function create() {
          div13 = element("div");
          div8 = element("div");
          create_component(txrender.$$.fragment);
          t0 = space();
          div1 = element("div");
          div0 = element("div");
          t1 = space();
          if_block0.c();
          t2 = space();
          div7 = element("div");
          div2 = element("div");
          t3 = space();
          div4 = element("div");
          div3 = element("div");
          create_component(blockinfo.$$.fragment);
          t4 = space();
          if (if_block1) if_block1.c();
          t5 = space();
          div5 = element("div");
          t6 = space();
          div6 = element("div");
          t7 = space();
          if (if_block2) if_block2.c();
          t8 = space();
          div12 = element("div");
          div11 = element("div");
          div9 = element("div");
          if (if_block3) if_block3.c();
          t9 = space();
          if (if_block4) if_block4.c();
          t10 = space();
          div10 = element("div");
          if (if_block5) if_block5.c();
          t11 = space();
          if (if_block6) if_block6.c();
          t12 = space();
          if (if_block7) if_block7.c();
          t13 = space();
          create_component(sidebar.$$.fragment);
          t14 = space();
          create_component(transactionoverlay.$$.fragment);
          t15 = space();
          create_component(aboutoverlay.$$.fragment);
          t16 = space();
          if (if_block8) if_block8.c();
          t17 = space();
          if (if_block9) if_block9.c();
          t18 = space();
          if (if_block10) if_block10.c();
          attr_dev(div0, "class", "height-bar svelte-1ffk99m");
          add_location(div0, file$1, 474, 6, 11013);
          attr_dev(div1, "class", "mempool-height svelte-1ffk99m");
          set_style(div1, "bottom", "calc(" + (
          /*$mempoolScreenHeight*/
          ctx[11] + 20) + "px)");
          add_location(div1, file$1, 473, 4, 10926);
          attr_dev(div2, "class", "spacer svelte-1ffk99m");
          set_style(div2, "flex",
          /*$pageWidth*/
          ctx[9] <= 640 ? '1.5' : '1');
          add_location(div2, file$1, 486, 6, 11442);
          attr_dev(div3, "class", "block-area svelte-1ffk99m");
          add_location(div3, file$1, 488, 8, 11624);
          attr_dev(div4, "class", "block-area-outer svelte-1ffk99m");
          set_style(div4, "width",
          /*$blockAreaSize*/
          ctx[13] + "px");
          set_style(div4, "height",
          /*$blockAreaSize*/
          ctx[13] + "px");
          add_location(div4, file$1, 487, 6, 11523);
          attr_dev(div5, "class", "spacer svelte-1ffk99m");
          add_location(div5, file$1, 495, 6, 11943);
          attr_dev(div6, "class", "spacer svelte-1ffk99m");
          add_location(div6, file$1, 496, 6, 11976);
          attr_dev(div7, "class", "block-area-wrapper svelte-1ffk99m");
          add_location(div7, file$1, 485, 4, 11403);
          attr_dev(div8, "class", "canvas-wrapper svelte-1ffk99m");
          add_location(div8, file$1, 470, 2, 10770);
          attr_dev(div9, "class", "row svelte-1ffk99m");
          add_location(div9, file$1, 506, 6, 12191);
          attr_dev(div10, "class", "row svelte-1ffk99m");
          add_location(div10, file$1, 514, 6, 12558);
          attr_dev(div11, "class", "status svelte-1ffk99m");
          toggle_class(div11, "tiny",
          /*$tinyScreen*/
          ctx[12]);
          add_location(div11, file$1, 505, 4, 12139);
          attr_dev(div12, "class", "top-bar svelte-1ffk99m");
          add_location(div12, file$1, 504, 2, 12113);
          attr_dev(div13, "class", "tx-area svelte-1ffk99m");
          set_style(div13, "width",
          /*canvasWidth*/
          ctx[3]);
          set_style(div13, "height",
          /*canvasHeight*/
          ctx[4]);
          toggle_class(div13, "light-mode", !
          /*$settings*/
          ctx[1].darkMode);
          add_location(div13, file$1, 469, 0, 10654);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div13, anchor);
          append_dev(div13, div8);
          mount_component(txrender, div8, null);
          append_dev(div8, t0);
          append_dev(div8, div1);
          append_dev(div1, div0);
          append_dev(div1, t1);
          if_block0.m(div1, null);
          append_dev(div8, t2);
          append_dev(div8, div7);
          append_dev(div7, div2);
          append_dev(div7, t3);
          append_dev(div7, div4);
          append_dev(div4, div3);
          mount_component(blockinfo, div3, null);
          append_dev(div4, t4);
          if (if_block1) if_block1.m(div4, null);
          append_dev(div7, t5);
          append_dev(div7, div5);
          append_dev(div7, t6);
          append_dev(div7, div6);
          append_dev(div13, t7);
          if (if_block2) if_block2.m(div13, null);
          append_dev(div13, t8);
          append_dev(div13, div12);
          append_dev(div12, div11);
          append_dev(div11, div9);
          if (if_block3) if_block3.m(div9, null);
          append_dev(div9, t9);
          if (if_block4) if_block4.m(div9, null);
          append_dev(div11, t10);
          append_dev(div11, div10);
          if (if_block5) if_block5.m(div10, null);
          append_dev(div12, t11);
          if (if_block6) if_block6.m(div12, null);
          append_dev(div12, t12);
          if (if_block7) if_block7.m(div12, null);
          append_dev(div13, t13);
          mount_component(sidebar, div13, null);
          append_dev(div13, t14);
          mount_component(transactionoverlay, div13, null);
          append_dev(div13, t15);
          mount_component(aboutoverlay, div13, null);
          append_dev(div13, t16);
          if (if_block8) if_block8.m(div13, null);
          append_dev(div13, t17);
          if (if_block9) if_block9.m(div13, null);
          append_dev(div13, t18);
          if (if_block10) if_block10.m(div13, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(window_1, "resize",
            /*resize*/
            ctx[21], false, false, false), listen_dev(window_1, "load",
            /*resize*/
            ctx[21], false, false, false), listen_dev(window_1, "click",
            /*pointerLeave*/
            ctx[26], false, false, false), listen_dev(div8, "pointerleave",
            /*pointerLeave*/
            ctx[26], false, false, false), listen_dev(div8, "pointermove",
            /*pointerMove*/
            ctx[25], false, false, false), listen_dev(div8, "click",
            /*onClick*/
            ctx[24], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const txrender_changes = {};
          if (dirty[0] &
          /*txController*/
          1) txrender_changes.controller =
          /*txController*/
          ctx[0];
          txrender.$set(txrender_changes);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div1, null);
            }
          }

          if (!current || dirty[0] &
          /*$mempoolScreenHeight*/
          2048) {
            set_style(div1, "bottom", "calc(" + (
            /*$mempoolScreenHeight*/
            ctx[11] + 20) + "px)");
          }

          if (!current || dirty[0] &
          /*$pageWidth*/
          512) {
            set_style(div2, "flex",
            /*$pageWidth*/
            ctx[9] <= 640 ? '1.5' : '1');
          }

          const blockinfo_changes = {};
          if (dirty[0] &
          /*$currentBlock*/
          16384) blockinfo_changes.block =
          /*$currentBlock*/
          ctx[14];
          if (dirty[0] &
          /*$blockVisible, $tinyScreen*/
          4100) blockinfo_changes.visible =
          /*$blockVisible*/
          ctx[2] && !
          /*$tinyScreen*/
          ctx[12];
          blockinfo.$set(blockinfo_changes);

          if (config$1.dev && config$1.debug &&
          /*$devSettings*/
          ctx[15].guides) {
            if (if_block1) ; else {
              if_block1 = create_if_block_11(ctx);
              if_block1.c();
              if_block1.m(div4, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (!current || dirty[0] &
          /*$blockAreaSize*/
          8192) {
            set_style(div4, "width",
            /*$blockAreaSize*/
            ctx[13] + "px");
          }

          if (!current || dirty[0] &
          /*$blockAreaSize*/
          8192) {
            set_style(div4, "height",
            /*$blockAreaSize*/
            ctx[13] + "px");
          }

          if (
          /*$selectedTx*/
          ctx[16]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty[0] &
              /*$selectedTx*/
              65536) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_10(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div13, t8);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*$settings*/
          ctx[1].showFX &&
          /*fxLabel*/
          ctx[5]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_9(ctx);
              if_block3.c();
              if_block3.m(div9, t9);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if (
          /*$tinyScreen*/
          ctx[12] &&
          /*$currentBlock*/
          ctx[14]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block_8(ctx);
              if_block4.c();
              if_block4.m(div9, null);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }

          if (
          /*$settings*/
          ctx[1].showNetworkStatus) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block_7(ctx);
              if_block5.c();
              if_block5.m(div10, null);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if (dirty[0] &
          /*$tinyScreen*/
          4096) {
            toggle_class(div11, "tiny",
            /*$tinyScreen*/
            ctx[12]);
          }

          if (
          /*$settings*/
          ctx[1].showSearch && !
          /*$tinyScreen*/
          ctx[12] && !
          /*$compactScreen*/
          ctx[18]) {
            if (if_block6) {
              if (dirty[0] &
              /*$settings, $tinyScreen, $compactScreen*/
              266242) {
                transition_in(if_block6, 1);
              }
            } else {
              if_block6 = create_if_block_6(ctx);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(div12, t12);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }

          if (!
          /*$tinyScreen*/
          ctx[12]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);

              if (dirty[0] &
              /*$tinyScreen*/
              4096) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block_4(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div12, null);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }

          if (config$1.donationsEnabled) if_block8.p(ctx, dirty);

          if (
          /*$loading*/
          ctx[20]) {
            if (if_block9) {
              if (dirty[0] &
              /*$loading*/
              1048576) {
                transition_in(if_block9, 1);
              }
            } else {
              if_block9 = create_if_block_1(ctx);
              if_block9.c();
              transition_in(if_block9, 1);
              if_block9.m(div13, t18);
            }
          } else if (if_block9) {
            group_outros();
            transition_out(if_block9, 1, 1, () => {
              if_block9 = null;
            });
            check_outros();
          }

          if (config$1.dev && config$1.debug &&
          /*$devSettings*/
          ctx[15].guides) {
            if (if_block10) ; else {
              if_block10 = create_if_block(ctx);
              if_block10.c();
              if_block10.m(div13, null);
            }
          } else if (if_block10) {
            if_block10.d(1);
            if_block10 = null;
          }

          if (!current || dirty[0] &
          /*canvasWidth*/
          8) {
            set_style(div13, "width",
            /*canvasWidth*/
            ctx[3]);
          }

          if (!current || dirty[0] &
          /*canvasHeight*/
          16) {
            set_style(div13, "height",
            /*canvasHeight*/
            ctx[4]);
          }

          if (dirty[0] &
          /*$settings*/
          2) {
            toggle_class(div13, "light-mode", !
            /*$settings*/
            ctx[1].darkMode);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(txrender.$$.fragment, local);
          transition_in(blockinfo.$$.fragment, local);
          transition_in(if_block2);
          transition_in(if_block6);
          transition_in(if_block7);
          transition_in(sidebar.$$.fragment, local);
          transition_in(transactionoverlay.$$.fragment, local);
          transition_in(aboutoverlay.$$.fragment, local);
          transition_in(if_block8);
          transition_in(if_block9);
          current = true;
        },
        o: function outro(local) {
          transition_out(txrender.$$.fragment, local);
          transition_out(blockinfo.$$.fragment, local);
          transition_out(if_block2);
          transition_out(if_block6);
          transition_out(if_block7);
          transition_out(sidebar.$$.fragment, local);
          transition_out(transactionoverlay.$$.fragment, local);
          transition_out(aboutoverlay.$$.fragment, local);
          transition_out(if_block8);
          transition_out(if_block9);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div13);
          destroy_component(txrender);
          if_block0.d();
          destroy_component(blockinfo);
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          destroy_component(sidebar);
          destroy_component(transactionoverlay);
          destroy_component(aboutoverlay);
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          if (if_block10) if_block10.d();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$1.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const fxColor = 'good';

    function instance$1($$self, $$props, $$invalidate) {
      let connectionColor;
      let connectionTitle;
      let $settings;
      let $exchangeRates;
      let $serverDelay;
      let $serverConnected;
      let $blockVisible;
      let $freezeResize;
      let $pageHeight;
      let $pageWidth;
      let $devEvents;
      let $mempoolCount;
      let $lastBlockId;
      let $mempoolScreenHeight;
      let $tinyScreen;
      let $blockAreaSize;
      let $currentBlock;
      let $devSettings;
      let $selectedTx;
      let $sidebarToggle;
      let $compactScreen;
      let $haveSupporters;
      let $loading;
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(1, $settings = $$value));
      validate_store(exchangeRates, 'exchangeRates');
      component_subscribe($$self, exchangeRates, $$value => $$invalidate(29, $exchangeRates = $$value));
      validate_store(serverDelay, 'serverDelay');
      component_subscribe($$self, serverDelay, $$value => $$invalidate(30, $serverDelay = $$value));
      validate_store(serverConnected, 'serverConnected');
      component_subscribe($$self, serverConnected, $$value => $$invalidate(31, $serverConnected = $$value));
      validate_store(blockVisible, 'blockVisible');
      component_subscribe($$self, blockVisible, $$value => $$invalidate(2, $blockVisible = $$value));
      validate_store(freezeResize, 'freezeResize');
      component_subscribe($$self, freezeResize, $$value => $$invalidate(32, $freezeResize = $$value));
      validate_store(pageHeight, 'pageHeight');
      component_subscribe($$self, pageHeight, $$value => $$invalidate(37, $pageHeight = $$value));
      validate_store(pageWidth, 'pageWidth');
      component_subscribe($$self, pageWidth, $$value => $$invalidate(9, $pageWidth = $$value));
      validate_store(devEvents, 'devEvents');
      component_subscribe($$self, devEvents, $$value => $$invalidate(38, $devEvents = $$value));
      validate_store(mempoolCount, 'mempoolCount');
      component_subscribe($$self, mempoolCount, $$value => $$invalidate(10, $mempoolCount = $$value));
      validate_store(lastBlockId, 'lastBlockId');
      component_subscribe($$self, lastBlockId, $$value => $$invalidate(39, $lastBlockId = $$value));
      validate_store(mempoolScreenHeight, 'mempoolScreenHeight');
      component_subscribe($$self, mempoolScreenHeight, $$value => $$invalidate(11, $mempoolScreenHeight = $$value));
      validate_store(tinyScreen, 'tinyScreen');
      component_subscribe($$self, tinyScreen, $$value => $$invalidate(12, $tinyScreen = $$value));
      validate_store(blockAreaSize, 'blockAreaSize');
      component_subscribe($$self, blockAreaSize, $$value => $$invalidate(13, $blockAreaSize = $$value));
      validate_store(currentBlock, 'currentBlock');
      component_subscribe($$self, currentBlock, $$value => $$invalidate(14, $currentBlock = $$value));
      validate_store(devSettings, 'devSettings');
      component_subscribe($$self, devSettings, $$value => $$invalidate(15, $devSettings = $$value));
      validate_store(selectedTx, 'selectedTx');
      component_subscribe($$self, selectedTx, $$value => $$invalidate(16, $selectedTx = $$value));
      validate_store(sidebarToggle, 'sidebarToggle');
      component_subscribe($$self, sidebarToggle, $$value => $$invalidate(17, $sidebarToggle = $$value));
      validate_store(compactScreen, 'compactScreen');
      component_subscribe($$self, compactScreen, $$value => $$invalidate(18, $compactScreen = $$value));
      validate_store(haveSupporters, 'haveSupporters');
      component_subscribe($$self, haveSupporters, $$value => $$invalidate(19, $haveSupporters = $$value));
      validate_store(loading, 'loading');
      component_subscribe($$self, loading, $$value => $$invalidate(20, $loading = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('TxViz', slots, []);
      let width = window.innerWidth - 20;
      let height = window.innerHeight - 20;
      let txController;
      let blockCount = 0;
      let running = false;
      let lastFrameUpdate = 0;
      let txStream;
      if (!config$1.noTxFeed || !config$1.noBlockFeed) txStream = getTxStream();
      let modeLoaded = false;
      let currentMode;
      let canvasWidth = '100%';
      let canvasHeight = '100%';
      onMount(() => {
        $$invalidate(0, txController = new TxController({
          width,
          height
        }));

        if (!config$1.noTxFeed) {
          txStream.subscribe('tx', tx => {
            txController.addTx(tx);
          });
          txStream.subscribe('drop_tx', txid => {
            txController.dropTx(txid);
          });
        }

        if (!config$1.noBlockFeed) {
          txStream.subscribe('block', _ref => {
            let {
              block,
              realtime
            } = _ref;

            if (block) {
              const added = txController.addBlock(block, realtime);
              if (added && added.id) set_store_value(lastBlockId, $lastBlockId = added.id, $lastBlockId);
            }
          });
        }

        if (!config$1.noTxFeed || !config$1.noBlockFeed) {
          txStream.subscribe('mempool_count', count => {
            set_store_value(mempoolCount, $mempoolCount = count, $mempoolCount);
          });
        }

        set_store_value(devEvents, $devEvents.addOneCallback = fakeTx, $devEvents);
        set_store_value(devEvents, $devEvents.addManyCallback = fakeTxs, $devEvents);
        set_store_value(devEvents, $devEvents.addBlockCallback = fakeBlock, $devEvents);
      });

      function resize() {
        set_store_value(pageWidth, $pageWidth = window.innerWidth, $pageWidth);
        set_store_value(pageHeight, $pageHeight = window.innerHeight, $pageHeight);

        if ((width !== window.innerWidth - 20 || height !== window.innerHeight - 20) && !$freezeResize) {
          // don't force resize unless the viewport has actually changed
          width = window.innerWidth - 20;
          height = window.innerHeight - 20;
          txController.resize({
            width,
            height
          });
        }
      }

      function changedMode() {
        if (txController) {
          txController.redoLayout({
            width,
            height
          });
        }
      }

      function hideBlock() {
        set_store_value(blockVisible, $blockVisible = false, $blockVisible);
      }

      function quitExploring() {
        if (txController) txController.resumeLatest();
      }

      function fakeBlock() {
        txController.simulateBlock();
      } // txController.addBlock(new BitcoinBlock({
      //   version: 'fake',
      //   id: Math.random(),
      //   value: 10000,
      //   prev_block: 'also_fake',
      //   merkle_root: 'merkle',
      //   timestamp: performance.now(),
      //   bits: 'none',
      //   txn_count: 20,
      //   txns: (new Array(100)).fill(0).map((x, i) => {
      //     return {
      //       version: 'fictional',
      //       value: Math.floor(Math.random() * 1000000) + 1,
      //       id: `fake_tx_${i}_${Math.random()}`
      //     }
      //   })
      // }))


      function fakeTx(value) {
        txController.simulateDumpTx(1, value);
      }

      function fakeTxs() {
        txController.simulateDumpTx(200);
      }

      let fxLabel = '';

      const debounce = v => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          val = v;
        }, 750);
      };

      let mousePosition = {
        x: 0,
        y: 0
      };

      function onClick(e) {
        $$invalidate(6, mousePosition = {
          x: e.clientX,
          y: e.clientY
        });
        const position = {
          x: e.clientX,
          y: window.innerHeight - e.clientY
        };
        if (txController) txController.mouseClick(position);
      }

      function pointerMove(e) {
        if (!txController.selectionLocked) {
          $$invalidate(6, mousePosition = {
            x: e.clientX,
            y: e.clientY
          });
          const position = {
            x: e.clientX,
            y: window.innerHeight - e.clientY
          };
          if (txController) txController.mouseMove(position);
        }
      }

      function pointerLeave(e) {
        const position = {
          x: null,
          y: null
        };
        if (txController) txController.mouseMove(position);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TxViz> was created with unknown prop '${key}'`);
      });

      const click_handler = () => {
        set_store_value(sidebarToggle, $sidebarToggle = 'settings', $sidebarToggle);
      };

      $$self.$capture_state = () => ({
        onMount,
        TxController,
        TxRender,
        getTxStream,
        settings,
        overlay,
        serverConnected,
        serverDelay,
        txCount,
        mempoolCount,
        mempoolScreenHeight,
        blockVisible,
        tinyScreen,
        compactScreen,
        currentBlock,
        latestBlockHeight,
        selectedTx,
        blockAreaSize,
        devEvents,
        devSettings,
        pageWidth,
        pageHeight,
        loading,
        freezeResize,
        BlockInfo,
        SearchBar,
        TxInfo,
        Sidebar,
        TransactionOverlay,
        AboutOverlay,
        DonationOverlay,
        SupportersOverlay,
        LoadingAnimation,
        Alerts,
        numberFormat,
        exchangeRates,
        lastBlockId,
        haveSupporters,
        sidebarToggle,
        formatCurrency,
        fade,
        config: config$1,
        width,
        height,
        txController,
        blockCount,
        running,
        lastFrameUpdate,
        txStream,
        modeLoaded,
        currentMode,
        canvasWidth,
        canvasHeight,
        resize,
        changedMode,
        hideBlock,
        quitExploring,
        fakeBlock,
        fakeTx,
        fakeTxs,
        fxColor,
        fxLabel,
        debounce,
        mousePosition,
        onClick,
        pointerMove,
        pointerLeave,
        connectionTitle,
        connectionColor,
        $settings,
        $exchangeRates,
        $serverDelay,
        $serverConnected,
        $blockVisible,
        $freezeResize,
        $pageHeight,
        $pageWidth,
        $devEvents,
        $mempoolCount,
        $lastBlockId,
        $mempoolScreenHeight,
        $tinyScreen,
        $blockAreaSize,
        $currentBlock,
        $devSettings,
        $selectedTx,
        $sidebarToggle,
        $compactScreen,
        $haveSupporters,
        $loading
      });

      $$self.$inject_state = $$props => {
        if ('width' in $$props) width = $$props.width;
        if ('height' in $$props) height = $$props.height;
        if ('txController' in $$props) $$invalidate(0, txController = $$props.txController);
        if ('blockCount' in $$props) blockCount = $$props.blockCount;
        if ('running' in $$props) running = $$props.running;
        if ('lastFrameUpdate' in $$props) lastFrameUpdate = $$props.lastFrameUpdate;
        if ('txStream' in $$props) txStream = $$props.txStream;
        if ('modeLoaded' in $$props) $$invalidate(27, modeLoaded = $$props.modeLoaded);
        if ('currentMode' in $$props) $$invalidate(28, currentMode = $$props.currentMode);
        if ('canvasWidth' in $$props) $$invalidate(3, canvasWidth = $$props.canvasWidth);
        if ('canvasHeight' in $$props) $$invalidate(4, canvasHeight = $$props.canvasHeight);
        if ('fxLabel' in $$props) $$invalidate(5, fxLabel = $$props.fxLabel);
        if ('mousePosition' in $$props) $$invalidate(6, mousePosition = $$props.mousePosition);
        if ('connectionTitle' in $$props) $$invalidate(7, connectionTitle = $$props.connectionTitle);
        if ('connectionColor' in $$props) $$invalidate(8, connectionColor = $$props.connectionColor);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*$blockVisible, txController*/
        5) {
          {
            if ($blockVisible) {
              if (txController) txController.showBlock();
            } else {
              if (txController) txController.hideBlock();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$settings, currentMode, modeLoaded*/
        402653186) {
          {
            if ($settings && currentMode != $settings.vbytes) {
              if (!modeLoaded) $$invalidate(27, modeLoaded = true);else changedMode($settings.vbytes);
              $$invalidate(28, currentMode = $settings.vbytes);
            }
          }
        }

        if ($$self.$$.dirty[1] &
        /*$freezeResize*/
        2) {
          {
            if ($freezeResize) {
              $$invalidate(3, canvasWidth = `${window.innerWidth}px`);
              $$invalidate(4, canvasHeight = `${window.innerHeight}px`);
            } else {
              $$invalidate(3, canvasWidth = '100%');
              $$invalidate(4, canvasHeight = '100%');
              resize();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*$serverDelay*/
        1073741824 | $$self.$$.dirty[1] &
        /*$serverConnected*/
        1) {
          $$invalidate(8, connectionColor = $serverConnected && $serverDelay < 5000 ? $serverDelay < 500 ? 'good' : 'ok' : 'bad');
        }

        if ($$self.$$.dirty[0] &
        /*$serverDelay*/
        1073741824 | $$self.$$.dirty[1] &
        /*$serverConnected*/
        1) {
          $$invalidate(7, connectionTitle = $serverConnected && $serverDelay < 5000 ? $serverDelay < 500 ? 'Streaming live transactions' : 'Unstable connection' : 'Disconnected');
        }

        if ($$self.$$.dirty[0] &
        /*$exchangeRates, $settings*/
        536870914) {
          {
            const rate = $exchangeRates[$settings.currency];
            if (rate && rate.last) $$invalidate(5, fxLabel = formatCurrency($settings.currency, rate.last));
          }
        }
      };

      return [txController, $settings, $blockVisible, canvasWidth, canvasHeight, fxLabel, mousePosition, connectionTitle, connectionColor, $pageWidth, $mempoolCount, $mempoolScreenHeight, $tinyScreen, $blockAreaSize, $currentBlock, $devSettings, $selectedTx, $sidebarToggle, $compactScreen, $haveSupporters, $loading, resize, hideBlock, quitExploring, onClick, pointerMove, pointerLeave, modeLoaded, currentMode, $exchangeRates, $serverDelay, $serverConnected, $freezeResize, click_handler];
    }

    class TxViz extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$1, create_fragment$1, safe_not_equal, {}, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TxViz",
          options,
          id: create_fragment$1.name
        });
      }

    }

    class Router {
      constructor() {
        let initialPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
        this.path = initialPath;
        this.apply(initialPath);
        urlPath.subscribe(val => {
          if (val != null) {
            this.pushHistory(val);
            this.path = val;
          }
        });
        window.addEventListener('popstate', e => {
          if (e && e.state && e.state.path) {
            this.path = e.state.path;
            this.apply(e.state.path);
          }
        });
      }

      pushHistory(path) {
        let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (replace) {
          window.history.replaceState({
            path
          }, "", path, window.history.state);
        } else if (path !== this.path) {
          window.history.pushState({
            path
          }, "", path);
        }
      }

      clearPath() {
        urlPath.set("/");
      }

      apply(path) {
        const parts = path.split("/");

        if (path === '/') {
          detailTx.set(null);
          highlightInOut.set(null);
          urlPath.set("/");
          explorerBlock.set(null);
          overlay.set(null);
        } else {
          switch (parts[1]) {
            case 'block':
              if (parts[2] === "height") {
                try {
                  const height = parseInt(parts[3]);
                  this.goToBlockHeight(height);
                } catch (err) {// ??
                }
              } else if (parts[2]) {
                this.goToBlock(parts[2]);
              }

              break;

            case 'tx':
              if (parts[2]) {
                this.goToTransaction(parts[2]);
              }

              break;

            case 'donate':
              overlay.set('donation');
              break;
          }
        }
      }

      async goToBlock(blockhash) {
        loading.increment();
        await searchBlockHash(blockhash);
        loading.decrement();
      }

      async goToBlockHeight(height) {
        loading.increment();
        await searchBlockHeight(height);
        loading.decrement();
      }

      async goToTransaction(q) {
        loading.increment();
        const parts = q.split(":");
        let txid, input, output;

        if (parts.length) {
          if (parts[0].length == 64) {
            txid = parts[0];
            output = parseInt(parts[1]);
            if (isNaN(output)) output = null;
          } else if (parts[1].length == 64) {
            txid = parts[1];
            input = parseInt(parts[0]);
            if (isNaN(input)) input = null;
          } else ;
        } else {
          txid = q;
        }

        await searchTx(txid, input, output);
        loading.decrement();
      }

    }

    /* src/App.svelte generated by Svelte v3.44.3 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
      let main;
      let txviz;
      let current;
      txviz = new TxViz({
        $$inline: true
      });
      const block = {
        c: function create() {
          main = element("main");
          create_component(txviz.$$.fragment);
          attr_dev(main, "class", "svelte-1juftbx");
          add_location(main, file, 12, 0, 345);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          mount_component(txviz, main, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(txviz.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(txviz.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);
          destroy_component(txviz);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance($$self, $$props, $$invalidate) {
      let $settings;
      validate_store(settings, 'settings');
      component_subscribe($$self, settings, $$value => $$invalidate(0, $settings = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots('App', slots, []);
      if (!$settings.noTrack && config$1.public) analytics.init();
      const router = new Router(window.location.pathname);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        TxViz,
        analytics,
        config: config$1,
        Router,
        settings,
        router,
        $settings
      });

      return [];
    }

    class App extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance, create_fragment, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "App",
          options,
          id: create_fragment.name
        });
      }

    }

    const app = new App({
      target: document.body,
      props: {}
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
